
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o basic.prg -L basic.lst -l basic.lbl basic.asm
; Fri Feb 07 22:37:48 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: code/data.asm

.0000					codePtr:
>0000							.word 	?
.0002					zTemp1:
>0002							.word 	?
.0004					zTemp2:
>0004							.word 	?
.0006					zTemp3:
>0006							.word 	?
.0008					zTemp4:
>0008							.word 	?
=$600					xsStatus = $600								; expression stack.
=$620					xsAddrLow = $620 							; these values are shared depending on type.
=$640					xsAddrHigh = $640
=$620					xsIntLow = xsAddrLow
=$640					xsIntHigh = xsAddrHigh
=$620					xsMantissa3 = xsAddrLow
=$640					xsMantissa2 = xsAddrHigh
=$660					xsMantissa1 = $660
=$680					xsMantissa0 = $680
=$6a0					xsExponent = $6A0

;******  Return to file: basic.asm


;******  Processing file: code/macros.asm


;******  Return to file: basic.asm

.6000	4c 93 62	jmp $6293			jmp 	ColdStart

;******  Processing file: files.asm

.6003					TokenTextTable:

;******  Processing file: generated/tokentext.inc

>6003	05 7b 45 4f 4c fd			.byte	$05,$7b,$45,$4f,$4c,$fd                  ; $80 : {eol}
>6009	03 41 4e c4				.byte	$03,$41,$4e,$c4                          ; $81 : and
>600d	02 4f d2				.byte	$02,$4f,$d2                              ; $82 : or
>6010	03 58 4f d2				.byte	$03,$58,$4f,$d2                          ; $83 : xor
>6014	01 be					.byte	$01,$be                                  ; $84 : >
>6016	02 3e bd				.byte	$02,$3e,$bd                              ; $85 : >=
>6019	01 bc					.byte	$01,$bc                                  ; $86 : <
>601b	02 3c bd				.byte	$02,$3c,$bd                              ; $87 : <=
>601e	01 bd					.byte	$01,$bd                                  ; $88 : =
>6020	02 3c be				.byte	$02,$3c,$be                              ; $89 : <>
>6023	01 ab					.byte	$01,$ab                                  ; $8a : +
>6025	01 ad					.byte	$01,$ad                                  ; $8b : -
>6027	01 aa					.byte	$01,$aa                                  ; $8c : *
>6029	01 af					.byte	$01,$af                                  ; $8d : /
>602b	03 4d 4f c4				.byte	$03,$4d,$4f,$c4                          ; $8e : mod
>602f	04 4c 45 4e a8				.byte	$04,$4c,$45,$4e,$a8                      ; $8f : len(
>6034	04 52 4e 44 a8				.byte	$04,$52,$4e,$44,$a8                      ; $90 : rnd(
>6039	04 41 53 43 a8				.byte	$04,$41,$53,$43,$a8                      ; $91 : asc(
>603e	05 43 48 52 24 a8			.byte	$05,$43,$48,$52,$24,$a8                  ; $92 : chr$(
>6044	04 56 41 4c a8				.byte	$04,$56,$41,$4c,$a8                      ; $93 : val(
>6049	05 53 54 52 24 a8			.byte	$05,$53,$54,$52,$24,$a8                  ; $94 : str$(
>604f	04 53 50 43 a8				.byte	$04,$53,$50,$43,$a8                      ; $95 : spc(
>6054	06 4c 45 46 54 24 a8			.byte	$06,$4c,$45,$46,$54,$24,$a8              ; $96 : left$(
>605b	05 4d 49 44 24 a8			.byte	$05,$4d,$49,$44,$24,$a8                  ; $97 : mid$(
>6061	07 52 49 47 48 54 24 a8			.byte	$07,$52,$49,$47,$48,$54,$24,$a8          ; $98 : right$(
>6069	04 41 42 53 a8				.byte	$04,$41,$42,$53,$a8                      ; $99 : abs(
>606e	04 53 47 4e a8				.byte	$04,$53,$47,$4e,$a8                      ; $9a : sgn(
>6073	04 49 4e 54 a8				.byte	$04,$49,$4e,$54,$a8                      ; $9b : int(
>6078	05 44 45 45 4b a8			.byte	$05,$44,$45,$45,$4b,$a8                  ; $9c : deek(
>607e	05 50 45 45 4b a8			.byte	$05,$50,$45,$45,$4b,$a8                  ; $9d : peek(
>6084	06 56 50 45 45 4b a8			.byte	$06,$56,$50,$45,$45,$4b,$a8              ; $9e : vpeek(
>608b	01 a8					.byte	$01,$a8                                  ; $9f : (
>608d	01 a5					.byte	$01,$a5                                  ; $a0 : %
>608f	01 a4					.byte	$01,$a4                                  ; $a1 : $
>6091	02 49 c6				.byte	$02,$49,$c6                              ; $a2 : if
>6094	06 52 45 50 45 41 d4			.byte	$06,$52,$45,$50,$45,$41,$d4              ; $a3 : repeat
>609b	03 46 4f d2				.byte	$03,$46,$4f,$d2                          ; $a4 : for
>609f	05 57 48 49 4c c5			.byte	$05,$57,$48,$49,$4c,$c5                  ; $a5 : while
>60a5	04 43 41 53 c5				.byte	$04,$43,$41,$53,$c5                      ; $a6 : case
>60aa	04 54 48 45 ce				.byte	$04,$54,$48,$45,$ce                      ; $a7 : then
>60af	05 45 4e 44 49 c6			.byte	$05,$45,$4e,$44,$49,$c6                  ; $a8 : endif
>60b5	05 55 4e 54 49 cc			.byte	$05,$55,$4e,$54,$49,$cc                  ; $a9 : until
>60bb	04 4e 45 58 d4				.byte	$04,$4e,$45,$58,$d4                      ; $aa : next
>60c0	08 45 4e 44 57 48 49 4c			.byte	$08,$45,$4e,$44,$57,$48,$49,$4c,$c5      ; $ab : endwhile
>60c8	c5
>60c9	07 45 4e 44 43 41 53 c5			.byte	$07,$45,$4e,$44,$43,$41,$53,$c5          ; $ac : endcase
>60d1	02 54 cf				.byte	$02,$54,$cf                              ; $ad : to
>60d4	04 53 54 45 d0				.byte	$04,$53,$54,$45,$d0                      ; $ae : step
>60d9	07 44 45 46 50 52 4f c3			.byte	$07,$44,$45,$46,$50,$52,$4f,$c3          ; $af : defproc
>60e1	07 45 4e 44 50 52 4f c3			.byte	$07,$45,$4e,$44,$50,$52,$4f,$c3          ; $b0 : endproc
>60e9	04 50 52 4f c3				.byte	$04,$50,$52,$4f,$c3                      ; $b1 : proc
>60ee	05 4c 4f 43 41 cc			.byte	$05,$4c,$4f,$43,$41,$cc                  ; $b2 : local
>60f4	03 4c 45 d4				.byte	$03,$4c,$45,$d4                          ; $b3 : let
>60f8	03 52 55 ce				.byte	$03,$52,$55,$ce                          ; $b4 : run
>60fc	04 53 54 4f d0				.byte	$04,$53,$54,$4f,$d0                      ; $b5 : stop
>6101	03 45 4e c4				.byte	$03,$45,$4e,$c4                          ; $b6 : end
>6105	05 50 52 49 4e d4			.byte	$05,$50,$52,$49,$4e,$d4                  ; $b7 : print
>610b	05 49 4e 50 55 d4			.byte	$05,$49,$4e,$50,$55,$d4                  ; $b8 : input
>6111	04 57 48 45 ce				.byte	$04,$57,$48,$45,$ce                      ; $b9 : when
>6116	07 44 45 46 41 55 4c d4			.byte	$07,$44,$45,$46,$41,$55,$4c,$d4          ; $ba : default
>611e	06 4f 50 54 49 4f ce			.byte	$06,$4f,$50,$54,$49,$4f,$ce              ; $bb : option
>6125	04 4c 49 53 d4				.byte	$04,$4c,$49,$53,$d4                      ; $bc : list
>612a	04 4c 4f 41 c4				.byte	$04,$4c,$4f,$41,$c4                      ; $bd : load
>612f	04 53 41 56 c5				.byte	$04,$53,$41,$56,$c5                      ; $be : save
>6134	03 4e 45 d7				.byte	$03,$4e,$45,$d7                          ; $bf : new
>6138	03 4f 4c c4				.byte	$03,$4f,$4c,$c4                          ; $c0 : old
>613c	04 50 4f 4b c5				.byte	$04,$50,$4f,$4b,$c5                      ; $c1 : poke
>6141	04 44 4f 4b c5				.byte	$04,$44,$4f,$4b,$c5                      ; $c2 : doke
>6146	05 56 50 4f 4b c5			.byte	$05,$56,$50,$4f,$4b,$c5                  ; $c3 : vpoke
>614c	03 52 45 cd				.byte	$03,$52,$45,$cd                          ; $c4 : rem
>6150	04 47 4f 54 cf				.byte	$04,$47,$4f,$54,$cf                      ; $c5 : goto
>6155	05 47 4f 53 55 c2			.byte	$05,$47,$4f,$53,$55,$c2                  ; $c6 : gosub
>615b	01 a9					.byte	$01,$a9                                  ; $c7 : )
>615d	01 ba					.byte	$01,$ba                                  ; $c8 : :
>615f	00					.byte	$00

;******  Return to file: files.asm

.6160					TokenControlByteTable:

;******  Processing file: generated/tokencbyte.inc

>6160	00					.byte	$00		; $80 : {eol}
>6161	10					.byte	$10		; $81 : and
>6162	10					.byte	$10		; $82 : or
>6163	10					.byte	$10		; $83 : xor
>6164	11					.byte	$11		; $84 : >
>6165	11					.byte	$11		; $85 : >=
>6166	11					.byte	$11		; $86 : <
>6167	11					.byte	$11		; $87 : <=
>6168	11					.byte	$11		; $88 : =
>6169	11					.byte	$11		; $89 : <>
>616a	12					.byte	$12		; $8a : +
>616b	12					.byte	$12		; $8b : -
>616c	13					.byte	$13		; $8c : *
>616d	13					.byte	$13		; $8d : /
>616e	13					.byte	$13		; $8e : mod
>616f	40					.byte	$40		; $8f : len(
>6170	40					.byte	$40		; $90 : rnd(
>6171	40					.byte	$40		; $91 : asc(
>6172	40					.byte	$40		; $92 : chr$(
>6173	40					.byte	$40		; $93 : val(
>6174	40					.byte	$40		; $94 : str$(
>6175	40					.byte	$40		; $95 : spc(
>6176	40					.byte	$40		; $96 : left$(
>6177	40					.byte	$40		; $97 : mid$(
>6178	40					.byte	$40		; $98 : right$(
>6179	40					.byte	$40		; $99 : abs(
>617a	40					.byte	$40		; $9a : sgn(
>617b	40					.byte	$40		; $9b : int(
>617c	40					.byte	$40		; $9c : deek(
>617d	40					.byte	$40		; $9d : peek(
>617e	40					.byte	$40		; $9e : vpeek(
>617f	40					.byte	$40		; $9f : (
>6180	40					.byte	$40		; $a0 : %
>6181	40					.byte	$40		; $a1 : $
>6182	82					.byte	$82		; $a2 : if
>6183	82					.byte	$82		; $a3 : repeat
>6184	82					.byte	$82		; $a4 : for
>6185	82					.byte	$82		; $a5 : while
>6186	82					.byte	$82		; $a6 : case
>6187	80					.byte	$80		; $a7 : then
>6188	80					.byte	$80		; $a8 : endif
>6189	80					.byte	$80		; $a9 : until
>618a	80					.byte	$80		; $aa : next
>618b	80					.byte	$80		; $ab : endwhile
>618c	80					.byte	$80		; $ac : endcase
>618d	81					.byte	$81		; $ad : to
>618e	81					.byte	$81		; $ae : step
>618f	81					.byte	$81		; $af : defproc
>6190	81					.byte	$81		; $b0 : endproc
>6191	81					.byte	$81		; $b1 : proc
>6192	81					.byte	$81		; $b2 : local
>6193	81					.byte	$81		; $b3 : let
>6194	81					.byte	$81		; $b4 : run
>6195	81					.byte	$81		; $b5 : stop
>6196	81					.byte	$81		; $b6 : end
>6197	81					.byte	$81		; $b7 : print
>6198	81					.byte	$81		; $b8 : input
>6199	81					.byte	$81		; $b9 : when
>619a	81					.byte	$81		; $ba : default
>619b	81					.byte	$81		; $bb : option
>619c	81					.byte	$81		; $bc : list
>619d	81					.byte	$81		; $bd : load
>619e	81					.byte	$81		; $be : save
>619f	81					.byte	$81		; $bf : new
>61a0	81					.byte	$81		; $c0 : old
>61a1	81					.byte	$81		; $c1 : poke
>61a2	81					.byte	$81		; $c2 : doke
>61a3	81					.byte	$81		; $c3 : vpoke
>61a4	81					.byte	$81		; $c4 : rem
>61a5	81					.byte	$81		; $c5 : goto
>61a6	81					.byte	$81		; $c6 : gosub
>61a7	00					.byte	$00		; $c7 : )
>61a8	00					.byte	$00		; $c8 : :

;******  Return to file: files.asm

.61a9					TokenVectors:

;******  Processing file: generated/tokenvectors.inc

>61a9	ab 62					.word	SyntaxError     		; $80 : {eol}
>61ab	ab 62					.word	SyntaxError     		; $81 : and
>61ad	ab 62					.word	SyntaxError     		; $82 : or
>61af	ab 62					.word	SyntaxError     		; $83 : xor
>61b1	ab 62					.word	SyntaxError     		; $84 : >
>61b3	ab 62					.word	SyntaxError     		; $85 : >=
>61b5	ab 62					.word	SyntaxError     		; $86 : <
>61b7	ab 62					.word	SyntaxError     		; $87 : <=
>61b9	ab 62					.word	SyntaxError     		; $88 : =
>61bb	ab 62					.word	SyntaxError     		; $89 : <>
>61bd	ab 62					.word	SyntaxError     		; $8a : +
>61bf	ab 62					.word	SyntaxError     		; $8b : -
>61c1	ab 62					.word	SyntaxError     		; $8c : *
>61c3	ab 62					.word	SyntaxError     		; $8d : /
>61c5	ab 62					.word	SyntaxError     		; $8e : mod
>61c7	ab 62					.word	SyntaxError     		; $8f : len(
>61c9	ab 62					.word	SyntaxError     		; $90 : rnd(
>61cb	ab 62					.word	SyntaxError     		; $91 : asc(
>61cd	ab 62					.word	SyntaxError     		; $92 : chr$(
>61cf	ab 62					.word	SyntaxError     		; $93 : val(
>61d1	ab 62					.word	SyntaxError     		; $94 : str$(
>61d3	ab 62					.word	SyntaxError     		; $95 : spc(
>61d5	ab 62					.word	SyntaxError     		; $96 : left$(
>61d7	ab 62					.word	SyntaxError     		; $97 : mid$(
>61d9	ab 62					.word	SyntaxError     		; $98 : right$(
>61db	ab 62					.word	SyntaxError     		; $99 : abs(
>61dd	ab 62					.word	SyntaxError     		; $9a : sgn(
>61df	ab 62					.word	SyntaxError     		; $9b : int(
>61e1	ab 62					.word	SyntaxError     		; $9c : deek(
>61e3	ab 62					.word	SyntaxError     		; $9d : peek(
>61e5	ab 62					.word	SyntaxError     		; $9e : vpeek(
>61e7	ab 62					.word	SyntaxError     		; $9f : (
>61e9	ab 62					.word	SyntaxError     		; $a0 : %
>61eb	ab 62					.word	SyntaxError     		; $a1 : $
>61ed	ab 62					.word	SyntaxError     		; $a2 : if
>61ef	ab 62					.word	SyntaxError     		; $a3 : repeat
>61f1	ab 62					.word	SyntaxError     		; $a4 : for
>61f3	ab 62					.word	SyntaxError     		; $a5 : while
>61f5	ab 62					.word	SyntaxError     		; $a6 : case
>61f7	ab 62					.word	SyntaxError     		; $a7 : then
>61f9	ab 62					.word	SyntaxError     		; $a8 : endif
>61fb	ab 62					.word	SyntaxError     		; $a9 : until
>61fd	ab 62					.word	SyntaxError     		; $aa : next
>61ff	ab 62					.word	SyntaxError     		; $ab : endwhile
>6201	ab 62					.word	SyntaxError     		; $ac : endcase
>6203	ab 62					.word	SyntaxError     		; $ad : to
>6205	ab 62					.word	SyntaxError     		; $ae : step
>6207	ab 62					.word	SyntaxError     		; $af : defproc
>6209	ab 62					.word	SyntaxError     		; $b0 : endproc
>620b	ab 62					.word	SyntaxError     		; $b1 : proc
>620d	ab 62					.word	SyntaxError     		; $b2 : local
>620f	ab 62					.word	SyntaxError     		; $b3 : let
>6211	ab 62					.word	SyntaxError     		; $b4 : run
>6213	ab 62					.word	SyntaxError     		; $b5 : stop
>6215	ab 62					.word	SyntaxError     		; $b6 : end
>6217	ab 62					.word	SyntaxError     		; $b7 : print
>6219	ab 62					.word	SyntaxError     		; $b8 : input
>621b	ab 62					.word	SyntaxError     		; $b9 : when
>621d	ab 62					.word	SyntaxError     		; $ba : default
>621f	ab 62					.word	SyntaxError     		; $bb : option
>6221	ab 62					.word	SyntaxError     		; $bc : list
>6223	ab 62					.word	SyntaxError     		; $bd : load
>6225	ab 62					.word	SyntaxError     		; $be : save
>6227	ab 62					.word	SyntaxError     		; $bf : new
>6229	ab 62					.word	SyntaxError     		; $c0 : old
>622b	ab 62					.word	SyntaxError     		; $c1 : poke
>622d	ab 62					.word	SyntaxError     		; $c2 : doke
>622f	ab 62					.word	SyntaxError     		; $c3 : vpoke
>6231	ab 62					.word	SyntaxError     		; $c4 : rem
>6233	ab 62					.word	SyntaxError     		; $c5 : goto
>6235	ab 62					.word	SyntaxError     		; $c6 : gosub
>6237	ab 62					.word	SyntaxError     		; $c7 : )
>6239	ab 62					.word	SyntaxError     		; $c8 : :

;******  Return to file: files.asm


;******  Processing file: expression/evaluate.asm

.623b					EvaluateExpression:
.623b	a2 00		ldx #$00			ldx 	#0 							; reset the evaluation stack pointer in X
.623d					EvalutateExpressionAtX:
.623d	a9 10		lda #$10			lda 	#$10 						; this is the lowest precedence.
.623f					EvaluateExpressionAtXPrecA:
.623f	48		pha				pha 								; save lowest stack level.
.6240	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first term.
.6242	30 4b		bmi $628f			bmi 	_EXAKeywordData 			; is it keyword, or data.
.6244	c9 60		cmp #$60			cmp 	#$60 						; is it a variable
.6246	90 46		bcc $628e			bcc 	_EXAVariable
.6248	c8		iny				iny 								; skip over the short constant
.6249	29 1f		and #$1f			and 	#$1F 						; short constant $00-$1F
.624b	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and put as an integer
.624e	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.6251	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; integer, number, not a reference.
.6254					_EXAHaveTerm:
.6254	68		pla				pla 	 							; restore current precedence and save in zTemp1
.6255	85 02		sta $02				sta 	zTemp1
.6257	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by a binary operation.
.6259	da		phx				phx
.625a	aa		tax				tax
.625b	bd e0 60	lda $60e0,x			lda 	TokenControlByteTable-$80,x ; get the control byte.
.625e	fa		plx				plx
.625f	c9 20		cmp #$20			cmp 	#$20 						; must be $10-$17 (or possibly $00, will be < precedence)
.6261	b0 06		bcs $6269			bcs 	_EXAExit
.6263	c5 02		cmp $02				cmp 	zTemp1 						; check against current precedence.
.6265	f0 02		beq $6269			beq 	_EXAExit
.6267	b0 01		bcs $626a			bcs		_EXABinaryOp 				; if >, do a binary operation.
.6269					_EXAExit:
.6269	60		rts				rts 								; exit expression evaluation.
.626a					_EXABinaryOp:
.626a	85 03		sta $03				sta 	zTemp1+1 					; save operator.
.626c	a5 02		lda $02				lda 	zTemp1 						; get and save current precedence
.626e	48		pha				pha
.626f	b1 00		lda ($00),y			lda 	(codePtr),y 				; push binary operator on stack
.6271	48		pha				pha
.6272	c8		iny				iny 								; and skip over it.
.6273	e8		inx				inx 								; calculate the RHS in the next slot up.
.6274	a5 03		lda $03				lda 	zTemp1+1 					; at operator precedence level.
.6276	20 3f 62	jsr $623f			jsr 	EvaluateExpressionAtXPrecA
.6279	ca		dex				dex
.627a	68		pla				pla 								; get binary operator.
.627b	da		phx				phx 								; save stack depth.
.627c	0a		asl a				asl 	a 							; double binary operator and put into X, loses MSB
.627d	aa		tax				tax
.627e	bd a9 61	lda $61a9,x			lda 	TokenVectors,x 				; get address => zTemp2
.6281	85 04		sta $04				sta 	zTemp2
.6283	bd aa 61	lda $61aa,x			lda 	TokenVectors+1,x
.6286	85 05		sta $05				sta 	zTemp2+1
.6288	fa		plx				plx 								; restore stack depth.
.6289	20 90 62	jsr $6290			jsr 	_EXACallZTemp2 				; call the routine
.628c	80 c6		bra $6254			bra 	_EXAHaveTerm 				; and loop round again.
.628e					_EXAVariable:
>628e	ff						.byte 	$FF
.628f					_EXAKeywordData:
>628f	ff						.byte 	$FF
.6290					_EXACallZTemp2:
.6290	6c 04 00	jmp ($0004)			jmp 	(zTemp2)

;******  Return to file: files.asm


;******  Return to file: basic.asm

.6293					ColdStart:
.6293	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.6295	9a		txs				txs
.6296	a9 a7		lda #$a7			lda 	#(TestProgram) & $FF
.6298	85 00		sta $00				sta 	0+(codePtr)
.629a	a9 62		lda #$62			lda 	#(TestProgram) >> 8
.629c	85 01		sta $01				sta 	1+(codePtr)
.629e	a0 00		ldy #$00			ldy 	#0
>62a0	ff						.byte 	$FF
.62a1	20 3b 62	jsr $623b			jsr 	EvaluateExpression
.62a4	4c ff ff	jmp $ffff			jmp 	$FFFF
.62a7					TestProgram:

;******  Processing file: generated/testcode.inc

>62a7	6c 8a 64				.byte	$6c,$8a,$64

;******  Return to file: basic.asm

>62aa	80						.byte 	$80
.62ab					SyntaxError:
.62ab	a2 5e		ldx #$5e			ldx 	#$5E
>62ad	ff						.byte 	$FF

;******  End of listing
