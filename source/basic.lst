
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o basic.prg -L basic.lst -l basic.lbl basic.asm
; Sat Feb 08 06:25:43 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: code/data.asm

.0000					codePtr:
>0000							.word 	?
.0002					zTemp1:
>0002							.word 	?
.0004					zTemp2:
>0004							.word 	?
.0006					zTemp3:
>0006							.word 	?
.0008					zTemp4:
>0008							.word 	?
=$600					xsStatus = $600								; expression stack.
=$620					xsAddrLow = $620 							; these values are shared depending on type.
=$640					xsAddrHigh = $640
=$620					xsIntLow = xsAddrLow
=$640					xsIntHigh = xsAddrHigh
=$620					xsMantissa3 = xsAddrLow
=$640					xsMantissa2 = xsAddrHigh
=$660					xsMantissa1 = $660
=$680					xsMantissa0 = $680
=$6a0					xsExponent = $6A0

;******  Return to file: basic.asm


;******  Processing file: code/macros.asm


;******  Return to file: basic.asm

.6000	4c 9b 63	jmp $639b			jmp 	ColdStart

;******  Processing file: files.asm

.6003					TokenTextTable:

;******  Processing file: generated/tokentext.inc

>6003	05 7b 45 4f 4c fd			.byte	$05,$7b,$45,$4f,$4c,$fd                  ; $80 : {eol}
>6009	03 41 4e c4				.byte	$03,$41,$4e,$c4                          ; $81 : and
>600d	02 4f d2				.byte	$02,$4f,$d2                              ; $82 : or
>6010	03 58 4f d2				.byte	$03,$58,$4f,$d2                          ; $83 : xor
>6014	01 be					.byte	$01,$be                                  ; $84 : >
>6016	02 3e bd				.byte	$02,$3e,$bd                              ; $85 : >=
>6019	01 bc					.byte	$01,$bc                                  ; $86 : <
>601b	02 3c bd				.byte	$02,$3c,$bd                              ; $87 : <=
>601e	01 bd					.byte	$01,$bd                                  ; $88 : =
>6020	02 3c be				.byte	$02,$3c,$be                              ; $89 : <>
>6023	01 ab					.byte	$01,$ab                                  ; $8a : +
>6025	01 ad					.byte	$01,$ad                                  ; $8b : -
>6027	01 aa					.byte	$01,$aa                                  ; $8c : *
>6029	01 af					.byte	$01,$af                                  ; $8d : /
>602b	03 4d 4f c4				.byte	$03,$4d,$4f,$c4                          ; $8e : mod
>602f	04 4c 45 4e a8				.byte	$04,$4c,$45,$4e,$a8                      ; $8f : len(
>6034	04 52 4e 44 a8				.byte	$04,$52,$4e,$44,$a8                      ; $90 : rnd(
>6039	04 41 53 43 a8				.byte	$04,$41,$53,$43,$a8                      ; $91 : asc(
>603e	05 43 48 52 24 a8			.byte	$05,$43,$48,$52,$24,$a8                  ; $92 : chr$(
>6044	04 56 41 4c a8				.byte	$04,$56,$41,$4c,$a8                      ; $93 : val(
>6049	05 53 54 52 24 a8			.byte	$05,$53,$54,$52,$24,$a8                  ; $94 : str$(
>604f	04 53 50 43 a8				.byte	$04,$53,$50,$43,$a8                      ; $95 : spc(
>6054	06 4c 45 46 54 24 a8			.byte	$06,$4c,$45,$46,$54,$24,$a8              ; $96 : left$(
>605b	05 4d 49 44 24 a8			.byte	$05,$4d,$49,$44,$24,$a8                  ; $97 : mid$(
>6061	07 52 49 47 48 54 24 a8			.byte	$07,$52,$49,$47,$48,$54,$24,$a8          ; $98 : right$(
>6069	04 41 42 53 a8				.byte	$04,$41,$42,$53,$a8                      ; $99 : abs(
>606e	04 53 47 4e a8				.byte	$04,$53,$47,$4e,$a8                      ; $9a : sgn(
>6073	04 49 4e 54 a8				.byte	$04,$49,$4e,$54,$a8                      ; $9b : int(
>6078	05 44 45 45 4b a8			.byte	$05,$44,$45,$45,$4b,$a8                  ; $9c : deek(
>607e	05 50 45 45 4b a8			.byte	$05,$50,$45,$45,$4b,$a8                  ; $9d : peek(
>6084	06 56 50 45 45 4b a8			.byte	$06,$56,$50,$45,$45,$4b,$a8              ; $9e : vpeek(
>608b	01 a8					.byte	$01,$a8                                  ; $9f : (
>608d	01 a5					.byte	$01,$a5                                  ; $a0 : %
>608f	01 a4					.byte	$01,$a4                                  ; $a1 : $
>6091	02 49 c6				.byte	$02,$49,$c6                              ; $a2 : if
>6094	06 52 45 50 45 41 d4			.byte	$06,$52,$45,$50,$45,$41,$d4              ; $a3 : repeat
>609b	03 46 4f d2				.byte	$03,$46,$4f,$d2                          ; $a4 : for
>609f	05 57 48 49 4c c5			.byte	$05,$57,$48,$49,$4c,$c5                  ; $a5 : while
>60a5	04 43 41 53 c5				.byte	$04,$43,$41,$53,$c5                      ; $a6 : case
>60aa	04 54 48 45 ce				.byte	$04,$54,$48,$45,$ce                      ; $a7 : then
>60af	05 45 4e 44 49 c6			.byte	$05,$45,$4e,$44,$49,$c6                  ; $a8 : endif
>60b5	05 55 4e 54 49 cc			.byte	$05,$55,$4e,$54,$49,$cc                  ; $a9 : until
>60bb	04 4e 45 58 d4				.byte	$04,$4e,$45,$58,$d4                      ; $aa : next
>60c0	08 45 4e 44 57 48 49 4c			.byte	$08,$45,$4e,$44,$57,$48,$49,$4c,$c5      ; $ab : endwhile
>60c8	c5
>60c9	07 45 4e 44 43 41 53 c5			.byte	$07,$45,$4e,$44,$43,$41,$53,$c5          ; $ac : endcase
>60d1	02 54 cf				.byte	$02,$54,$cf                              ; $ad : to
>60d4	04 53 54 45 d0				.byte	$04,$53,$54,$45,$d0                      ; $ae : step
>60d9	07 44 45 46 50 52 4f c3			.byte	$07,$44,$45,$46,$50,$52,$4f,$c3          ; $af : defproc
>60e1	07 45 4e 44 50 52 4f c3			.byte	$07,$45,$4e,$44,$50,$52,$4f,$c3          ; $b0 : endproc
>60e9	04 50 52 4f c3				.byte	$04,$50,$52,$4f,$c3                      ; $b1 : proc
>60ee	05 4c 4f 43 41 cc			.byte	$05,$4c,$4f,$43,$41,$cc                  ; $b2 : local
>60f4	03 4c 45 d4				.byte	$03,$4c,$45,$d4                          ; $b3 : let
>60f8	03 52 55 ce				.byte	$03,$52,$55,$ce                          ; $b4 : run
>60fc	04 53 54 4f d0				.byte	$04,$53,$54,$4f,$d0                      ; $b5 : stop
>6101	03 45 4e c4				.byte	$03,$45,$4e,$c4                          ; $b6 : end
>6105	05 50 52 49 4e d4			.byte	$05,$50,$52,$49,$4e,$d4                  ; $b7 : print
>610b	05 49 4e 50 55 d4			.byte	$05,$49,$4e,$50,$55,$d4                  ; $b8 : input
>6111	04 57 48 45 ce				.byte	$04,$57,$48,$45,$ce                      ; $b9 : when
>6116	07 44 45 46 41 55 4c d4			.byte	$07,$44,$45,$46,$41,$55,$4c,$d4          ; $ba : default
>611e	06 4f 50 54 49 4f ce			.byte	$06,$4f,$50,$54,$49,$4f,$ce              ; $bb : option
>6125	04 4c 49 53 d4				.byte	$04,$4c,$49,$53,$d4                      ; $bc : list
>612a	04 4c 4f 41 c4				.byte	$04,$4c,$4f,$41,$c4                      ; $bd : load
>612f	04 53 41 56 c5				.byte	$04,$53,$41,$56,$c5                      ; $be : save
>6134	03 4e 45 d7				.byte	$03,$4e,$45,$d7                          ; $bf : new
>6138	03 4f 4c c4				.byte	$03,$4f,$4c,$c4                          ; $c0 : old
>613c	04 50 4f 4b c5				.byte	$04,$50,$4f,$4b,$c5                      ; $c1 : poke
>6141	04 44 4f 4b c5				.byte	$04,$44,$4f,$4b,$c5                      ; $c2 : doke
>6146	05 56 50 4f 4b c5			.byte	$05,$56,$50,$4f,$4b,$c5                  ; $c3 : vpoke
>614c	03 52 45 cd				.byte	$03,$52,$45,$cd                          ; $c4 : rem
>6150	04 47 4f 54 cf				.byte	$04,$47,$4f,$54,$cf                      ; $c5 : goto
>6155	05 47 4f 53 55 c2			.byte	$05,$47,$4f,$53,$55,$c2                  ; $c6 : gosub
>615b	01 a9					.byte	$01,$a9                                  ; $c7 : )
>615d	01 ba					.byte	$01,$ba                                  ; $c8 : :
>615f	00					.byte	$00

;******  Return to file: files.asm

.6160					TokenControlByteTable:

;******  Processing file: generated/tokencbyte.inc

>6160	00					.byte	$00		; $80 : {eol}
>6161	11					.byte	$11		; $81 : and
>6162	11					.byte	$11		; $82 : or
>6163	11					.byte	$11		; $83 : xor
>6164	12					.byte	$12		; $84 : >
>6165	12					.byte	$12		; $85 : >=
>6166	12					.byte	$12		; $86 : <
>6167	12					.byte	$12		; $87 : <=
>6168	12					.byte	$12		; $88 : =
>6169	12					.byte	$12		; $89 : <>
>616a	13					.byte	$13		; $8a : +
>616b	13					.byte	$13		; $8b : -
>616c	14					.byte	$14		; $8c : *
>616d	14					.byte	$14		; $8d : /
>616e	14					.byte	$14		; $8e : mod
>616f	40					.byte	$40		; $8f : len(
>6170	40					.byte	$40		; $90 : rnd(
>6171	40					.byte	$40		; $91 : asc(
>6172	40					.byte	$40		; $92 : chr$(
>6173	40					.byte	$40		; $93 : val(
>6174	40					.byte	$40		; $94 : str$(
>6175	40					.byte	$40		; $95 : spc(
>6176	40					.byte	$40		; $96 : left$(
>6177	40					.byte	$40		; $97 : mid$(
>6178	40					.byte	$40		; $98 : right$(
>6179	40					.byte	$40		; $99 : abs(
>617a	40					.byte	$40		; $9a : sgn(
>617b	40					.byte	$40		; $9b : int(
>617c	40					.byte	$40		; $9c : deek(
>617d	40					.byte	$40		; $9d : peek(
>617e	40					.byte	$40		; $9e : vpeek(
>617f	40					.byte	$40		; $9f : (
>6180	40					.byte	$40		; $a0 : %
>6181	40					.byte	$40		; $a1 : $
>6182	82					.byte	$82		; $a2 : if
>6183	82					.byte	$82		; $a3 : repeat
>6184	82					.byte	$82		; $a4 : for
>6185	82					.byte	$82		; $a5 : while
>6186	82					.byte	$82		; $a6 : case
>6187	80					.byte	$80		; $a7 : then
>6188	80					.byte	$80		; $a8 : endif
>6189	80					.byte	$80		; $a9 : until
>618a	80					.byte	$80		; $aa : next
>618b	80					.byte	$80		; $ab : endwhile
>618c	80					.byte	$80		; $ac : endcase
>618d	81					.byte	$81		; $ad : to
>618e	81					.byte	$81		; $ae : step
>618f	81					.byte	$81		; $af : defproc
>6190	81					.byte	$81		; $b0 : endproc
>6191	81					.byte	$81		; $b1 : proc
>6192	81					.byte	$81		; $b2 : local
>6193	81					.byte	$81		; $b3 : let
>6194	81					.byte	$81		; $b4 : run
>6195	81					.byte	$81		; $b5 : stop
>6196	81					.byte	$81		; $b6 : end
>6197	81					.byte	$81		; $b7 : print
>6198	81					.byte	$81		; $b8 : input
>6199	81					.byte	$81		; $b9 : when
>619a	81					.byte	$81		; $ba : default
>619b	81					.byte	$81		; $bb : option
>619c	81					.byte	$81		; $bc : list
>619d	81					.byte	$81		; $bd : load
>619e	81					.byte	$81		; $be : save
>619f	81					.byte	$81		; $bf : new
>61a0	81					.byte	$81		; $c0 : old
>61a1	81					.byte	$81		; $c1 : poke
>61a2	81					.byte	$81		; $c2 : doke
>61a3	81					.byte	$81		; $c3 : vpoke
>61a4	81					.byte	$81		; $c4 : rem
>61a5	81					.byte	$81		; $c5 : goto
>61a6	81					.byte	$81		; $c6 : gosub
>61a7	00					.byte	$00		; $c7 : )
>61a8	00					.byte	$00		; $c8 : :

;******  Return to file: files.asm

.61a9					TokenVectors:

;******  Processing file: generated/tokenvectors.inc

>61a9	b2 63					.word	SyntaxError             		; $80 : {eol}
>61ab	2e 63					.word	BinaryAnd               		; $81 : and
>61ad	4c 63					.word	BinaryOr                		; $82 : or
>61af	6a 63					.word	BinaryXor               		; $83 : xor
>61b1	b2 63					.word	SyntaxError             		; $84 : >
>61b3	b2 63					.word	SyntaxError             		; $85 : >=
>61b5	b2 63					.word	SyntaxError             		; $86 : <
>61b7	b2 63					.word	SyntaxError             		; $87 : <=
>61b9	b2 63					.word	SyntaxError             		; $88 : =
>61bb	b2 63					.word	SyntaxError             		; $89 : <>
>61bd	f0 62					.word	BinaryAdd               		; $8a : +
>61bf	0f 63					.word	BinarySub               		; $8b : -
>61c1	b2 63					.word	SyntaxError             		; $8c : *
>61c3	b2 63					.word	SyntaxError             		; $8d : /
>61c5	b2 63					.word	SyntaxError             		; $8e : mod
>61c7	b2 63					.word	SyntaxError             		; $8f : len(
>61c9	b2 63					.word	SyntaxError             		; $90 : rnd(
>61cb	b2 63					.word	SyntaxError             		; $91 : asc(
>61cd	b2 63					.word	SyntaxError             		; $92 : chr$(
>61cf	b2 63					.word	SyntaxError             		; $93 : val(
>61d1	b2 63					.word	SyntaxError             		; $94 : str$(
>61d3	b2 63					.word	SyntaxError             		; $95 : spc(
>61d5	b2 63					.word	SyntaxError             		; $96 : left$(
>61d7	b2 63					.word	SyntaxError             		; $97 : mid$(
>61d9	b2 63					.word	SyntaxError             		; $98 : right$(
>61db	b2 63					.word	SyntaxError             		; $99 : abs(
>61dd	b2 63					.word	SyntaxError             		; $9a : sgn(
>61df	b2 63					.word	SyntaxError             		; $9b : int(
>61e1	b2 63					.word	SyntaxError             		; $9c : deek(
>61e3	b2 63					.word	SyntaxError             		; $9d : peek(
>61e5	b2 63					.word	SyntaxError             		; $9e : vpeek(
>61e7	b2 63					.word	SyntaxError             		; $9f : (
>61e9	b2 63					.word	SyntaxError             		; $a0 : %
>61eb	b2 63					.word	SyntaxError             		; $a1 : $
>61ed	b2 63					.word	SyntaxError             		; $a2 : if
>61ef	b2 63					.word	SyntaxError             		; $a3 : repeat
>61f1	b2 63					.word	SyntaxError             		; $a4 : for
>61f3	b2 63					.word	SyntaxError             		; $a5 : while
>61f5	b2 63					.word	SyntaxError             		; $a6 : case
>61f7	b2 63					.word	SyntaxError             		; $a7 : then
>61f9	b2 63					.word	SyntaxError             		; $a8 : endif
>61fb	b2 63					.word	SyntaxError             		; $a9 : until
>61fd	b2 63					.word	SyntaxError             		; $aa : next
>61ff	b2 63					.word	SyntaxError             		; $ab : endwhile
>6201	b2 63					.word	SyntaxError             		; $ac : endcase
>6203	b2 63					.word	SyntaxError             		; $ad : to
>6205	b2 63					.word	SyntaxError             		; $ae : step
>6207	b2 63					.word	SyntaxError             		; $af : defproc
>6209	b2 63					.word	SyntaxError             		; $b0 : endproc
>620b	b2 63					.word	SyntaxError             		; $b1 : proc
>620d	b2 63					.word	SyntaxError             		; $b2 : local
>620f	b2 63					.word	SyntaxError             		; $b3 : let
>6211	b2 63					.word	SyntaxError             		; $b4 : run
>6213	b2 63					.word	SyntaxError             		; $b5 : stop
>6215	b2 63					.word	SyntaxError             		; $b6 : end
>6217	b2 63					.word	SyntaxError             		; $b7 : print
>6219	b2 63					.word	SyntaxError             		; $b8 : input
>621b	b2 63					.word	SyntaxError             		; $b9 : when
>621d	b2 63					.word	SyntaxError             		; $ba : default
>621f	b2 63					.word	SyntaxError             		; $bb : option
>6221	b2 63					.word	SyntaxError             		; $bc : list
>6223	b2 63					.word	SyntaxError             		; $bd : load
>6225	b2 63					.word	SyntaxError             		; $be : save
>6227	b2 63					.word	SyntaxError             		; $bf : new
>6229	b2 63					.word	SyntaxError             		; $c0 : old
>622b	b2 63					.word	SyntaxError             		; $c1 : poke
>622d	b2 63					.word	SyntaxError             		; $c2 : doke
>622f	b2 63					.word	SyntaxError             		; $c3 : vpoke
>6231	b2 63					.word	SyntaxError             		; $c4 : rem
>6233	b2 63					.word	SyntaxError             		; $c5 : goto
>6235	b2 63					.word	SyntaxError             		; $c6 : gosub
>6237	b2 63					.word	SyntaxError             		; $c7 : )
>6239	b2 63					.word	SyntaxError             		; $c8 : :

;******  Return to file: files.asm


;******  Processing file: expression/evaluate.asm

.623b					EvaluateExpression:
.623b	a2 00		ldx #$00			ldx 	#0 							; reset the evaluation stack pointer in X
.623d					EvalutateExpressionAtX:
.623d	a9 10		lda #$10			lda 	#$10 						; this is the lowest precedence.
.623f					EvaluateExpressionAtXPrecA:
.623f	48		pha				pha 								; save lowest stack level.
.6240	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first term.
.6242	30 4b		bmi $628f			bmi 	_EXAKeywordData 			; is it keyword, or data.
.6244	c9 60		cmp #$60			cmp 	#$60 						; is it a variable
.6246	90 46		bcc $628e			bcc 	_EXAVariable
.6248	c8		iny				iny 								; skip over the short constant
.6249	29 1f		and #$1f			and 	#$1F 						; short constant $00-$1F
.624b	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and put as an integer
.624e	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.6251	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; integer, number, not a reference.
.6254					_EXAHaveTerm:
.6254	68		pla				pla 	 							; restore current precedence and save in zTemp1
.6255	85 02		sta $02				sta 	zTemp1
.6257	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by a binary operation.
.6259	da		phx				phx
.625a	aa		tax				tax
.625b	bd e0 60	lda $60e0,x			lda 	TokenControlByteTable-$80,x ; get the control byte.
.625e	fa		plx				plx
.625f	c9 20		cmp #$20			cmp 	#$20 						; must be $10-$17 (or possibly $00, will be < precedence)
.6261	b0 06		bcs $6269			bcs 	_EXAExit
.6263	c5 02		cmp $02				cmp 	zTemp1 						; check against current precedence.
.6265	f0 02		beq $6269			beq 	_EXAExit
.6267	b0 01		bcs $626a			bcs		_EXABinaryOp 				; if >, do a binary operation.
.6269					_EXAExit:
.6269	60		rts				rts 								; exit expression evaluation.
.626a					_EXABinaryOp:
.626a	85 03		sta $03				sta 	zTemp1+1 					; save operator.
.626c	a5 02		lda $02				lda 	zTemp1 						; get and save current precedence
.626e	48		pha				pha
.626f	b1 00		lda ($00),y			lda 	(codePtr),y 				; push binary operator on stack
.6271	48		pha				pha
.6272	c8		iny				iny 								; and skip over it.
.6273	e8		inx				inx 								; calculate the RHS in the next slot up.
.6274	a5 03		lda $03				lda 	zTemp1+1 					; at operator precedence level.
.6276	20 3f 62	jsr $623f			jsr 	EvaluateExpressionAtXPrecA
.6279	ca		dex				dex
.627a	68		pla				pla 								; get binary operator.
.627b	da		phx				phx 								; save stack depth.
.627c	0a		asl a				asl 	a 							; double binary operator and put into X, loses MSB
.627d	aa		tax				tax
.627e	bd a9 61	lda $61a9,x			lda 	TokenVectors,x 				; get address => zTemp2
.6281	85 04		sta $04				sta 	zTemp2
.6283	bd aa 61	lda $61aa,x			lda 	TokenVectors+1,x
.6286	85 05		sta $05				sta 	zTemp2+1
.6288	fa		plx				plx 								; restore stack depth.
.6289	20 90 62	jsr $6290			jsr 	_EXACallZTemp2 				; call the routine
.628c	80 c6		bra $6254			bra 	_EXAHaveTerm 				; and loop round again.
.628e					_EXAVariable:
>628e	ff						.byte 	$FF
.628f					_EXAKeywordData:
>628f	ff						.byte 	$FF
.6290					_EXACallZTemp2:
.6290	6c 04 00	jmp ($0004)			jmp 	(zTemp2)

;******  Return to file: files.asm


;******  Processing file: expression/exprutils.asm

.6293					DeReferenceBinary:
.6293	e8		inx				inx
.6294	20 98 62	jsr $6298			jsr 	DeReferenceUnary
.6297	ca		dex				dex
.6298					DeReferenceUnary:
.6298	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; the reference flag is in bit 0
.629b	6a		ror a				ror 	a 							; shift into carry.
.629c	90 33		bcc $62d1			bcc 	_DRNotReference 			; if clear, it's already a reference.
.629e	0a		asl a				asl 	a 							; get back, but with bit 0 cleared
.629f	9d 00 06	sta $0600,x			sta 	xsStatus,x
.62a2	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put the address to dereference into zTemp1
.62a5	85 02		sta $02				sta 	zTemp1
.62a7	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.62aa	85 03		sta $03				sta 	zTemp1+1
.62ac	5a		phy				phy 								; save position in code
.62ad	b2 02		lda ($02)			lda 	(zTemp1) 					; dereference the first two bytes - this will be
.62af	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; for float, int and string, and will go in these
.62b2	a0 01		ldy #$01			ldy 	#1 							; which are also the address, and mantissa3 & 2
.62b4	b1 02		lda ($02),y			lda 	(zTemp1),y
.62b6	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.62b9	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; check if it's a float (bit 7)
.62bc	10 12		bpl $62d0			bpl 	_DRNotFloat 				; if not, we are complete
.62be	c8		iny				iny 								; if float, copy all five bytes of the floating point
.62bf	b1 02		lda ($02),y			lda 	(zTemp1),y 					; number into the stack.
.62c1	9d 60 06	sta $0660,x			sta 	xsMantissa1,x
.62c4	c8		iny				iny
.62c5	b1 02		lda ($02),y			lda 	(zTemp1),y
.62c7	9d 80 06	sta $0680,x			sta 	xsMantissa0,x
.62ca	c8		iny				iny
.62cb	b1 02		lda ($02),y			lda 	(zTemp1),y
.62cd	9d a0 06	sta $06a0,x			sta 	xsExponent,x
.62d0					_DRNotFloat:
.62d0	7a		ply				ply 								; restore code position.
.62d1					_DRNotReference:
.62d1	60		rts				rts
.62d2					NumberTypeCheck:
.62d2	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; bit 7 set if either float, bit 6 set if either string.
.62d5	1d 01 06	ora $0601,x			ora 	xsStatus+1,x
.62d8	0a		asl a				asl 	a 							; carry set if either float, bit 7 set if either string
.62d9	30 01		bmi $62dc			bmi 	_NTCError 					; so fail if string, we want int
.62db	60		rts				rts
.62dc					_NTCError:
.62dc	20 b5 63	jsr $63b5			jsr 	ErrorHandler
>62df	4e 75 6d 62 65 72 20 4f				.text 	"Number Operation",0
>62e7	70 65 72 61 74 69 6f 6e 00

;******  Return to file: files.asm


;******  Processing file: expression/integer/arithmetic.asm

.62f0					BinaryAdd:
.62f0	20 93 62	jsr $6293			jsr 	DeReferenceBinary 			; convert references to values
.62f3	20 d2 62	jsr $62d2			jsr 	NumberTypeCheck 			; check numeric, returns CC if both integer.
.62f6	90 03		bcc $62fb			bcc 	_Integer
.62f8	4c 88 63	jmp $6388			jmp 	FPAdd
.62fb					_Integer:
.62fb	18		clc				clc
.62fc	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.62ff	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.6302	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6305	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6308	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.630b	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.630e	60		rts				rts
.630f					BinarySub:
.630f	20 93 62	jsr $6293			jsr 	DeReferenceBinary 			; convert references to values
.6312	20 d2 62	jsr $62d2			jsr 	NumberTypeCheck 			; check numeric, returns CC if both integer.
.6315	90 03		bcc $631a			bcc 	_Integer
.6317	4c 88 63	jmp $6388			jmp 	FPSub
.631a					_Integer:
.631a	38		sec				sec
.631b	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.631e	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.6321	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6324	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6327	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.632a	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.632d	60		rts				rts
.632e					BinaryAnd:
.632e	20 93 62	jsr $6293			jsr 	DeReferenceBinary 			; convert references to values
.6331	20 d2 62	jsr $62d2			jsr 	NumberTypeCheck 			; check numeric. if float convert to integer
.6334	90 03		bcc $6339			bcc 	_Integer
.6336	20 88 63	jsr $6388			jsr 	FPFloatToInteger
.6339					_Integer:
.6339	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.633c	3d 21 06	and $0621,x			and 	xsIntLow+1,x
.633f	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6342	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6345	3d 41 06	and $0641,x			and 	xsIntHigh+1,x
.6348	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.634b	60		rts				rts
.634c					BinaryOr:
.634c	20 93 62	jsr $6293			jsr 	DeReferenceBinary 			; convert references to values
.634f	20 d2 62	jsr $62d2			jsr 	NumberTypeCheck 			; check numeric. if float convert to integer
.6352	90 03		bcc $6357			bcc 	_Integer
.6354	20 88 63	jsr $6388			jsr 	FPFloatToInteger
.6357					_Integer:
.6357	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.635a	1d 21 06	ora $0621,x			ora 	xsIntLow+1,x
.635d	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6360	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6363	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.6366	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.6369	60		rts				rts
.636a					BinaryXor:
.636a	20 93 62	jsr $6293			jsr 	DeReferenceBinary 			; convert references to values
.636d	20 d2 62	jsr $62d2			jsr 	NumberTypeCheck 			; check numeric. if float convert to integer
.6370	90 03		bcc $6375			bcc 	_Integer
.6372	20 88 63	jsr $6388			jsr 	FPFloatToInteger
.6375					_Integer:
.6375	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.6378	5d 21 06	eor $0621,x			eor 	xsIntLow+1,x
.637b	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.637e	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6381	5d 41 06	eor $0641,x			eor 	xsIntHigh+1,x
.6384	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.6387	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/float/floatdummy.asm

.6388					FPAdd:
.6388					FPSub:
.6388					FPMultiply:
.6388					FPDivide:
.6388					FPFloatToInteger:
.6388	20 b5 63	jsr $63b5			jsr 	ErrorHandler
>638b	4e 6f 74 20 49 6d 70 6c				.text 	"Not Implemented",0
>6393	65 6d 65 6e 74 65 64 00

;******  Return to file: files.asm


;******  Return to file: basic.asm

.639b					ColdStart:
.639b	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.639d	9a		txs				txs
.639e	a9 ae		lda #$ae			lda 	#(TestProgram) & $FF
.63a0	85 00		sta $00				sta 	0+(codePtr)
.63a2	a9 63		lda #$63			lda 	#(TestProgram) >> 8
.63a4	85 01		sta $01				sta 	1+(codePtr)
.63a6	a0 00		ldy #$00			ldy 	#0
.63a8	20 3b 62	jsr $623b			jsr 	EvaluateExpression
.63ab	4c ff ff	jmp $ffff			jmp 	$FFFF
.63ae					TestProgram:

;******  Processing file: generated/testcode.inc

>63ae	7e 81 6d				.byte	$7e,$81,$6d

;******  Return to file: basic.asm

>63b1	80						.byte 	$80
.63b2					SyntaxError:
.63b2	a2 5e		ldx #$5e			ldx 	#$5E
>63b4	ff						.byte 	$FF
.63b5					ErrorHandler:
.63b5	a2 ee		ldx #$ee			ldx 	#$EE
>63b7	ff						.byte 	$FF

;******  End of listing
