
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o basic_nocode.prg -L basic.lst -l basic.lbl basic.asm
; Sun Feb 09 06:45:50 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: code/data.asm

.0000					codePtr:
>0000							.word 	?
.0002					structSP:
>0002							.byte 	?
.0003					zTemp1:
>0003							.word 	?
.0005					zTemp2:
>0005							.word 	?
.0007					zTemp3:
>0007							.word 	?
.0009					zTemp4:
>0009							.word 	?
.000b					signCount:
>000b							.byte 	?
.000c					convertPtr:
>000c							.byte 	?
.000d					randomSeed:
>000d							.word 	?
=$600					xsStatus = $600								; expression stack (must all fit in one page)
=$20					stackSize = $20 							; stack elements allowed (max 256/6)
=1568					xsAddrLow = xsStatus+stackSize 				; these values are shared depending on type.
=1600					xsAddrHigh = xsStatus+stackSize*2
=1568					xsIntLow = xsAddrLow
=1600					xsIntHigh = xsAddrHigh
=1568					xsMantissa3 = xsAddrLow
=1600					xsMantissa2 = xsAddrHigh
=1632					xsMantissa1 = xsStatus+stackSize*3
=1664					xsMantissa0 = xsStatus+stackSize*4
=1696					xsExponent = xsStatus+stackSize*5
=$700					variables = $700							; 26 variables A-Z. Must be on a page boundary.
=$780					structStack = $780 							; structure stack.
=$800					textBuffer = $800							; text buffer for input command lines.
=$fb					TOK_STRING_OBJ = $FB
=$fe					TOK_BYTE_OBJ = $FE
=$ff					TOK_WORD_OBJ = $FF
="G"					SMARK_GOSUB = 'G'
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: basic.asm


;******  Processing file: code/macros.asm


;******  Return to file: basic.asm

.1000	4c db 1b	jmp $1bdb			jmp 	ColdStart

;******  Processing file: files.asm

.1003					TokenTextTable:

;******  Processing file: generated/tokentext.inc

>1003	05 28 45 4f 4c a9			.byte	$05,$28,$45,$4f,$4c,$a9                  ; $80 : (eol)
>1009	01 a5					.byte	$01,$a5                                  ; $81 : %
>100b	02 25 a8				.byte	$02,$25,$a8                              ; $82 : %(
>100e	01 a4					.byte	$01,$a4                                  ; $83 : $
>1010	02 24 a8				.byte	$02,$24,$a8                              ; $84 : $(
>1013	01 a3					.byte	$01,$a3                                  ; $85 : #
>1015	02 23 a8				.byte	$02,$23,$a8                              ; $86 : #(
>1018	01 a8					.byte	$01,$a8                                  ; $87 : (
>101a	01 a9					.byte	$01,$a9                                  ; $88 : )
>101c	01 ba					.byte	$01,$ba                                  ; $89 : :
>101e	01 ac					.byte	$01,$ac                                  ; $8a : ,
>1020	01 bb					.byte	$01,$bb                                  ; $8b : ;
>1022	03 41 4e c4				.byte	$03,$41,$4e,$c4                          ; $8c : and
>1026	02 4f d2				.byte	$02,$4f,$d2                              ; $8d : or
>1029	03 58 4f d2				.byte	$03,$58,$4f,$d2                          ; $8e : xor
>102d	01 be					.byte	$01,$be                                  ; $8f : >
>102f	02 3e bd				.byte	$02,$3e,$bd                              ; $90 : >=
>1032	01 bc					.byte	$01,$bc                                  ; $91 : <
>1034	02 3c bd				.byte	$02,$3c,$bd                              ; $92 : <=
>1037	01 bd					.byte	$01,$bd                                  ; $93 : =
>1039	02 3c be				.byte	$02,$3c,$be                              ; $94 : <>
>103c	01 ab					.byte	$01,$ab                                  ; $95 : +
>103e	01 ad					.byte	$01,$ad                                  ; $96 : -
>1040	01 aa					.byte	$01,$aa                                  ; $97 : *
>1042	01 af					.byte	$01,$af                                  ; $98 : /
>1044	03 4d 4f c4				.byte	$03,$4d,$4f,$c4                          ; $99 : mod
>1048	04 4c 45 4e a8				.byte	$04,$4c,$45,$4e,$a8                      ; $9a : len(
>104d	04 52 4e 44 a8				.byte	$04,$52,$4e,$44,$a8                      ; $9b : rnd(
>1052	04 41 53 43 a8				.byte	$04,$41,$53,$43,$a8                      ; $9c : asc(
>1057	05 43 48 52 24 a8			.byte	$05,$43,$48,$52,$24,$a8                  ; $9d : chr$(
>105d	04 56 41 4c a8				.byte	$04,$56,$41,$4c,$a8                      ; $9e : val(
>1062	05 53 54 52 24 a8			.byte	$05,$53,$54,$52,$24,$a8                  ; $9f : str$(
>1068	04 53 50 43 a8				.byte	$04,$53,$50,$43,$a8                      ; $a0 : spc(
>106d	06 4c 45 46 54 24 a8			.byte	$06,$4c,$45,$46,$54,$24,$a8              ; $a1 : left$(
>1074	05 4d 49 44 24 a8			.byte	$05,$4d,$49,$44,$24,$a8                  ; $a2 : mid$(
>107a	07 52 49 47 48 54 24 a8			.byte	$07,$52,$49,$47,$48,$54,$24,$a8          ; $a3 : right$(
>1082	04 41 42 53 a8				.byte	$04,$41,$42,$53,$a8                      ; $a4 : abs(
>1087	04 53 47 4e a8				.byte	$04,$53,$47,$4e,$a8                      ; $a5 : sgn(
>108c	04 49 4e 54 a8				.byte	$04,$49,$4e,$54,$a8                      ; $a6 : int(
>1091	07 52 41 4e 44 4f 4d a8			.byte	$07,$52,$41,$4e,$44,$4f,$4d,$a8          ; $a7 : random(
>1099	05 44 45 45 4b a8			.byte	$05,$44,$45,$45,$4b,$a8                  ; $a8 : deek(
>109f	05 50 45 45 4b a8			.byte	$05,$50,$45,$45,$4b,$a8                  ; $a9 : peek(
>10a5	06 56 50 45 45 4b a8			.byte	$06,$56,$50,$45,$45,$4b,$a8              ; $aa : vpeek(
>10ac	02 49 c6				.byte	$02,$49,$c6                              ; $ab : if
>10af	06 52 45 50 45 41 d4			.byte	$06,$52,$45,$50,$45,$41,$d4              ; $ac : repeat
>10b6	03 46 4f d2				.byte	$03,$46,$4f,$d2                          ; $ad : for
>10ba	05 57 48 49 4c c5			.byte	$05,$57,$48,$49,$4c,$c5                  ; $ae : while
>10c0	04 43 41 53 c5				.byte	$04,$43,$41,$53,$c5                      ; $af : case
>10c5	04 54 48 45 ce				.byte	$04,$54,$48,$45,$ce                      ; $b0 : then
>10ca	05 45 4e 44 49 c6			.byte	$05,$45,$4e,$44,$49,$c6                  ; $b1 : endif
>10d0	05 55 4e 54 49 cc			.byte	$05,$55,$4e,$54,$49,$cc                  ; $b2 : until
>10d6	04 4e 45 58 d4				.byte	$04,$4e,$45,$58,$d4                      ; $b3 : next
>10db	08 45 4e 44 57 48 49 4c			.byte	$08,$45,$4e,$44,$57,$48,$49,$4c,$c5      ; $b4 : endwhile
>10e3	c5
>10e4	07 45 4e 44 43 41 53 c5			.byte	$07,$45,$4e,$44,$43,$41,$53,$c5          ; $b5 : endcase
>10ec	02 54 cf				.byte	$02,$54,$cf                              ; $b6 : to
>10ef	04 53 54 45 d0				.byte	$04,$53,$54,$45,$d0                      ; $b7 : step
>10f4	04 50 52 4f c3				.byte	$04,$50,$52,$4f,$c3                      ; $b8 : proc
>10f9	07 45 4e 44 50 52 4f c3			.byte	$07,$45,$4e,$44,$50,$52,$4f,$c3          ; $b9 : endproc
>1101	04 43 41 4c cc				.byte	$04,$43,$41,$4c,$cc                      ; $ba : call
>1106	05 4c 4f 43 41 cc			.byte	$05,$4c,$4f,$43,$41,$cc                  ; $bb : local
>110c	03 52 55 ce				.byte	$03,$52,$55,$ce                          ; $bc : run
>1110	04 53 54 4f d0				.byte	$04,$53,$54,$4f,$d0                      ; $bd : stop
>1115	03 45 4e c4				.byte	$03,$45,$4e,$c4                          ; $be : end
>1119	05 50 52 49 4e d4			.byte	$05,$50,$52,$49,$4e,$d4                  ; $bf : print
>111f	05 49 4e 50 55 d4			.byte	$05,$49,$4e,$50,$55,$d4                  ; $c0 : input
>1125	04 57 48 45 ce				.byte	$04,$57,$48,$45,$ce                      ; $c1 : when
>112a	07 44 45 46 41 55 4c d4			.byte	$07,$44,$45,$46,$41,$55,$4c,$d4          ; $c2 : default
>1132	03 4c 45 d4				.byte	$03,$4c,$45,$d4                          ; $c3 : let
>1136	06 4f 50 54 49 4f ce			.byte	$06,$4f,$50,$54,$49,$4f,$ce              ; $c4 : option
>113d	04 4c 49 53 d4				.byte	$04,$4c,$49,$53,$d4                      ; $c5 : list
>1142	04 4c 4f 41 c4				.byte	$04,$4c,$4f,$41,$c4                      ; $c6 : load
>1147	04 53 41 56 c5				.byte	$04,$53,$41,$56,$c5                      ; $c7 : save
>114c	03 4e 45 d7				.byte	$03,$4e,$45,$d7                          ; $c8 : new
>1150	03 4f 4c c4				.byte	$03,$4f,$4c,$c4                          ; $c9 : old
>1154	04 50 4f 4b c5				.byte	$04,$50,$4f,$4b,$c5                      ; $ca : poke
>1159	04 44 4f 4b c5				.byte	$04,$44,$4f,$4b,$c5                      ; $cb : doke
>115e	05 56 50 4f 4b c5			.byte	$05,$56,$50,$4f,$4b,$c5                  ; $cc : vpoke
>1164	03 52 45 cd				.byte	$03,$52,$45,$cd                          ; $cd : rem
>1168	04 47 4f 54 cf				.byte	$04,$47,$4f,$54,$cf                      ; $ce : goto
>116d	05 47 4f 53 55 c2			.byte	$05,$47,$4f,$53,$55,$c2                  ; $cf : gosub
>1173	03 53 59 d3				.byte	$03,$53,$59,$d3                          ; $d0 : sys
>1177	06 52 45 54 55 52 ce			.byte	$06,$52,$45,$54,$55,$52,$ce              ; $d1 : return
>117e	06 41 53 53 45 52 d4			.byte	$06,$41,$53,$53,$45,$52,$d4              ; $d2 : assert
>1185	02 4f ce				.byte	$02,$4f,$ce                              ; $d3 : on
>1188	04 4f 50 45 ce				.byte	$04,$4f,$50,$45,$ce                      ; $d4 : open
>118d	05 43 4c 4f 53 c5			.byte	$05,$43,$4c,$4f,$53,$c5                  ; $d5 : close
>1193	03 44 49 d2				.byte	$03,$44,$49,$d2                          ; $d6 : dir
>1197	03 44 49 cd				.byte	$03,$44,$49,$cd                          ; $d7 : dim
>119b	04 52 45 41 c4				.byte	$04,$52,$45,$41,$c4                      ; $d8 : read
>11a0	04 44 41 54 c1				.byte	$04,$44,$41,$54,$c1                      ; $d9 : data
>11a5	07 52 45 53 54 4f 52 c5			.byte	$07,$52,$45,$53,$54,$4f,$52,$c5          ; $da : restore
>11ad	00					.byte	$00

;******  Return to file: files.asm

.11ae					TokenControlByteTable:

;******  Processing file: generated/tokencbyte.inc

>11ae	00					.byte	$00		; $80 : (eol)
>11af	40					.byte	$40		; $81 : %
>11b0	00					.byte	$00		; $82 : %(
>11b1	40					.byte	$40		; $83 : $
>11b2	00					.byte	$00		; $84 : $(
>11b3	00					.byte	$00		; $85 : #
>11b4	00					.byte	$00		; $86 : #(
>11b5	40					.byte	$40		; $87 : (
>11b6	00					.byte	$00		; $88 : )
>11b7	00					.byte	$00		; $89 : :
>11b8	00					.byte	$00		; $8a : ,
>11b9	00					.byte	$00		; $8b : ;
>11ba	11					.byte	$11		; $8c : and
>11bb	11					.byte	$11		; $8d : or
>11bc	11					.byte	$11		; $8e : xor
>11bd	12					.byte	$12		; $8f : >
>11be	12					.byte	$12		; $90 : >=
>11bf	12					.byte	$12		; $91 : <
>11c0	12					.byte	$12		; $92 : <=
>11c1	12					.byte	$12		; $93 : =
>11c2	12					.byte	$12		; $94 : <>
>11c3	13					.byte	$13		; $95 : +
>11c4	13					.byte	$13		; $96 : -
>11c5	14					.byte	$14		; $97 : *
>11c6	14					.byte	$14		; $98 : /
>11c7	14					.byte	$14		; $99 : mod
>11c8	40					.byte	$40		; $9a : len(
>11c9	40					.byte	$40		; $9b : rnd(
>11ca	40					.byte	$40		; $9c : asc(
>11cb	40					.byte	$40		; $9d : chr$(
>11cc	40					.byte	$40		; $9e : val(
>11cd	40					.byte	$40		; $9f : str$(
>11ce	40					.byte	$40		; $a0 : spc(
>11cf	40					.byte	$40		; $a1 : left$(
>11d0	40					.byte	$40		; $a2 : mid$(
>11d1	40					.byte	$40		; $a3 : right$(
>11d2	40					.byte	$40		; $a4 : abs(
>11d3	40					.byte	$40		; $a5 : sgn(
>11d4	40					.byte	$40		; $a6 : int(
>11d5	40					.byte	$40		; $a7 : random(
>11d6	40					.byte	$40		; $a8 : deek(
>11d7	40					.byte	$40		; $a9 : peek(
>11d8	40					.byte	$40		; $aa : vpeek(
>11d9	82					.byte	$82		; $ab : if
>11da	82					.byte	$82		; $ac : repeat
>11db	82					.byte	$82		; $ad : for
>11dc	82					.byte	$82		; $ae : while
>11dd	82					.byte	$82		; $af : case
>11de	80					.byte	$80		; $b0 : then
>11df	80					.byte	$80		; $b1 : endif
>11e0	80					.byte	$80		; $b2 : until
>11e1	80					.byte	$80		; $b3 : next
>11e2	80					.byte	$80		; $b4 : endwhile
>11e3	80					.byte	$80		; $b5 : endcase
>11e4	81					.byte	$81		; $b6 : to
>11e5	81					.byte	$81		; $b7 : step
>11e6	81					.byte	$81		; $b8 : proc
>11e7	81					.byte	$81		; $b9 : endproc
>11e8	81					.byte	$81		; $ba : call
>11e9	81					.byte	$81		; $bb : local
>11ea	81					.byte	$81		; $bc : run
>11eb	81					.byte	$81		; $bd : stop
>11ec	81					.byte	$81		; $be : end
>11ed	81					.byte	$81		; $bf : print
>11ee	81					.byte	$81		; $c0 : input
>11ef	81					.byte	$81		; $c1 : when
>11f0	81					.byte	$81		; $c2 : default
>11f1	81					.byte	$81		; $c3 : let
>11f2	81					.byte	$81		; $c4 : option
>11f3	81					.byte	$81		; $c5 : list
>11f4	81					.byte	$81		; $c6 : load
>11f5	81					.byte	$81		; $c7 : save
>11f6	81					.byte	$81		; $c8 : new
>11f7	81					.byte	$81		; $c9 : old
>11f8	81					.byte	$81		; $ca : poke
>11f9	81					.byte	$81		; $cb : doke
>11fa	81					.byte	$81		; $cc : vpoke
>11fb	81					.byte	$81		; $cd : rem
>11fc	81					.byte	$81		; $ce : goto
>11fd	81					.byte	$81		; $cf : gosub
>11fe	81					.byte	$81		; $d0 : sys
>11ff	81					.byte	$81		; $d1 : return
>1200	81					.byte	$81		; $d2 : assert
>1201	81					.byte	$81		; $d3 : on
>1202	81					.byte	$81		; $d4 : open
>1203	81					.byte	$81		; $d5 : close
>1204	81					.byte	$81		; $d6 : dir
>1205	81					.byte	$81		; $d7 : dim
>1206	81					.byte	$81		; $d8 : read
>1207	81					.byte	$81		; $d9 : data
>1208	81					.byte	$81		; $da : restore

;******  Return to file: files.asm

>1209							.align 	2 				; defense against old 6502 bug may be present.
.120a					TokenVectors:

;******  Processing file: generated/tokenvectors.inc

>120a	c0 12					.word	SyntaxError             		; $80 : (eol)
>120c	e5 1a					.word	Dummy_Binary            		; $81 : %
>120e	c0 12					.word	SyntaxError             		; $82 : %(
>1210	e5 1a					.word	Dummy_Hex               		; $83 : $
>1212	c0 12					.word	SyntaxError             		; $84 : $(
>1214	c0 12					.word	SyntaxError             		; $85 : #
>1216	c0 12					.word	SyntaxError             		; $86 : #(
>1218	e9 1a					.word	Parenthesis             		; $87 : (
>121a	c0 12					.word	SyntaxError             		; $88 : )
>121c	c0 12					.word	SyntaxError             		; $89 : :
>121e	c0 12					.word	SyntaxError             		; $8a : ,
>1220	c0 12					.word	SyntaxError             		; $8b : ;
>1222	65 18					.word	BinaryAnd               		; $8c : and
>1224	83 18					.word	BinaryOr                		; $8d : or
>1226	a1 18					.word	BinaryXor               		; $8e : xor
>1228	c3 19					.word	Compare_Greater         		; $8f : >
>122a	b6 19					.word	Compare_GreaterEquals   		; $90 : >=
>122c	b9 19					.word	Compare_Less            		; $91 : <
>122e	c0 19					.word	Compare_LessEquals      		; $92 : <=
>1230	9f 19					.word	Compare_Equals          		; $93 : =
>1232	a2 19					.word	Compare_NotEquals       		; $94 : <>
>1234	1c 18					.word	BinaryAdd               		; $95 : +
>1236	46 18					.word	BinarySub               		; $96 : -
>1238	bf 18					.word	Multiply16x16           		; $97 : *
>123a	00 19					.word	Divide16x16             		; $98 : /
>123c	0f 19					.word	Modulus16x16            		; $99 : mod
>123e	41 1b					.word	StringLength            		; $9a : len(
>1240	c0 12					.word	SyntaxError             		; $9b : rnd(
>1242	c0 12					.word	SyntaxError             		; $9c : asc(
>1244	c0 12					.word	SyntaxError             		; $9d : chr$(
>1246	c0 12					.word	SyntaxError             		; $9e : val(
>1248	c0 12					.word	SyntaxError             		; $9f : str$(
>124a	c0 12					.word	SyntaxError             		; $a0 : spc(
>124c	c0 12					.word	SyntaxError             		; $a1 : left$(
>124e	c0 12					.word	SyntaxError             		; $a2 : mid$(
>1250	c0 12					.word	SyntaxError             		; $a3 : right$(
>1252	f0 1a					.word	AbsoluteValue           		; $a4 : abs(
>1254	0c 1b					.word	SignValue               		; $a5 : sgn(
>1256	c0 12					.word	SyntaxError             		; $a6 : int(
>1258	44 1a					.word	RandomNumber            		; $a7 : random(
>125a	66 1b					.word	DeekMemory              		; $a8 : deek(
>125c	63 1b					.word	PeekMemory              		; $a9 : peek(
>125e	c0 12					.word	SyntaxError             		; $aa : vpeek(
>1260	a8 15					.word	IfCommand               		; $ab : if
>1262	c0 12					.word	SyntaxError             		; $ac : repeat
>1264	c0 12					.word	SyntaxError             		; $ad : for
>1266	c0 12					.word	SyntaxError             		; $ae : while
>1268	c0 12					.word	SyntaxError             		; $af : case
>126a	c0 12					.word	SyntaxError             		; $b0 : then
>126c	c0 12					.word	SyntaxError             		; $b1 : endif
>126e	c0 12					.word	SyntaxError             		; $b2 : until
>1270	c0 12					.word	SyntaxError             		; $b3 : next
>1272	c0 12					.word	SyntaxError             		; $b4 : endwhile
>1274	c0 12					.word	SyntaxError             		; $b5 : endcase
>1276	c0 12					.word	SyntaxError             		; $b6 : to
>1278	c0 12					.word	SyntaxError             		; $b7 : step
>127a	c0 12					.word	SyntaxError             		; $b8 : proc
>127c	c0 12					.word	SyntaxError             		; $b9 : endproc
>127e	c0 12					.word	SyntaxError             		; $ba : call
>1280	c0 12					.word	SyntaxError             		; $bb : local
>1282	7c 16					.word	Command_RUN             		; $bc : run
>1284	bf 16					.word	Command_STOP            		; $bd : stop
>1286	bc 16					.word	Command_END             		; $be : end
>1288	c0 12					.word	SyntaxError             		; $bf : print
>128a	c0 12					.word	SyntaxError             		; $c0 : input
>128c	c0 12					.word	SyntaxError             		; $c1 : when
>128e	c0 12					.word	SyntaxError             		; $c2 : default
>1290	c0 12					.word	SyntaxError             		; $c3 : let
>1292	c0 12					.word	SyntaxError             		; $c4 : option
>1294	c0 12					.word	SyntaxError             		; $c5 : list
>1296	c0 12					.word	SyntaxError             		; $c6 : load
>1298	c0 12					.word	SyntaxError             		; $c7 : save
>129a	c0 12					.word	SyntaxError             		; $c8 : new
>129c	c0 12					.word	SyntaxError             		; $c9 : old
>129e	30 16					.word	Command_Poke            		; $ca : poke
>12a0	33 16					.word	Command_Doke            		; $cb : doke
>12a2	c0 12					.word	SyntaxError             		; $cc : vpoke
>12a4	23 16					.word	Command_Rem             		; $cd : rem
>12a6	52 15					.word	Command_GOTO            		; $ce : goto
>12a8	25 15					.word	Command_Gosub           		; $cf : gosub
>12aa	c0 12					.word	SyntaxError             		; $d0 : sys
>12ac	34 15					.word	Command_Return          		; $d1 : return
>12ae	00 16					.word	Command_Assert          		; $d2 : assert
>12b0	c0 12					.word	SyntaxError             		; $d3 : on
>12b2	c0 12					.word	SyntaxError             		; $d4 : open
>12b4	c0 12					.word	SyntaxError             		; $d5 : close
>12b6	c0 12					.word	SyntaxError             		; $d6 : dir
>12b8	c0 12					.word	SyntaxError             		; $d7 : dim
>12ba	c0 12					.word	SyntaxError             		; $d8 : read
>12bc	c0 12					.word	SyntaxError             		; $d9 : data
>12be	c0 12					.word	SyntaxError             		; $da : restore

;******  Return to file: files.asm


;******  Processing file: generated/tokenconst.inc

=$db					TOK_LAST_TOKEN = $db
=$80					TOK_LPARENEOLRPAREN = $80
=$81					TOK_PERCENT = $81
=$82					TOK_PERCENTLPAREN = $82
=$83					TOK_DOLLAR = $83
=$84					TOK_DOLLARLPAREN = $84
=$85					TOK_HASH = $85
=$86					TOK_HASHLPAREN = $86
=$87					TOK_LPAREN = $87
=$88					TOK_RPAREN = $88
=$89					TOK_COLON = $89
=$8a					TOK_COMMA = $8a
=$8b					TOK_SEMICOLON = $8b
=$8c					TOK_AND = $8c
=$8d					TOK_OR = $8d
=$8e					TOK_XOR = $8e
=$8f					TOK_GREATER = $8f
=$90					TOK_GREATEREQUAL = $90
=$91					TOK_LESS = $91
=$92					TOK_LESSEQUAL = $92
=$93					TOK_EQUAL = $93
=$94					TOK_LESSGREATER = $94
=$95					TOK_PLUS = $95
=$96					TOK_MINUS = $96
=$97					TOK_STAR = $97
=$98					TOK_SLASH = $98
=$99					TOK_MOD = $99
=$9a					TOK_LENLPAREN = $9a
=$9b					TOK_RNDLPAREN = $9b
=$9c					TOK_ASCLPAREN = $9c
=$9d					TOK_CHRDOLLARLPAREN = $9d
=$9e					TOK_VALLPAREN = $9e
=$9f					TOK_STRDOLLARLPAREN = $9f
=$a0					TOK_SPCLPAREN = $a0
=$a1					TOK_LEFTDOLLARLPAREN = $a1
=$a2					TOK_MIDDOLLARLPAREN = $a2
=$a3					TOK_RIGHTDOLLARLPAREN = $a3
=$a4					TOK_ABSLPAREN = $a4
=$a5					TOK_SGNLPAREN = $a5
=$a6					TOK_INTLPAREN = $a6
=$a7					TOK_RANDOMLPAREN = $a7
=$a8					TOK_DEEKLPAREN = $a8
=$a9					TOK_PEEKLPAREN = $a9
=$aa					TOK_VPEEKLPAREN = $aa
=$ab					TOK_IF = $ab
=$ac					TOK_REPEAT = $ac
=$ad					TOK_FOR = $ad
=$ae					TOK_WHILE = $ae
=$af					TOK_CASE = $af
=$b0					TOK_THEN = $b0
=$b1					TOK_ENDIF = $b1
=$b2					TOK_UNTIL = $b2
=$b3					TOK_NEXT = $b3
=$b4					TOK_ENDWHILE = $b4
=$b5					TOK_ENDCASE = $b5
=$b6					TOK_TO = $b6
=$b7					TOK_STEP = $b7
=$b8					TOK_PROC = $b8
=$b9					TOK_ENDPROC = $b9
=$ba					TOK_CALL = $ba
=$bb					TOK_LOCAL = $bb
=$bc					TOK_RUN = $bc
=$bd					TOK_STOP = $bd
=$be					TOK_END = $be
=$bf					TOK_PRINT = $bf
=$c0					TOK_INPUT = $c0
=$c1					TOK_WHEN = $c1
=$c2					TOK_DEFAULT = $c2
=$c3					TOK_LET = $c3
=$c4					TOK_OPTION = $c4
=$c5					TOK_LIST = $c5
=$c6					TOK_LOAD = $c6
=$c7					TOK_SAVE = $c7
=$c8					TOK_NEW = $c8
=$c9					TOK_OLD = $c9
=$ca					TOK_POKE = $ca
=$cb					TOK_DOKE = $cb
=$cc					TOK_VPOKE = $cc
=$cd					TOK_REM = $cd
=$ce					TOK_GOTO = $ce
=$cf					TOK_GOSUB = $cf
=$d0					TOK_SYS = $d0
=$d1					TOK_RETURN = $d1
=$d2					TOK_ASSERT = $d2
=$d3					TOK_ON = $d3
=$d4					TOK_OPEN = $d4
=$d5					TOK_CLOSE = $d5
=$d6					TOK_DIR = $d6
=$d7					TOK_DIM = $d7
=$d8					TOK_READ = $d8
=$d9					TOK_DATA = $d9
=$da					TOK_RESTORE = $da

;******  Return to file: files.asm


;******  Processing file: code/error.asm

.12c0					SyntaxError:
.12c0	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>12c3	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>12cb	72 72 6f 72 00
.12d0					TypeMismatch:
.12d0	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>12d3	54 79 70 65 20 4d 69 73				.text 	"Type Mismatch",0
>12db	6d 61 74 63 68 00
.12e1					ParameterError:
.12e1	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>12e4	50 61 72 61 6d 65 74 65				.text 	"Parameter",0
>12ec	72 00
.12ee					ErrorHandler:
.12ee	68		pla				pla 								; get message address
.12ef	7a		ply				ply
.12f0	1a		inc a				inc 	a
.12f1	d0 01		bne $12f4			bne 	_EHNoCarry
.12f3	c8		iny				iny
.12f4					_EHNoCarry:
.12f4	20 07 14	jsr $1407			jsr 	EXPrintString
.12f7	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.12f9	b1 00		lda ($00),y			lda 	(codePtr),y
.12fb	c8		iny				iny
.12fc	11 00		ora ($00),y			ora 	(codePtr),y
.12fe	f0 14		beq $1314			beq 	_EHNoLine
.1300	a9 1e		lda #$1e			lda 	#_EHMsg2 & $FF 				; print " at "
.1302	a0 13		ldy #$13			ldy 	#_EHMsg2 >> 8
.1304	20 07 14	jsr $1407			jsr 	EXPrintString
.1307	a0 02		ldy #$02			ldy 	#2 							; print line number
.1309	b1 00		lda ($00),y			lda 	(codePtr),y
.130b	48		pha				pha
.130c	88		dey				dey
.130d	b1 00		lda ($00),y			lda 	(codePtr),y
.130f	7a		ply				ply
.1310	18		clc				clc
.1311	20 73 1a	jsr $1a73			jsr 	PrintYA
.1314					_EHNoLine:
.1314	a9 0d		lda #$0d			lda 	#13
.1316	20 40 13	jsr $1340			jsr 	ExternPrint
.1319	80 fe		bra $1319	_h1:	bra 	_h1
.131b	4c eb 1b	jmp $1beb			jmp 	WarmStart
.131e					_EHMsg2:
>131e	20 61 74 20 00					.text 	" at ",0

;******  Return to file: files.asm


;******  Processing file: code/extern.asm

.1323					ExternInitialise:
.1323	a9 93		lda #$93			lda 	#147 						; clear screen
.1325	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1328	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.132a	4c 4c 13	jmp $134c			jmp 	ExternColour
.132d					ExternCheckBreak:
.132d	da		phx				phx 								; make sure we keep XY
.132e	5a		phy				phy
.132f	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.1332	f0 03		beq $1337			beq		_ECBExit 					; stopped
.1334	7a		ply				ply 								; restore and exit.
.1335	fa		plx				plx
.1336	60		rts				rts
.1337					_ECBExit:
.1337	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>133a	42 72 65 61 6b 00				.text 	"Break",0
.1340					ExternPrint:
.1340	48		pha				pha
.1341	da		phx				phx
.1342	5a		phy				phy
.1343	29 7f		and #$7f			and 	#$7F
.1345	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1348	7a		ply				ply
.1349	fa		plx				plx
.134a	68		pla				pla
.134b	60		rts				rts
.134c					ExternColour:
.134c	48		pha				pha
.134d	da		phx				phx
.134e	48		pha				pha
.134f	29 08		and #$08			and 	#8
.1351	0a		asl a				asl 	a
.1352	0a		asl a				asl 	a
.1353	0a		asl a				asl 	a
.1354	0a		asl a				asl 	a
.1355	49 92		eor #$92			eor 	#$92
.1357	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.135a	68		pla				pla
.135b	29 07		and #$07			and 	#7
.135d	aa		tax				tax
.135e	bd 67 13	lda $1367,x			lda 	_ECTable,x
.1361	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1364	fa		plx				plx
.1365	68		pla				pla
.1366	60		rts				rts
.1367					_ECTable:
>1367	90						.byte 	144
>1368	1c						.byte 	28
>1369	1e						.byte 	30
>136a	9e						.byte 	158
>136b	1f						.byte 	31
>136c	9c						.byte 	156
>136d	9f						.byte 	159
>136e	05						.byte 	5
.136f					ExternInput:
.136f	a9 00		lda #$00			lda 	#(textBuffer & $FF)
.1371	85 07		sta $07				sta 	zTemp3
.1373	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1375	85 08		sta $08				sta 	zTemp3+1
.1377	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.137a	c9 0d		cmp #$0d			cmp 	#13
.137c	f0 0c		beq $138a			beq 	_EIExit
.137e	29 7f		and #$7f			and 	#$7F
.1380	92 07		sta ($07)			sta 	(zTemp3)
.1382	e6 07		inc $07				inc 	zTemp3
.1384	d0 f1		bne $1377			bne 	_EIRead
.1386	e6 08		inc $08				inc 	zTemp3+1
.1388	80 ed		bra $1377			bra 	_EIRead
.138a	a9 00		lda #$00	_EIExit:lda 	#0
.138c	92 07		sta ($07)			sta 	(zTemp3)
.138e	a9 0d		lda #$0d			lda 	#13
.1390	20 40 13	jsr $1340			jsr 	ExternPrint
.1393	60		rts				rts
.1394					ExternSave:
.1394	da		phx				phx
.1395	5a		phy				phy
.1396	85 05		sta $05				sta 	zTemp2 						; save start
.1398	84 06		sty $06				sty 	zTemp2+1
.139a	20 fc 13	jsr $13fc			jsr 	EXGetLength 				; get length of file into A
.139d	a6 07		ldx $07				ldx 	zTemp3
.139f	a4 08		ldy $08				ldy 	zTemp3+1
.13a1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.13a4	a9 01		lda #$01			lda 	#1
.13a6	a2 08		ldx #$08			ldx 	#8	 						; device #8
.13a8	a0 00		ldy #$00			ldy 	#0
.13aa	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.13ad	a6 03		ldx $03				ldx 	zTemp1 						; end address
.13af	a4 04		ldy $04				ldy 	zTemp1+1
.13b1	a9 05		lda #$05			lda 	#zTemp2
.13b3	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.13b6	b0 03		bcs $13bb			bcs 	_ESSave
.13b8	7a		ply				ply
.13b9	fa		plx				plx
.13ba	60		rts				rts
.13bb					_ESSave:
.13bb	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>13be	4c 6f 61 64 20 46 61 69				.text 	"Load Failed",0
>13c6	6c 65 64 00
.13ca					ExternLoad:
.13ca	da		phx				phx 								; save XY
.13cb	5a		phy				phy
.13cc	48		pha				pha 								; save target
.13cd	5a		phy				phy
.13ce	20 fc 13	jsr $13fc			jsr 	EXGetLength 				; get length of file into A
.13d1	a6 07		ldx $07				ldx 	zTemp3
.13d3	a4 08		ldy $08				ldy 	zTemp3+1
.13d5	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.13d8	a9 01		lda #$01			lda 	#1
.13da	a2 08		ldx #$08			ldx 	#8	 						; device #8
.13dc	a0 00		ldy #$00			ldy 	#0
.13de	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.13e1	7a		ply				ply 								; restore target to YX and call load
.13e2	fa		plx				plx
.13e3	a9 00		lda #$00			lda 	#0 							; load command
.13e5	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.13e8	b0 03		bcs $13ed			bcs 	_ESLoad
.13ea	7a		ply				ply
.13eb	fa		plx				plx
.13ec	60		rts				rts
.13ed					_ESLoad:
.13ed	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>13f0	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>13f8	4c 45 44 00
.13fc					EXGetLength:
.13fc	5a		phy				phy
.13fd	a0 ff		ldy #$ff			ldy 	#255
.13ff	c8		iny		_EXGL0:	iny
.1400	b1 07		lda ($07),y			lda 	(zTemp3),y
.1402	d0 fb		bne $13ff			bne 	_EXGL0
.1404	98		tya				tya
.1405	7a		ply				ply
.1406	60		rts				rts
.1407					EXPrintString:
.1407	48		pha				pha
.1408	5a		phy				phy
.1409	84 04		sty $04				sty 	zTemp1+1
.140b	85 03		sta $03				sta 	zTemp1
.140d	a0 00		ldy #$00			ldy 	#0
.140f					_EXPSLoop:
.140f	b1 03		lda ($03),y			lda 	(zTemp1),y
.1411	f0 13		beq $1426			beq 	_EXPSExit
.1413	29 7f		and #$7f			and 	#$7F
.1415	c9 61		cmp #$61			cmp 	#'a'
.1417	90 07		bcc $1420			bcc 	_EXPSNoLC
.1419	c9 7b		cmp #$7b			cmp 	#'z'+1
.141b	b0 03		bcs $1420			bcs 	_EXPSNoLC
.141d	38		sec				sec
.141e	e9 20		sbc #$20			sbc 	#32
.1420					_EXPSNoLC:
.1420	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1423	c8		iny				iny
.1424	80 e9		bra $140f			bra 	_EXPSLoop
.1426					_EXPSExit:
.1426	7a		ply				ply
.1427	68		pla				pla
.1428	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: code/structstack.asm

.1429					StructReset:
.1429	a9 7f		lda #$7f			lda 	#$7F	 					; reset the SP points to TOS
.142b	85 02		sta $02				sta 	structSP
.142d	a9 ff		lda #$ff			lda 	#$FF 						; put a dummy marker that can't be a struct marker
.142f	8d ff 07	sta $07ff			sta 	structStack+$7F
.1432	60		rts				rts
.1433					StructPushA:
.1433	da		phx				phx 								; save X
.1434	c6 02		dec $02				dec 	structSP 					; make space on stack
.1436	f0 07		beq $143f			beq 	SPUnderflow 				; no space left
.1438	a6 02		ldx $02				ldx 	structSP 					; get offset into X
.143a	9d 80 07	sta $0780,x			sta 	structStack,x 				; and save
.143d	fa		plx				plx
.143e	60		rts				rts
.143f					SPUnderflow:
.143f	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>1442	53 74 72 75 63 74 75 72				.text 	"Structure Stack",0
>144a	65 20 53 74 61 63 6b 00
.1452					StructPushPos:
.1452	da		phx				phx
.1453	a5 02		lda $02				lda 	structSP 					; make space for 3 bytes
.1455	38		sec				sec
.1456	e9 03		sbc #$03			sbc 	#3
.1458	f0 e5		beq $143f			beq 	SPUnderflow
.145a	90 e3		bcc $143f			bcc 	SPUnderflow 				; borrowed, so underflowed.
.145c	85 02		sta $02				sta 	structSP
.145e	aa		tax				tax 								; X points to space
.145f	98		tya				tya 								; save offset
.1460	9d 80 07	sta $0780,x			sta 	structStack,x
.1463	a5 00		lda $00				lda 	codePtr 					; save address of line
.1465	9d 81 07	sta $0781,x			sta 	structStack+1,x
.1468	a5 01		lda $01				lda 	codePtr+1
.146a	9d 82 07	sta $0782,x			sta 	structStack+2,x
.146d	fa		plx				plx
.146e	60		rts				rts
.146f					StructGetPos:
.146f	18		clc				clc 								; add offset to stack pointer.
.1470	65 02		adc $02				adc 	structSP
.1472	aa		tax				tax
.1473	bd 80 07	lda $0780,x			lda 	structStack,x 				; Y offset
.1476	a8		tay				tay
.1477	bd 81 07	lda $0781,x			lda 	structStack+1,x
.147a	85 00		sta $00				sta 	codePtr
.147c	bd 82 07	lda $0782,x			lda 	structStack+2,x
.147f	85 01		sta $01				sta 	codePtr+1
.1481	60		rts				rts
.1482					StructPopABytes:
.1482	18		clc				clc
.1483	65 02		adc $02				adc 	structSP
.1485	85 02		sta $02				sta 	structSP
.1487	60		rts				rts
.1488					StructCheckTOS:
.1488	da		phx				phx
.1489	a6 02		ldx $02				ldx 	structSP 					; get offset to TOS
.148b	5d 80 07	eor $0780,x			eor 	structStack,x 				; zero if match, non zero if didn't
.148e	18		clc				clc
.148f	69 ff		adc #$ff			adc 	#$FF 						; carry will now be set if it doesn't match
.1491	fa		plx				plx 								; restore X and exit
.1492	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: code/syntax.asm

.1493					SyntaxCheckRightBracket:
.1493	b1 00		lda ($00),y			lda 	(codePtr),y
.1495	c8		iny				iny
.1496	c9 88		cmp #$88			cmp 	#TOK_RPAREN
.1498	d0 01		bne $149b			bne 	_SCRBError
.149a	60		rts				rts
.149b					_SCRBError:
.149b	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>149e	4d 69 73 73 69 6e 67 20				.text 	"Missing )",0
>14a6	29 00
.14a8					SyntaxCheckComma:
.14a8	b1 00		lda ($00),y			lda 	(codePtr),y
.14aa	c8		iny				iny
.14ab	c9 8a		cmp #$8a			cmp 	#TOK_COMMA
.14ad	d0 01		bne $14b0			bne 	_SCRCError
.14af	60		rts				rts
.14b0					_SCRCError:
.14b0	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>14b3	4d 69 73 73 69 6e 67 20				.text 	"Missing ,",0
>14bb	2c 00
.14bd					SyntaxCheckA:
.14bd	d1 00		cmp ($00),y			cmp 	(codePtr),y
.14bf	d0 02		bne $14c3			bne 	_SCAError
.14c1	c8		iny				iny
.14c2	60		rts				rts
.14c3					_SCAError:
.14c3	4c c0 12	jmp $12c0			jmp 	SyntaxError

;******  Return to file: files.asm


;******  Processing file: commands/let.asm

.14c6					Command_LET:
.14c6	a2 00		ldx #$00			ldx 	#0 							; get the L-Expr
.14c8	20 97 17	jsr $1797			jsr 	EvaluateTermAtX
.14cb	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; check to see if it is a reference.
.14ce	6a		ror a				ror 	a
.14cf	90 38		bcc $1509			bcc 	_CLTNotVar 					; if not, then we have an error.
.14d1	a9 93		lda #$93			lda 	#TOK_EQUAL					; next token must be an equals.
.14d3	20 bd 14	jsr $14bd			jsr 	SyntaxCheckA
.14d6	e8		inx				inx
.14d7	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; calculate the R-Expr in level 1.
.14da	ad 20 06	lda $0620			lda 	xsAddrLow
.14dd	85 03		sta $03				sta 	zTemp1
.14df	ad 40 06	lda $0640			lda 	xsAddrHigh
.14e2	85 04		sta $04				sta 	zTemp1+1
.14e4	ad 00 06	lda $0600			lda 	xsStatus 					; check the same types.
.14e7	4d 01 06	eor $0601			eor 	xsStatus+1
.14ea	29 40		and #$40			and 	#$40
.14ec	d0 1e		bne $150c			bne 	_CLTTypeMismatch
.14ee	2c 00 06	bit $0600			bit 	xsStatus 					; string to string assignment
.14f1	70 30		bvs $1523			bvs 	_CLTStringAssignment
.14f3	30 2c		bmi $1521			bmi 	_CLTFloatAssignment
.14f5	2c 01 06	bit $0601			bit 	xsStatus+1 					; are we assigning a float to an integer ?
.14f8	70 15		bvs $150f			bvs 	_CLTFloatToInt 				; yes, then we do not auto truncate.
.14fa	5a		phy				phy 								; copy value into reference.
.14fb	ad 21 06	lda $0621			lda 	xsIntLow+1
.14fe	92 03		sta ($03)			sta 	(zTemp1)
.1500	a0 01		ldy #$01			ldy 	#1
.1502	ad 41 06	lda $0641			lda 	xsIntHigh+1
.1505	91 03		sta ($03),y			sta 	(zTemp1),y
.1507	7a		ply				ply
.1508	60		rts				rts
.1509					_CLTNotVar:
.1509	4c c0 12	jmp $12c0			jmp 	SyntaxError
.150c					_CLTTypeMismatch:
.150c	4c d0 12	jmp $12d0			jmp 	TypeMismatch
.150f					_CLTFloatToInt:
.150f	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>1512	50 72 65 63 69 73 69 6f				.text 	"Precision Lost",0
>151a	6e 20 4c 6f 73 74 00
.1521					_CLTFloatAssignment:
.1521	80 fe		bra $1521			bra 	_CLTFloatAssignment
.1523					_CLTStringAssignment:
.1523	80 fe		bra $1523			bra 	_CLTStringAssignment

;******  Return to file: files.asm


;******  Processing file: commands/gosub.asm

.1525					Command_Gosub:
.1525	20 c7 16	jsr $16c7			jsr 	EvaluateExpression 			; get the line number.
.1528	20 52 14	jsr $1452			jsr 	StructPushPos 				; save position
.152b	a9 47		lda #$47			lda 	#SMARK_GOSUB 				; push a GOSUB marker
.152d	20 33 14	jsr $1433			jsr 	StructPushA
.1530	20 59 15	jsr $1559			jsr 	TransferControlToStack		; branch to there
.1533	60		rts				rts
.1534					Command_Return:
.1534	a9 47		lda #$47			lda 	#SMARK_GOSUB 						; thing to check against
.1536	20 88 14	jsr $1488			jsr 	StructCheckTOS 				; is it on top ?
.1539	90 0c		bcc $1547			bcc 	_Ok
.153b	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>153e	4e 6f 20 47 6f 73 75 62				.text 	"No Gosub",0
>1546	00
.1547					_Ok:
.1547	a9 01		lda #$01			lda 	#1 							; restore return address
.1549	20 6f 14	jsr $146f			jsr 	StructGetPos
.154c	a9 04		lda #$04			lda 	#4 							; pop the address and marker
.154e	20 82 14	jsr $1482			jsr 	StructPopABytes
.1551	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: commands/goto.asm

.1552					Command_GOTO:
.1552	20 c7 16	jsr $16c7			jsr 	EvaluateExpression 			; get the line number.
.1555	20 59 15	jsr $1559			jsr 	TransferControlToStack		; branch to there
.1558	60		rts				rts
.1559					TransferControlToStack:
.1559	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary 			; remove a reference.
.155c	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; must be an integer.
.155f	d0 35		bne $1596			bne 	_TCTBadLine
.1561	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; copy line # to zTemp1
.1564	85 03		sta $03				sta 	zTemp1
.1566	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.1569	85 04		sta $04				sta 	zTemp1+1
.156b	a9 46		lda #$46			lda 	#(BasicProgram) & $FF
.156d	85 00		sta $00				sta 	0+(codePtr)
.156f	a9 1c		lda #$1c			lda 	#(BasicProgram) >> 8
.1571	85 01		sta $01				sta 	1+(codePtr)
.1573					_TCTLoop:
.1573	b2 00		lda ($00)			lda 	(codePtr) 					; didn't find it
.1575	f0 22		beq $1599			beq 	_TCTUnknown
.1577	a0 01		ldy #$01			ldy 	#1 		 					; does it match ?
.1579	b1 00		lda ($00),y			lda		(codePtr),y
.157b	c5 03		cmp $03				cmp 	zTemp1
.157d	d0 07		bne $1586			bne 	_TCTGoNext
.157f	c8		iny				iny
.1580	b1 00		lda ($00),y			lda		(codePtr),y
.1582	c5 04		cmp $04				cmp 	zTemp1+1
.1584	f0 0d		beq $1593			beq 	_TCTFound
.1586					_TCTGoNext:
.1586	18		clc				clc
.1587	a5 00		lda $00				lda 	codePtr
.1589	72 00		adc ($00)			adc 	(codePtr)
.158b	85 00		sta $00				sta 	codePtr
.158d	90 02		bcc $1591			bcc 	_NoCarryAdv
.158f	e6 01		inc $01				inc 	codePtr+1
.1591					_NoCarryAdv:
.1591	80 e0		bra $1573			bra 	_TCTLoop 					; loop round
.1593					_TCTFound:
.1593	a0 03		ldy #$03			ldy 	#3 							; from start of the line
.1595	60		rts				rts
.1596					_TCTBadLine:
.1596	4c e1 12	jmp $12e1			jmp 	ParameterError
.1599					_TCTUnknown:
.1599	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>159c	4c 69 6e 65 20 6e 75 6d				.text 	"Line number",0
>15a4	62 65 72 00

;******  Return to file: files.asm


;******  Processing file: commands/if.asm

.15a8					IfCommand:
.15a8	20 c7 16	jsr $16c7			jsr 	EvaluateExpression 			; this is the IF test.
.15ab	20 a2 17	jsr $17a2			jsr 	DereferenceUnary 			; make it an integer value.
.15ae	2c 00 06	bit $0600			bit 	xsStatus 					; check type
.15b1	70 2d		bvs $15e0			bvs 	_IFCType 					; string, error
.15b3	10 03		bpl $15b8			bpl 	_IFCInteger 				; if float
.15b5	20 c2 1b	jsr $1bc2			jsr 	FPFloatToInteger  			; convert to integer
.15b8					_IFCInteger:
.15b8	b1 00		lda ($00),y			lda 	(codePtr),y 				; what follows ?
.15ba	c9 b0		cmp #$b0			cmp 	#TOK_THEN 					; if it is not then it is multiline IF
.15bc	d0 25		bne $15e3			bne 	_IFCMultiline
.15be	c8		iny				iny
.15bf	ad 20 06	lda $0620			lda 	xsIntLow 					; check if it is non-zero
.15c2	0d 40 06	ora $0640			ora 	xsIntHigh
.15c5	d0 05		bne $15cc			bne 	_IFCExecute 				; if so, then execute the rest of the line.
.15c7	b2 00		lda ($00)			lda 	(codePtr)					; point at the last character on the line
.15c9	a8		tay				tay
.15ca	88		dey				dey
.15cb	60		rts				rts
.15cc					_IFCExecute:
.15cc	b1 00		lda ($00),y			lda 	(codePtr),y 				; what follows ? if it is a number, then do GOTO
.15ce	c9 fe		cmp #$fe			cmp 	#TOK_BYTE_OBJ 				; byte/word tokens
.15d0	f0 0b		beq $15dd			beq 	_IFCGoto
.15d2	c9 ff		cmp #$ff			cmp 	#TOK_WORD_OBJ
.15d4	f0 07		beq $15dd			beq 	_IFCGoto
.15d6	29 c0		and #$c0			and 	#$C0 						; check for 40-7F the short constants.
.15d8	c9 40		cmp #$40			cmp 	#$40
.15da	f0 01		beq $15dd			beq 	_IFCGoto
.15dc	60		rts				rts
.15dd					_IFCGoto:
.15dd	4c 52 15	jmp $1552			jmp 	Command_GOTO
.15e0					_IFCType:
.15e0	4c d0 12	jmp $12d0			jmp 	TypeMismatch
.15e3					_IFCMultiline:
.15e3	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>15e6	49 46 2e 2e 45 4e 44 49				.text 	"IF..ENDIF not implemented",0
>15ee	46 20 6e 6f 74 20 69 6d 70 6c 65 6d 65 6e 74 65
>15fe	64 00

;******  Return to file: files.asm


;******  Processing file: commands/miscellany.asm

.1600					Command_Assert:
.1600	a2 00		ldx #$00			ldx 	#0 							; get a single parameter
.1602	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1605	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1608	20 dc 17	jsr $17dc			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.160b	90 03		bcc $1610			bcc 	_Integer
.160d	4c c0 12	jmp $12c0			jmp 	SyntaxError
.1610					_Integer:
.1610	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; check it is non-zero
.1613	1d 40 06	ora $0640,x			ora 	xsIntHigh,x
.1616	f0 01		beq $1619			beq 	_CAFail
.1618	60		rts				rts
.1619					_CAFail:
.1619	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>161c	41 73 73 65 72 74 00				.text 	"Assert",0
.1623					Command_Rem:
.1623	b1 00		lda ($00),y			lda 	(codePtr),y
.1625	c9 fb		cmp #$fb			cmp 	#TOK_STRING_OBJ 			; is there a string ?
.1627	d0 06		bne $162f			bne 	_CRExit
.1629	c8		iny				iny 								; then skip over it.
.162a	38		sec				sec
.162b	98		tya				tya
.162c	71 00		adc ($00),y			adc 	(codePtr),y
.162e	a8		tay				tay
.162f					_CRExit:
.162f	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: commands/pokedoke.asm

.1630					Command_Poke:
.1630	18		clc				clc
.1631	80 01		bra $1634			bra 	WriteMemoryMain
.1633					Command_Doke:
.1633	38		sec				sec
.1634					WriteMemoryMain:
.1634	08		php				php									; save cc byte cs word
.1635	a2 00		ldx #$00			ldx 	#0 							; get address and parameter.
.1637	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; evaluate the term
.163a	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary 			; convert term to value if reference.
.163d	20 dc 17	jsr $17dc			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1640	90 03		bcc $1645			bcc 	_Integer
.1642	4c d0 12	jmp $12d0			jmp 	TypeMismatch
.1645					_Integer:
.1645	20 a8 14	jsr $14a8			jsr 	SyntaxCheckComma
.1648	e8		inx				inx
.1649	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; evaluate the term
.164c	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary 			; convert term to value if reference.
.164f	20 dc 17	jsr $17dc			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1652	90 03		bcc $1657			bcc 	_Integer
.1654	4c d0 12	jmp $12d0			jmp 	TypeMismatch
.1657					_Integer:
.1657	ad 20 06	lda $0620			lda 	xsAddrLow 					; transfer address
.165a	85 03		sta $03				sta 	zTemp1
.165c	ad 40 06	lda $0640			lda 	xsAddrHigh
.165f	85 04		sta $04				sta 	zTemp1+1
.1661	ad 21 06	lda $0621			lda 	xsIntLow+1 					; do the poke anyway
.1664	92 03		sta ($03)			sta 	(zTemp1)
.1666	28		plp				plp
.1667	b0 09		bcs $1672			bcs 	_WMMWord
.1669	ad 41 06	lda $0641			lda 	xsIntHigh+1 				; get high byte
.166c	d0 01		bne $166f			bne 	_WMMByteReq 				; should be zero
.166e	60		rts				rts
.166f					_WMMByteReq:
.166f	4c e1 12	jmp $12e1			jmp 	ParameterError
.1672					_WMMWord:
.1672	5a		phy				phy
.1673	a0 01		ldy #$01			ldy 	#1
.1675	ad 41 06	lda $0641			lda 	xsIntHigh+1
.1678	91 03		sta ($03),y			sta 	(zTemp1),y
.167a	7a		ply				ply
.167b	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: commands/run.asm

.167c					Command_RUN:
.167c	20 29 14	jsr $1429			jsr 	StructReset 				; reset the structure stack.
.167f	a9 46		lda #$46			lda 	#(BasicProgram) & $FF
.1681	85 00		sta $00				sta 	0+(codePtr)
.1683	a9 1c		lda #$1c			lda 	#(BasicProgram) >> 8
.1685	85 01		sta $01				sta 	1+(codePtr)
.1687					_CRNewLine:
.1687	b2 00		lda ($00)			lda 	(codePtr) 					; check not at the end of the program
.1689	f0 31		beq $16bc			beq 	Command_END 				; reached the end of the program
.168b	a0 02		ldy #$02			ldy 	#2 							; first token of program line -1 for the INY
.168d					_CRNextToken:
.168d	c8		iny				iny 								;
.168e					_CRNextCommand:
.168e	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token.
.1690	10 25		bpl $16b7			bpl 	_CRDefaultLet 				; is it a token, if not, try LET.
.1692	c9 89		cmp #$89			cmp 	#TOK_COLON 					; skip colons
.1694	f0 f7		beq $168d			beq 	_CRNextToken
.1696	c9 db		cmp #$db			cmp 	#TOK_LAST_TOKEN				; token too high, probably $F8-$FF
.1698	b0 1a		bcs $16b4			bcs 	_CRSyntax
.169a	0a		asl a				asl 	a 							; put token x 2 in X, clears bit 7.
.169b	f0 07		beq $16a4			beq 	_CRNextLine 				; if this is zero now it was $80, so end of line
.169d	aa		tax				tax
.169e	c8		iny				iny 								; advance over token.
.169f	20 b1 16	jsr $16b1			jsr 	_CRCallRoutine 				; call that routine
.16a2	80 ea		bra $168e			bra 	_CRNextCommand 				; and carry on.
.16a4					_CRNextLine:
.16a4	18		clc				clc
.16a5	a5 00		lda $00				lda 	codePtr
.16a7	72 00		adc ($00)			adc 	(codePtr)
.16a9	85 00		sta $00				sta 	codePtr
.16ab	90 02		bcc $16af			bcc 	_NoCarryAdv
.16ad	e6 01		inc $01				inc 	codePtr+1
.16af					_NoCarryAdv:
.16af	80 d6		bra $1687			bra 	_CRNewLine 					; do new line code.
.16b1					_CRCallRoutine:
.16b1	7c 0a 12	jmp ($120a,x)			jmp 	(TokenVectors,x)
.16b4					_CRSyntax:
.16b4	4c c0 12	jmp $12c0			jmp 	SyntaxError
.16b7					_CRDefaultLet:
.16b7	20 c6 14	jsr $14c6			jsr 	Command_LET
.16ba	80 d2		bra $168e			bra 	_CRNextCommand
.16bc					Command_END:
.16bc	4c eb 1b	jmp $1beb			jmp 	WarmStart
.16bf					Command_STOP:
.16bf	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>16c2	53 74 6f 70 00					.text 	"Stop",0

;******  Return to file: files.asm


;******  Processing file: expression/evaluate.asm

.16c7					EvaluateExpression:
.16c7	a2 00		ldx #$00			ldx 	#0 							; reset the evaluation stack pointer in X
.16c9					EvaluateExpressionAtX:
.16c9	a9 10		lda #$10			lda 	#$10 						; this is the lowest precedence.
.16cb					EvaluateExpressionAtXPrecA:
.16cb	48		pha				pha 								; save lowest stack level.
.16cc	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first term.
.16ce	30 4f		bmi $171f			bmi 	_EXAKeywordData 			; is it keyword, or data.
.16d0	c9 40		cmp #$40			cmp 	#$40 						; is it a variable (0-3F)
.16d2	90 46		bcc $171a			bcc 	_EXAVariable
.16d4	c8		iny				iny 								; skip over the short constant
.16d5	29 3f		and #$3f			and 	#$3F 						; short constant $00-$3F
.16d7	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and put as an integer
.16da	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.16dd	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; integer, number, not a reference.
.16e0					_EXAHaveTerm:
.16e0	68		pla				pla 	 							; restore current precedence and save in zTemp1
.16e1	85 03		sta $03				sta 	zTemp1
.16e3	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by a binary operation.
.16e5	da		phx				phx
.16e6	aa		tax				tax
.16e7	bd 2e 11	lda $112e,x			lda 	TokenControlByteTable-$80,x ; get the control byte.
.16ea	fa		plx				plx
.16eb	c9 20		cmp #$20			cmp 	#$20 						; must be $10-$17 (or possibly $00, will be < precedence)
.16ed	b0 06		bcs $16f5			bcs 	_EXAExit
.16ef	c5 03		cmp $03				cmp 	zTemp1 						; check against current precedence.
.16f1	f0 02		beq $16f5			beq 	_EXAExit
.16f3	b0 01		bcs $16f6			bcs		_EXABinaryOp 				; if >, do a binary operation.
.16f5					_EXAExit:
.16f5	60		rts				rts 								; exit expression evaluation.
.16f6					_EXABinaryOp:
.16f6	85 04		sta $04				sta 	zTemp1+1 					; save operator.
.16f8	a5 03		lda $03				lda 	zTemp1 						; get and save current precedence
.16fa	48		pha				pha
.16fb	b1 00		lda ($00),y			lda 	(codePtr),y 				; push binary operator on stack
.16fd	48		pha				pha
.16fe	c8		iny				iny 								; and skip over it.
.16ff	e8		inx				inx 								; calculate the RHS in the next slot up.
.1700	a5 04		lda $04				lda 	zTemp1+1 					; at operator precedence level.
.1702	20 cb 16	jsr $16cb			jsr 	EvaluateExpressionAtXPrecA
.1705	ca		dex				dex
.1706	68		pla				pla 								; get binary operator.
.1707	da		phx				phx 								; save stack depth.
.1708	0a		asl a				asl 	a 							; double binary operator and put into X, loses MSB
.1709	aa		tax				tax
.170a	bd 0a 12	lda $120a,x			lda 	TokenVectors,x 				; get address => zTemp2
.170d	85 05		sta $05				sta 	zTemp2
.170f	bd 0b 12	lda $120b,x			lda 	TokenVectors+1,x
.1712	85 06		sta $06				sta 	zTemp2+1
.1714	fa		plx				plx 								; restore stack depth.
.1715	20 94 17	jsr $1794			jsr 	_EXACallZTemp2 				; call the routine
.1718	80 c6		bra $16e0			bra 	_EXAHaveTerm 				; and loop round again.
.171a					_EXAVariable:
.171a	20 9b 1b	jsr $1b9b			jsr 	VariableLookup 				; look up the variable value perhaps creating it.
.171d	80 c1		bra $16e0			bra 	_EXAHaveTerm 				; and carry on with the expression
.171f					_EXAKeywordData:
.171f	c9 96		cmp #$96			cmp 	#TOK_MINUS 					; special case as - is unary and binary operator.
.1721	d0 09		bne $172c			bne 	_EXANotNegate
.1723	c8		iny				iny
.1724	20 97 17	jsr $1797			jsr 	EvaluateTermAtX 			; the term
.1727	20 8b 19	jsr $198b			jsr 	IntegerNegate 				; negate it
.172a	80 b4		bra $16e0			bra 	_EXAHaveTerm 				; and loop back.
.172c					_EXANotNegate:
.172c	c9 f8		cmp #$f8			cmp 	#$F8 						; $80-$F8 are unary functions
.172e	90 45		bcc $1775			bcc 	_EXAUnaryFunction
.1730	c9 fb		cmp #$fb			cmp 	#TOK_STRING_OBJ 			; $FB is a string.
.1732	f0 25		beq $1759			beq 	_EXAString
.1734	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; it is now either $FE (short int) or $FF (long int)
.1737	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.173a	48		pha				pha 								; save identifier
.173b	c8		iny				iny 								; do the low byte
.173c	b1 00		lda ($00),y			lda 	(codePtr),y
.173e	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1741	c8		iny				iny
.1742	68		pla				pla 								; get identifier
.1743	c9 fe		cmp #$fe			cmp 	#TOK_BYTE_OBJ  				; if short then done.
.1745	f0 99		beq $16e0			beq 	_EXAHaveTerm
.1747	c9 ff		cmp #$ff			cmp 	#TOK_WORD_OBJ 				; should be $FF
.1749	d0 08		bne $1753			bne 	_EXACrash
.174b	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy high byte
.174d	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1750	c8		iny				iny
.1751	80 8d		bra $16e0			bra 	_EXAHaveTerm
.1753					_EXACrash:
.1753	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>1756	23 58 00					.text 	"#X",0
.1759					_EXAString:
.1759	c8		iny				iny 								; point to string length, which is the string start.
.175a	98		tya				tya 								; work out the physical address of the string
.175b	18		clc				clc
.175c	65 00		adc $00				adc 	codePtr
.175e	9d 20 06	sta $0620,x			sta 	xsAddrLow,x
.1761	a5 01		lda $01				lda 	codePtr+1
.1763	69 00		adc #$00			adc 	#0
.1765	9d 40 06	sta $0640,x			sta 	xsAddrHigh,x
.1768	a9 40		lda #$40			lda 	#$40 						; set the type to string
.176a	9d 00 06	sta $0600,x			sta 	xsStatus,x
.176d	98		tya				tya 								; add the length to the current position
.176e	38		sec				sec 								; +1 for the length byte itself.
.176f	71 00		adc ($00),y			adc 	(codePtr),y
.1771	a8		tay				tay
.1772	4c e0 16	jmp $16e0			jmp 	_EXAHaveTerm
.1775					_EXAUnaryFunction:
.1775	da		phx				phx 								; get the table entry to check it is a unary function
.1776	aa		tax				tax
.1777	3c 2e 11	bit $112e,x			bit 	TokenControlByteTable-$80,x ; if bit 6 is not set, it's not a unary function.
.177a	50 15		bvc $1791			bvc 	_EXANotUnaryFunction
.177c	8a		txa				txa 								; now copy the routine address, put token x 2 in.
.177d	0a		asl a				asl 	a
.177e	aa		tax				tax
.177f	bd 0a 12	lda $120a,x			lda 	TokenVectors,x 				; get address => zTemp2
.1782	85 05		sta $05				sta 	zTemp2
.1784	bd 0b 12	lda $120b,x			lda 	TokenVectors+1,x
.1787	85 06		sta $06				sta 	zTemp2+1
.1789	fa		plx				plx 								; restore stack depth.
.178a	c8		iny				iny 								; skip unary function token.
.178b	20 94 17	jsr $1794			jsr 	_EXACallZTemp2 				; call the routine
.178e	4c e0 16	jmp $16e0			jmp 	_EXAHaveTerm 				; and loop round again.
.1791					_EXANotUnaryFunction:
.1791	4c c0 12	jmp $12c0			jmp 	SyntaxError
.1794					_EXACallZTemp2:
.1794	6c 05 00	jmp ($0005)			jmp 	(zTemp2)

;******  Return to file: files.asm


;******  Processing file: expression/exprutils.asm

.1797					EvaluateTermAtX:
.1797	a9 1f		lda #$1f			lda 	#$1F 						; too high precedence so just term
.1799	20 cb 16	jsr $16cb			jsr 	EvaluateExpressionAtXPrecA
.179c	60		rts				rts
.179d					DeReferenceBinary:
.179d	e8		inx				inx
.179e	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary
.17a1	ca		dex				dex
.17a2					DeReferenceUnary:
.17a2	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; the reference flag is in bit 0
.17a5	6a		ror a				ror 	a 							; shift into carry.
.17a6	90 33		bcc $17db			bcc 	_DRNotReference 			; if clear, it's already a reference.
.17a8	0a		asl a				asl 	a 							; get back, but with bit 0 cleared
.17a9	9d 00 06	sta $0600,x			sta 	xsStatus,x
.17ac	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put the address to dereference into zTemp1
.17af	85 03		sta $03				sta 	zTemp1
.17b1	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.17b4	85 04		sta $04				sta 	zTemp1+1
.17b6	5a		phy				phy 								; save position in code
.17b7	b2 03		lda ($03)			lda 	(zTemp1) 					; dereference the first two bytes - this will be
.17b9	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; for float, int and string, and will go in these
.17bc	a0 01		ldy #$01			ldy 	#1 							; which are also the address, and mantissa3 & 2
.17be	b1 03		lda ($03),y			lda 	(zTemp1),y
.17c0	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.17c3	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; check if it's a float (bit 7)
.17c6	10 12		bpl $17da			bpl 	_DRNotFloat 				; if not, we are complete
.17c8	c8		iny				iny 								; if float, copy all five bytes of the floating point
.17c9	b1 03		lda ($03),y			lda 	(zTemp1),y 					; number into the stack.
.17cb	9d 60 06	sta $0660,x			sta 	xsMantissa1,x
.17ce	c8		iny				iny
.17cf	b1 03		lda ($03),y			lda 	(zTemp1),y
.17d1	9d 80 06	sta $0680,x			sta 	xsMantissa0,x
.17d4	c8		iny				iny
.17d5	b1 03		lda ($03),y			lda 	(zTemp1),y
.17d7	9d a0 06	sta $06a0,x			sta 	xsExponent,x
.17da					_DRNotFloat:
.17da	7a		ply				ply 								; restore code position.
.17db					_DRNotReference:
.17db	60		rts				rts
.17dc					UnaryNumberTypeCheck:
.17dc	bd 00 06	lda $0600,x			lda 	xsStatus,x
.17df	80 06		bra $17e7			bra 	BNTCMain
.17e1					BinaryNumberTypeCheck:
.17e1	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; bit 7 set if either float, bit 6 set if either string.
.17e4	1d 01 06	ora $0601,x			ora 	xsStatus+1,x
.17e7					BNTCMain:
.17e7	0a		asl a				asl 	a 							; carry set if either float, bit 7 set if either string
.17e8	30 01		bmi $17eb			bmi 	_NTCError 					; so fail if string, we want int
.17ea	60		rts				rts
.17eb					_NTCError:
.17eb	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>17ee	4e 75 6d 62 65 72 20 65				.text 	"Number expected",0
>17f6	78 70 65 63 74 65 64 00
.17fe					BinaryStringTypeCheck:
.17fe	3c 01 06	bit $0601,x			bit 	xsStatus+1,x
.1801	50 06		bvc $1809			bvc 	STCError
.1803					UnaryStringTypeCheck:
.1803	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; check if string
.1806	50 01		bvc $1809			bvc 	STCError
.1808	60		rts				rts
.1809					STCError:
.1809	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>180c	53 74 72 69 6e 67 20 65				.text 	"String expected",0
>1814	78 70 65 63 74 65 64 00

;******  Return to file: files.asm


;******  Processing file: expression/integer/arithmetic.asm

.181c					BinaryAdd:
.181c	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.181f	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.1822	50 06		bvc $182a			bvc 	_NumericType
.1824	20 fe 17	jsr $17fe			jsr 	BinaryStringTypeCheck 		; check both are strings
.1827	4c c0 12	jmp $12c0			jmp 	SyntaxError 							; and do the string handler
.182a					_NumericType:
.182a	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; see if they are compatible.
.182d	90 03		bcc $1832			bcc 	_Integer
.182f	4c c2 1b	jmp $1bc2			jmp 	FPAdd
.1832					_Integer:
.1832	18		clc				clc
.1833	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1836	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.1839	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.183c	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.183f	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.1842	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1845	60		rts				rts
.1846					BinarySub:
.1846	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.1849	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.184c	90 03		bcc $1851			bcc 	_Integer
.184e	4c c2 1b	jmp $1bc2			jmp 	FPSub
.1851					_Integer:
.1851	38		sec				sec
.1852	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1855	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.1858	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.185b	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.185e	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.1861	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1864	60		rts				rts
.1865					BinaryAnd:
.1865	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.1868	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.186b	90 03		bcc $1870			bcc 	_Integer
.186d	20 c2 1b	jsr $1bc2			jsr 	FPFloatToInteger
.1870					_Integer:
.1870	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1873	3d 21 06	and $0621,x			and 	xsIntLow+1,x
.1876	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1879	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.187c	3d 41 06	and $0641,x			and 	xsIntHigh+1,x
.187f	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1882	60		rts				rts
.1883					BinaryOr:
.1883	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.1886	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.1889	90 03		bcc $188e			bcc 	_Integer
.188b	20 c2 1b	jsr $1bc2			jsr 	FPFloatToInteger
.188e					_Integer:
.188e	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1891	1d 21 06	ora $0621,x			ora 	xsIntLow+1,x
.1894	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1897	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.189a	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.189d	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.18a0	60		rts				rts
.18a1					BinaryXor:
.18a1	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.18a4	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.18a7	90 03		bcc $18ac			bcc 	_Integer
.18a9	20 c2 1b	jsr $1bc2			jsr 	FPFloatToInteger
.18ac					_Integer:
.18ac	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.18af	5d 21 06	eor $0621,x			eor 	xsIntLow+1,x
.18b2	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.18b5	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.18b8	5d 41 06	eor $0641,x			eor 	xsIntHigh+1,x
.18bb	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.18be	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/multiply.asm

.18bf					Multiply16x16:
.18bf	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.18c2	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.18c5	90 03		bcc $18ca			bcc 	_Integer
.18c7	4c c2 1b	jmp $1bc2			jmp 	FPMultiply
.18ca					_Integer:
.18ca	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; 1st value to zTemp1
.18cd	85 05		sta $05				sta 	zTemp2
.18cf	bd 40 06	lda $0640,x			lda		xsIntHigh,x
.18d2	85 06		sta $06				sta 	zTemp2+1
.18d4	9e 20 06	stz $0620,x			stz 	xsIntLow,x 					; zero 1st on stack
.18d7	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.18da					_MultLoop:
.18da	46 06		lsr $06				lsr 	zTemp2+1 					; ror zTemp2 into C
.18dc	66 05		ror $05				ror 	zTemp2
.18de	90 13		bcc $18f3			bcc 	_MultNoAdd
.18e0	18		clc				clc 								; add 2nd to 1st.
.18e1	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.18e4	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.18e7	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.18ea	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.18ed	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.18f0	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.18f3					_MultNoAdd:
.18f3	1e 21 06	asl $0621,x			asl 	xsIntLow+1,x 				; shift 2nd left
.18f6	3e 41 06	rol $0641,x			rol 	xsIntHigh+1,x
.18f9	a5 05		lda $05				lda 	zTemp2	 					; until multiplier is zero
.18fb	05 06		ora $06				ora 	zTemp2+1
.18fd	d0 db		bne $18da			bne 	_MultLoop
.18ff	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/divide.asm

.1900					Divide16x16:
.1900	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.1903	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.1906	90 03		bcc $190b			bcc 	_Integer
.1908	4c c2 1b	jmp $1bc2			jmp 	FPDivide
.190b					_Integer:
.190b	20 2c 19	jsr $192c			jsr 	IntegerDivide
.190e	60		rts				rts
.190f					Modulus16x16:
.190f	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.1912	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.1915	90 03		bcc $191a			bcc 	_Integer
.1917	4c c2 1b	jmp $1bc2			jmp 	FPModulus
.191a					_Integer:
.191a	20 2c 19	jsr $192c			jsr 	IntegerDivide
.191d	a5 03		lda $03				lda 	zTemp1
.191f	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1922	a5 04		lda $04				lda 	zTemp1+1
.1924	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1927	60		rts				rts
.1928					UnsignedIntegerDivide:
.1928	64 0b		stz $0b				stz 	SignCount 					; Count of signs.
.192a	80 1e		bra $194a			bra 	DivideMain
.192c					IntegerDivide:
.192c	bd 21 06	lda $0621,x			lda 	xsIntLow+1,x 				; check for division by zero.
.192f	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.1932	d0 14		bne $1948			bne 	_BFDOkay
.1934	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>1937	44 69 76 69 73 69 6f 6e				.text 	"Division by Zero",0
>193f	20 62 79 20 5a 65 72 6f 00
.1948					_BFDOkay:
.1948	64 0b		stz $0b				stz 	SignCount 					; Count of signs.
.194a					DivideMain:
.194a	64 03		stz $03				stz 	zTemp1 						; Q/Dividend/Left in +0
.194c	64 04		stz $04				stz 	zTemp1+1 					; M/Divisor/Right in +1
.194e	5a		phy				phy 								; Y is the counter, save position
.194f	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1951					_BFDLoop:
.1951	1e 20 06	asl $0620,x			asl 	xsIntLow,x 					; shift AQ left.
.1954	3e 40 06	rol $0640,x			rol 	xsIntHigh,x
.1957	26 03		rol $03				rol 	zTemp1
.1959	26 04		rol $04				rol 	zTemp1+1
.195b	38		sec				sec
.195c	a5 03		lda $03				lda 	zTemp1+0 					; Calculate A-M on stack.
.195e	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.1961	48		pha				pha
.1962	a5 04		lda $04				lda 	zTemp1+1
.1964	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.1967	90 0f		bcc $1978			bcc 	_BFDNoAdd
.1969	85 04		sta $04				sta 	zTemp1+1
.196b	68		pla				pla
.196c	85 03		sta $03				sta 	zTemp1+0
.196e	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; set Q bit 1.
.1971	09 01		ora #$01			ora 	#1
.1973	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1976	80 01		bra $1979			bra 	_BFDNext
.1978					_BFDNoAdd:
.1978	68		pla				pla 								; Throw away the intermediate calculations
.1979					_BFDNext:
.1979	88		dey				dey
.197a	d0 d5		bne $1951			bne 	_BFDLoop
.197c	7a		ply				ply 								; restore Y
.197d	46 0b		lsr $0b				lsr 	SignCount 					; if sign count odd,
.197f	90 03		bcc $1984			bcc 	_BFDUnsigned 				; then the result is signed
.1981	20 8b 19	jsr $198b			jsr		IntegerNegate 				; negate the result
.1984					_BFDUnsigned:
.1984	60		rts				rts
.1985					CheckIntegerNegate:
.1985	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; is it -ve = MSB set ?
.1988	30 01		bmi $198b			bmi 	IntegerNegate 				; if so negate it
.198a	60		rts				rts
.198b					IntegerNegate:
.198b	e6 0b		inc $0b				inc 	SignCount 					; bump the count of signs
.198d	38		sec				sec 								; negate
.198e	a9 00		lda #$00			lda 	#0
.1990	fd 20 06	sbc $0620,x			sbc 	xsIntLow,x
.1993	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1996	a9 00		lda #$00			lda 	#0
.1998	fd 40 06	sbc $0640,x			sbc 	xsIntHigh,x
.199b	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.199e	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/icompare.asm

.199f					Compare_Equals:
.199f	18		clc				clc
.19a0	80 01		bra $19a3			bra 	CEMain
.19a2					Compare_NotEquals:
.19a2	38		sec				sec
.19a3					CEMain:
.19a3	08		php				php 								; carry set flips the result
.19a4	20 cd 19	jsr $19cd			jsr 	EqualityComparison
.19a7					CEWriteResult:
.19a7	28		plp				plp  								; get the flip flag
.19a8	90 02		bcc $19ac			bcc 	_CENoFlip
.19aa	49 ff		eor #$ff			eor 	#$FF 						; if so invert the result
.19ac					_CENoFlip:
.19ac	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; write it out
.19af	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.19b2	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; its an integer
.19b5	60		rts				rts
.19b6					Compare_GreaterEquals:
.19b6	18		clc				clc
.19b7	80 01		bra $19ba			bra 	GEMain
.19b9					Compare_Less:
.19b9	38		sec				sec
.19ba					GEMain:
.19ba	08		php				php 								; carry set flips the result
.19bb	20 f9 19	jsr $19f9			jsr 	MagnitudeComparison
.19be	80 e7		bra $19a7			bra 	CEWriteResult
.19c0					Compare_LessEquals:
.19c0	18		clc				clc
.19c1	80 01		bra $19c4			bra 	LEMain
.19c3					Compare_Greater:
.19c3	38		sec				sec
.19c4					LEMain:
.19c4	08		php				php 								; carry set flips the result
.19c5	20 27 1a	jsr $1a27			jsr 	SwapStackTop 				; swap the top two over. Not that efficient, probably doesn't matter
.19c8	20 f9 19	jsr $19f9			jsr 	MagnitudeComparison 		; so the comparison is backwards.
.19cb	80 da		bra $19a7			bra 	CEWriteResult
.19cd					EqualityComparison:
.19cd	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.19d0	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.19d3	50 06		bvc $19db			bvc 	_NumericType
.19d5	20 fe 17	jsr $17fe			jsr 	BinaryStringTypeCheck 		; check both are strings
.19d8	4c c0 12	jmp $12c0			jmp 	SyntaxError 							; and do the string handler
.19db					_NumericType:
.19db	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; see if they are compatible.
.19de	90 03		bcc $19e3			bcc 	_Integer
.19e0	4c c2 1b	jmp $1bc2			jmp 	FPEquality
.19e3					_Integer:
.19e3	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.19e6	dd 21 06	cmp $0621,x			cmp 	xsIntLow+1,x
.19e9	d0 0b		bne $19f6			bne 	_NECFail
.19eb	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.19ee	dd 41 06	cmp $0641,x			cmp 	xsIntHigh+1,x
.19f1	d0 03		bne $19f6			bne 	_NECFail
.19f3	a9 ff		lda #$ff			lda 	#$FF
.19f5	60		rts				rts
.19f6					_NECFail:
.19f6	a9 00		lda #$00			lda 	#$00
.19f8	60		rts				rts
.19f9					MagnitudeComparison:
.19f9	20 9d 17	jsr $179d			jsr 	DeReferenceBinary 			; convert references to values
.19fc	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.19ff	50 06		bvc $1a07			bvc 	_NumericType
.1a01	20 fe 17	jsr $17fe			jsr 	BinaryStringTypeCheck 		; check both are strings
.1a04	4c c0 12	jmp $12c0			jmp 	SyntaxError 							; and do the string handler
.1a07					_NumericType:
.1a07	20 e1 17	jsr $17e1			jsr 	BinaryNumberTypeCheck 		; see if they are compatible.
.1a0a	90 03		bcc $1a0f			bcc 	_Integer
.1a0c	4c c2 1b	jmp $1bc2			jmp 	FPMagnitude
.1a0f					_Integer:
.1a0f	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1a12	dd 21 06	cmp $0621,x			cmp 	xsIntLow+1,x
.1a15	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.1a18	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.1a1b	50 02		bvc $1a1f			bvc 	_MCNoOverflow
.1a1d	49 80		eor #$80			eor 	#$80
.1a1f					_MCNoOverflow:
.1a1f	30 03		bmi $1a24			bmi 	_NECFail
.1a21	a9 ff		lda #$ff			lda 	#$FF
.1a23	60		rts				rts
.1a24					_NECFail:
.1a24	a9 00		lda #$00			lda 	#$00
.1a26	60		rts				rts
.1a27					SwapStackTop:
.1a27	da		phx				phx
.1a28	5a		phy				phy
.1a29	a0 06		ldy #$06			ldy 	#6 							; swap count
.1a2b					_SSTLoop:
.1a2b	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; the first stack entry, flip it over.
.1a2e	48		pha				pha
.1a2f	bd 01 06	lda $0601,x			lda 	xsStatus+1,x
.1a32	9d 00 06	sta $0600,x			sta 	xsStatus,x
.1a35	68		pla				pla
.1a36	9d 01 06	sta $0601,x			sta 	xsStatus+1,x
.1a39	8a		txa				txa 								; go forward to the next stack chunk.
.1a3a	18		clc				clc
.1a3b	69 20		adc #$20			adc 	#stackSize
.1a3d	aa		tax				tax
.1a3e	88		dey				dey 								; do it for the whole of this stack
.1a3f	d0 ea		bne $1a2b			bne 	_SSTLoop
.1a41	7a		ply				ply
.1a42	fa		plx				plx
.1a43	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/random.asm

.1a44					RandomNumber:
.1a44	20 57 1a	jsr $1a57			jsr 	AdvanceRandomSeed 			; bytes seperately as zero problem.
.1a47	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1a4a	20 57 1a	jsr $1a57			jsr 	AdvanceRandomSeed
.1a4d	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1a50	9e 00 06	stz $0600,x			stz 	xsStatus,x
.1a53	20 93 14	jsr $1493			jsr 	SyntaxCheckRightBracket 	; check followed by )
.1a56	60		rts				rts
.1a57					AdvanceRandomSeed:
.1a57	a5 0d		lda $0d				lda 	randomSeed
.1a59	05 0e		ora $0e				ora 	randomSeed+1
.1a5b	d0 08		bne $1a65			bne 	_RH_NoInit
.1a5d	a9 7c		lda #$7c			lda 	#$7C
.1a5f	85 0d		sta $0d				sta 	randomSeed
.1a61	a9 a1		lda #$a1			lda 	#$A1
.1a63	85 0e		sta $0e				sta 	randomSeed+1
.1a65					_RH_NoInit:
.1a65	a5 0d		lda $0d				lda 	randomSeed
.1a67	4a		lsr a		        lsr		a
.1a68	26 0e		rol $0e		        rol 	randomSeed+1
.1a6a	90 02		bcc $1a6e	        bcc 	_RH_NoEor
.1a6c	49 b4		eor #$b4	        eor 	#$B4
.1a6e					_RH_NoEor:
.1a6e	85 0d		sta $0d		        sta 	randomSeed
.1a70	45 0e		eor $0e		        eor 	randomSeed+1
.1a72	60		rts		        rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/tostring.asm

.1a73					PrintYA:
.1a73	a2 00		ldx #$00			ldx 	#0 							; put on stack.
.1a75	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1a78	98		tya				tya
.1a79	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1a7c	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; tell system it is an integer.
.1a7f	a9 0a		lda #$0a			lda 	#10 						; base
.1a81	20 88 1a	jsr $1a88			jsr 	ConvertIntegerUnsigned 		; unsigned integer conversion.
.1a84	20 07 14	jsr $1407			jsr 	EXPrintString 				; print the result
.1a87	60		rts				rts
.1a88					ConvertIntegerUnsigned:
.1a88	da		phx				phx
.1a89	48		pha				pha 								; save base on stack
.1a8a	64 0c		stz $0c				stz 	convertPtr 					; reset conversion position
.1a8c	80 11		bra $1a9f			bra 	CIMain
.1a8e					ConvertIntegerSigned:
.1a8e	da		phx				phx
.1a8f	48		pha				pha 								; save base on stack.
.1a90	64 0c		stz $0c				stz 	convertPtr 					; reset conversion position
.1a92	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; is it -ve ?
.1a95	10 08		bpl $1a9f			bpl 	CIMain
.1a97	20 8b 19	jsr $198b			jsr 	IntegerNegate 				; make it positive
.1a9a	a9 2d		lda #$2d			lda 	#"-" 						; write a - sign out.
.1a9c	20 d8 1a	jsr $1ad8			jsr 	CIWriteCharacter
.1a9f					CIMain:
.1a9f	7a		ply				ply									; get base back
.1aa0	a9 ff		lda #$ff			lda 	#$FF 						; push marker on stack.
.1aa2	48		pha				pha
.1aa3	5a		phy				phy  								; push base back.
.1aa4					_CILoop:
.1aa4	68		pla				pla 								; get and save base.
.1aa5	48		pha				pha
.1aa6	9d 21 06	sta $0621,x			sta 	xsIntLow+1,x 				; put it in the next stack level and set type
.1aa9	9e 41 06	stz $0641,x			stz 	xsIntHigh+1,x
.1aac	9e 00 06	stz $0600,x			stz 	xsStatus,x
.1aaf	20 28 19	jsr $1928			jsr 	UnsignedIntegerDivide 		; divide.
.1ab2	7a		ply				ply 								; get base into Y
.1ab3	a5 03		lda $03				lda 	zTemp1 						; push the remainder on the stack.
.1ab5	48		pha				pha
.1ab6	5a		phy				phy 								; push the base back.
.1ab7	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; complete
.1aba	1d 40 06	ora $0640,x			ora 	xsIntHigh,x
.1abd	d0 e5		bne $1aa4			bne 	_CILoop
.1abf	68		pla				pla 								; throw the base
.1ac0					_CIUnpack:
.1ac0	68		pla				pla 								; pull off stack so in the right order
.1ac1	30 0f		bmi $1ad2			bmi 	_CIExit
.1ac3	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.1ac5	90 03		bcc $1aca			bcc 	_CINotAlpha
.1ac7	18		clc				clc
.1ac8	69 07		adc #$07			adc 	#7
.1aca					_CINotAlpha:
.1aca	18		clc				clc
.1acb	69 30		adc #$30			adc 	#48
.1acd	20 d8 1a	jsr $1ad8			jsr 	CIWriteCharacter 			; keep going till reach the marker
.1ad0	80 ee		bra $1ac0			bra 	_CIUnpack
.1ad2					_CIExit:
.1ad2	fa		plx				plx
.1ad3	a9 00		lda #$00			lda 	#textBuffer & $FF 			; return with pointer in YA
.1ad5	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.1ad7	60		rts				rts
.1ad8					CIWriteCharacter:
.1ad8	da		phx				phx
.1ad9	a6 0c		ldx $0c				ldx		convertPtr
.1adb	9d 00 08	sta $0800,x			sta 	textBuffer,x
.1ade	9e 01 08	stz $0801,x			stz 	textBuffer+1,x
.1ae1	fa		plx				plx
.1ae2	e6 0c		inc $0c				inc 	convertPtr
.1ae4	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/unary.asm

.1ae5					Dummy_Binary:
.1ae5					Dummy_Hex:
.1ae5	20 97 17	jsr $1797			jsr 	EvaluateTermAtX
.1ae8	60		rts				rts
.1ae9					Parenthesis:
.1ae9	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; parenthesised expression
.1aec	20 93 14	jsr $1493			jsr 	SyntaxCheckRightBracket 	; check followed by )
.1aef	60		rts				rts
.1af0					AbsoluteValue:
.1af0	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1af3	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1af6	20 dc 17	jsr $17dc			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1af9	90 03		bcc $1afe			bcc 	_Integer
.1afb	4c 05 1b	jmp $1b05			jmp 	AVFloat
.1afe					_Integer:
.1afe	20 85 19	jsr $1985			jsr 	CheckIntegerNegate 			; use absolute value in divide
.1b01	20 93 14	jsr $1493			jsr 	SyntaxCheckRightBracket
.1b04	60		rts				rts
.1b05					AVFloat:
.1b05	20 c2 1b	jsr $1bc2			jsr 	FPAbs
.1b08	20 93 14	jsr $1493			jsr 	SyntaxCheckRightBracket
.1b0b	60		rts				rts
.1b0c					SignValue:
.1b0c	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1b0f	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1b12	20 dc 17	jsr $17dc			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1b15	90 03		bcc $1b1a			bcc 	_Integer
.1b17	4c 3a 1b	jmp $1b3a			jmp 	SVFloat
.1b1a					_Integer:
.1b1a	20 93 14	jsr $1493			jsr 	SyntaxCheckRightBracket
.1b1d	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; Check zero
.1b20	1d 20 06	ora $0620,x			ora 	xsIntLow,x
.1b23	f0 05		beq $1b2a			beq 	_SVSetLH
.1b25	0a		asl a				asl 	a 							; msb into carry
.1b26	90 09		bcc $1b31			bcc 	_SVGreater0 				; if CC then it's positive and non zero
.1b28	a9 ff		lda #$ff			lda 	#$FF 						; -ve so return -1
.1b2a					_SVSetLH:
.1b2a	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1b2d	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1b30	60		rts				rts
.1b31					_SVGreater0:
.1b31	a9 01		lda #$01			lda 	#1
.1b33	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1b36	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.1b39	60		rts				rts
.1b3a					SVFloat:
.1b3a	20 c2 1b	jsr $1bc2			jsr 	FPSgn
.1b3d	20 93 14	jsr $1493			jsr 	SyntaxCheckRightBracket
.1b40	60		rts				rts
.1b41					StringLength:
.1b41	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1b44	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1b47	20 03 18	jsr $1803			jsr 	UnaryStringTypeCheck 		; check string.
.1b4a	20 93 14	jsr $1493			jsr 	SyntaxCheckRightBracket
.1b4d	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put address of string into zTemp1
.1b50	85 03		sta $03				sta 	zTemp1
.1b52	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.1b55	85 04		sta $04				sta 	zTemp1+1
.1b57	b2 03		lda ($03)			lda 	(zTemp1)					; get the length (strings are len prefixed)
.1b59	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and return it
.1b5c	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.1b5f	9e 00 06	stz $0600,x			stz 	xsStatus,x
.1b62	60		rts				rts
.1b63					PeekMemory:
.1b63	18		clc				clc
.1b64	80 01		bra $1b67			bra 	ReadMemoryMain
.1b66					DeekMemory:
.1b66	38		sec				sec
.1b67					ReadMemoryMain:
.1b67	08		php				php 								; CS read word CC read byte
.1b68	20 c9 16	jsr $16c9			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1b6b	20 a2 17	jsr $17a2			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1b6e	20 dc 17	jsr $17dc			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1b71	90 03		bcc $1b76			bcc 	_Integer
.1b73	4c e1 12	jmp $12e1			jmp 	ParameterError
.1b76					_Integer:
.1b76	20 93 14	jsr $1493			jsr 	SyntaxCheckRightBracket
.1b79	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; transfer address
.1b7c	85 03		sta $03				sta 	zTemp1
.1b7e	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.1b81	85 04		sta $04				sta 	zTemp1+1
.1b83	b2 03		lda ($03)			lda 	(zTemp1) 					; do the LSB
.1b85	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1b88	9e 40 06	stz $0640,x			stz 	xsIntHigh,x 				; zero MSB
.1b8b	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; set the type
.1b8e	28		plp				plp
.1b8f	90 09		bcc $1b9a			bcc 	_RMMPeek 					; read type
.1b91	5a		phy				phy
.1b92	a0 01		ldy #$01			ldy 	#1
.1b94	b1 03		lda ($03),y			lda 	(zTemp1),y
.1b96	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1b99	7a		ply				ply
.1b9a					_RMMPeek:
.1b9a	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: variables/variable.asm

.1b9b					VariableLookup:
.1b9b	c9 1a		cmp #$1a			cmp 	#26 						; multi character variables.
.1b9d	b0 13		bcs $1bb2			bcs 	_VLError
.1b9f	0a		asl a				asl 	a 							; multiply by 5, do not move for float
.1ba0	0a		asl a				asl 	a
.1ba1	71 00		adc ($00),y			adc 	(codePtr),y
.1ba3	c8		iny				iny 								; skip over variable token
.1ba4	9d 20 06	sta $0620,x			sta 	xsAddrLow,x
.1ba7	a9 07		lda #$07			lda 	#variables >> 8
.1ba9	9d 40 06	sta $0640,x			sta 	xsAddrHigh,x
.1bac	a9 01		lda #$01			lda 	#$01 						; integer reference.
.1bae	9d 00 06	sta $0600,x			sta 	xsStatus,x
.1bb1	60		rts				rts
.1bb2					_VLError:
.1bb2	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>1bb5	42 61 64 20 56 61 72 69				.text 	"Bad Variable",0
>1bbd	61 62 6c 65 00

;******  Return to file: files.asm


;******  Processing file: expression/float/floatdummy.asm

.1bc2					FPAdd:
.1bc2					FPSub:
.1bc2					FPMultiply:
.1bc2					FPDivide:
.1bc2					FPModulus:
.1bc2					FPAbs:
.1bc2					FPSgn:
.1bc2					FPFloatToInteger:
.1bc2					FPIntegerToFloat:
.1bc2					FPEquality:
.1bc2					FPMagnitude:
.1bc2	20 ee 12	jsr $12ee			jsr 	ErrorHandler
>1bc5	46 6c 6f 61 74 20 4e 6f				.text 	"Float Not Implemented",0
>1bcd	74 20 49 6d 70 6c 65 6d 65 6e 74 65 64 00

;******  Return to file: files.asm


;******  Return to file: basic.asm

.1bdb					ColdStart:
.1bdb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1bdd	9a		txs				txs
.1bde	20 23 13	jsr $1323			jsr 	ExternInitialise
.1be1	a9 ee		lda #$ee			lda 	#BootMessage & $FF
.1be3	a0 1b		ldy #$1b			ldy 	#BootMessage >> 8
.1be5	20 07 14	jsr $1407			jsr 	EXPrintString
.1be8	4c 7c 16	jmp $167c			jmp 	Command_Run
.1beb					WarmStart:
.1beb	4c ff ff	jmp $ffff			jmp 	$FFFF
.1bee					BootMessage:
>1bee	2a 2a 2a 2a 20 43 6f 6d				.text 	"**** Commander X16 Basic ****",13,13
>1bf6	6d 61 6e 64 65 72 20 58 31 36 20 42 61 73 69 63
>1c06	20 2a 2a 2a 2a 0d 0d
>1c0d	35 31 32 4b 20 48 69 67				.text 	"512K High RAM.",13,13
>1c15	68 20 52 41 4d 2e 0d 0d
>1c1d	50 72 65 2d 41 6c 70 68				.text 	"Pre-Alpha. "
>1c25	61 2e 20

;******  Processing file: generated/buildinfo.inc

>1c28	42 75 69 6c 64 3a 32 33			.text	"Build:230 (09-Feb-20 06:45)"
>1c30	30 20 28 30 39 2d 46 65 62 2d 32 30 20 30 36 3a
>1c40	34 35 29

;******  Return to file: basic.asm

>1c43	0d 0d 00					.byte 	13,13,0
.1c46					BasicProgram:

;******  End of listing
