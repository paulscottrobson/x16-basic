
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o basic_nocode.prg -L basic.lst -l basic.lbl basic.asm
; Sat Feb 08 14:52:35 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: code/data.asm

.0000					codePtr:
>0000							.word 	?
.0002					zTemp1:
>0002							.word 	?
.0004					zTemp2:
>0004							.word 	?
.0006					zTemp3:
>0006							.word 	?
.0008					zTemp4:
>0008							.word 	?
.000a					signCount:
>000a							.byte 	?
.000b					convertPtr:
>000b							.byte 	?
=$600					xsStatus = $600								; expression stack (must all fit in one page)
=$20					stackSize = $20 							; stack elements allowed (max 256/6)
=1568					xsAddrLow = xsStatus+stackSize 				; these values are shared depending on type.
=1600					xsAddrHigh = xsStatus+stackSize*2
=1568					xsIntLow = xsAddrLow
=1600					xsIntHigh = xsAddrHigh
=1568					xsMantissa3 = xsAddrLow
=1600					xsMantissa2 = xsAddrHigh
=1632					xsMantissa1 = xsStatus+stackSize*3
=1664					xsMantissa0 = xsStatus+stackSize*4
=1696					xsExponent = xsStatus+stackSize*5
=$700					variables = $700							; 26 variables A-Z. Must be on a page boundary.
=$800					textBuffer = $800							; text buffer for input command lines.
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: basic.asm


;******  Processing file: code/macros.asm


;******  Return to file: basic.asm

.1000	4c 1f 19	jmp $191f			jmp 	ColdStart

;******  Processing file: files.asm

.1003					TokenTextTable:

;******  Processing file: generated/tokentext.inc

>1003	05 28 45 4f 4c a9			.byte	$05,$28,$45,$4f,$4c,$a9                  ; $80 : (eol)
>1009	01 a9					.byte	$01,$a9                                  ; $81 : )
>100b	01 ba					.byte	$01,$ba                                  ; $82 : :
>100d	01 ac					.byte	$01,$ac                                  ; $83 : ,
>100f	01 bb					.byte	$01,$bb                                  ; $84 : ;
>1011	01 a3					.byte	$01,$a3                                  ; $85 : #
>1013	03 41 4e c4				.byte	$03,$41,$4e,$c4                          ; $86 : and
>1017	02 4f d2				.byte	$02,$4f,$d2                              ; $87 : or
>101a	03 58 4f d2				.byte	$03,$58,$4f,$d2                          ; $88 : xor
>101e	01 be					.byte	$01,$be                                  ; $89 : >
>1020	02 3e bd				.byte	$02,$3e,$bd                              ; $8a : >=
>1023	01 bc					.byte	$01,$bc                                  ; $8b : <
>1025	02 3c bd				.byte	$02,$3c,$bd                              ; $8c : <=
>1028	01 bd					.byte	$01,$bd                                  ; $8d : =
>102a	02 3c be				.byte	$02,$3c,$be                              ; $8e : <>
>102d	01 ab					.byte	$01,$ab                                  ; $8f : +
>102f	01 ad					.byte	$01,$ad                                  ; $90 : -
>1031	01 aa					.byte	$01,$aa                                  ; $91 : *
>1033	01 af					.byte	$01,$af                                  ; $92 : /
>1035	03 4d 4f c4				.byte	$03,$4d,$4f,$c4                          ; $93 : mod
>1039	04 4c 45 4e a8				.byte	$04,$4c,$45,$4e,$a8                      ; $94 : len(
>103e	04 52 4e 44 a8				.byte	$04,$52,$4e,$44,$a8                      ; $95 : rnd(
>1043	04 41 53 43 a8				.byte	$04,$41,$53,$43,$a8                      ; $96 : asc(
>1048	05 43 48 52 24 a8			.byte	$05,$43,$48,$52,$24,$a8                  ; $97 : chr$(
>104e	04 56 41 4c a8				.byte	$04,$56,$41,$4c,$a8                      ; $98 : val(
>1053	05 53 54 52 24 a8			.byte	$05,$53,$54,$52,$24,$a8                  ; $99 : str$(
>1059	04 53 50 43 a8				.byte	$04,$53,$50,$43,$a8                      ; $9a : spc(
>105e	06 4c 45 46 54 24 a8			.byte	$06,$4c,$45,$46,$54,$24,$a8              ; $9b : left$(
>1065	05 4d 49 44 24 a8			.byte	$05,$4d,$49,$44,$24,$a8                  ; $9c : mid$(
>106b	07 52 49 47 48 54 24 a8			.byte	$07,$52,$49,$47,$48,$54,$24,$a8          ; $9d : right$(
>1073	04 41 42 53 a8				.byte	$04,$41,$42,$53,$a8                      ; $9e : abs(
>1078	04 53 47 4e a8				.byte	$04,$53,$47,$4e,$a8                      ; $9f : sgn(
>107d	04 49 4e 54 a8				.byte	$04,$49,$4e,$54,$a8                      ; $a0 : int(
>1082	05 44 45 45 4b a8			.byte	$05,$44,$45,$45,$4b,$a8                  ; $a1 : deek(
>1088	05 50 45 45 4b a8			.byte	$05,$50,$45,$45,$4b,$a8                  ; $a2 : peek(
>108e	06 56 50 45 45 4b a8			.byte	$06,$56,$50,$45,$45,$4b,$a8              ; $a3 : vpeek(
>1095	01 a8					.byte	$01,$a8                                  ; $a4 : (
>1097	01 a5					.byte	$01,$a5                                  ; $a5 : %
>1099	01 a4					.byte	$01,$a4                                  ; $a6 : $
>109b	02 49 c6				.byte	$02,$49,$c6                              ; $a7 : if
>109e	06 52 45 50 45 41 d4			.byte	$06,$52,$45,$50,$45,$41,$d4              ; $a8 : repeat
>10a5	03 46 4f d2				.byte	$03,$46,$4f,$d2                          ; $a9 : for
>10a9	05 57 48 49 4c c5			.byte	$05,$57,$48,$49,$4c,$c5                  ; $aa : while
>10af	04 43 41 53 c5				.byte	$04,$43,$41,$53,$c5                      ; $ab : case
>10b4	04 54 48 45 ce				.byte	$04,$54,$48,$45,$ce                      ; $ac : then
>10b9	05 45 4e 44 49 c6			.byte	$05,$45,$4e,$44,$49,$c6                  ; $ad : endif
>10bf	05 55 4e 54 49 cc			.byte	$05,$55,$4e,$54,$49,$cc                  ; $ae : until
>10c5	04 4e 45 58 d4				.byte	$04,$4e,$45,$58,$d4                      ; $af : next
>10ca	08 45 4e 44 57 48 49 4c			.byte	$08,$45,$4e,$44,$57,$48,$49,$4c,$c5      ; $b0 : endwhile
>10d2	c5
>10d3	07 45 4e 44 43 41 53 c5			.byte	$07,$45,$4e,$44,$43,$41,$53,$c5          ; $b1 : endcase
>10db	02 54 cf				.byte	$02,$54,$cf                              ; $b2 : to
>10de	04 53 54 45 d0				.byte	$04,$53,$54,$45,$d0                      ; $b3 : step
>10e3	04 50 52 4f c3				.byte	$04,$50,$52,$4f,$c3                      ; $b4 : proc
>10e8	07 45 4e 44 50 52 4f c3			.byte	$07,$45,$4e,$44,$50,$52,$4f,$c3          ; $b5 : endproc
>10f0	04 43 41 4c cc				.byte	$04,$43,$41,$4c,$cc                      ; $b6 : call
>10f5	05 4c 4f 43 41 cc			.byte	$05,$4c,$4f,$43,$41,$cc                  ; $b7 : local
>10fb	03 52 55 ce				.byte	$03,$52,$55,$ce                          ; $b8 : run
>10ff	04 53 54 4f d0				.byte	$04,$53,$54,$4f,$d0                      ; $b9 : stop
>1104	03 45 4e c4				.byte	$03,$45,$4e,$c4                          ; $ba : end
>1108	05 50 52 49 4e d4			.byte	$05,$50,$52,$49,$4e,$d4                  ; $bb : print
>110e	05 49 4e 50 55 d4			.byte	$05,$49,$4e,$50,$55,$d4                  ; $bc : input
>1114	04 57 48 45 ce				.byte	$04,$57,$48,$45,$ce                      ; $bd : when
>1119	07 44 45 46 41 55 4c d4			.byte	$07,$44,$45,$46,$41,$55,$4c,$d4          ; $be : default
>1121	03 4c 45 d4				.byte	$03,$4c,$45,$d4                          ; $bf : let
>1125	06 4f 50 54 49 4f ce			.byte	$06,$4f,$50,$54,$49,$4f,$ce              ; $c0 : option
>112c	04 4c 49 53 d4				.byte	$04,$4c,$49,$53,$d4                      ; $c1 : list
>1131	04 4c 4f 41 c4				.byte	$04,$4c,$4f,$41,$c4                      ; $c2 : load
>1136	04 53 41 56 c5				.byte	$04,$53,$41,$56,$c5                      ; $c3 : save
>113b	03 4e 45 d7				.byte	$03,$4e,$45,$d7                          ; $c4 : new
>113f	03 4f 4c c4				.byte	$03,$4f,$4c,$c4                          ; $c5 : old
>1143	04 50 4f 4b c5				.byte	$04,$50,$4f,$4b,$c5                      ; $c6 : poke
>1148	04 44 4f 4b c5				.byte	$04,$44,$4f,$4b,$c5                      ; $c7 : doke
>114d	05 56 50 4f 4b c5			.byte	$05,$56,$50,$4f,$4b,$c5                  ; $c8 : vpoke
>1153	03 52 45 cd				.byte	$03,$52,$45,$cd                          ; $c9 : rem
>1157	04 47 4f 54 cf				.byte	$04,$47,$4f,$54,$cf                      ; $ca : goto
>115c	05 47 4f 53 55 c2			.byte	$05,$47,$4f,$53,$55,$c2                  ; $cb : gosub
>1162	03 53 59 d3				.byte	$03,$53,$59,$d3                          ; $cc : sys
>1166	06 52 45 54 55 52 ce			.byte	$06,$52,$45,$54,$55,$52,$ce              ; $cd : return
>116d	06 41 53 53 45 52 d4			.byte	$06,$41,$53,$53,$45,$52,$d4              ; $ce : assert
>1174	02 4f ce				.byte	$02,$4f,$ce                              ; $cf : on
>1177	04 4f 50 45 ce				.byte	$04,$4f,$50,$45,$ce                      ; $d0 : open
>117c	05 43 4c 4f 53 c5			.byte	$05,$43,$4c,$4f,$53,$c5                  ; $d1 : close
>1182	03 44 49 d2				.byte	$03,$44,$49,$d2                          ; $d2 : dir
>1186	03 44 49 cd				.byte	$03,$44,$49,$cd                          ; $d3 : dim
>118a	04 52 45 41 c4				.byte	$04,$52,$45,$41,$c4                      ; $d4 : read
>118f	04 44 41 54 c1				.byte	$04,$44,$41,$54,$c1                      ; $d5 : data
>1194	07 52 45 53 54 4f 52 c5			.byte	$07,$52,$45,$53,$54,$4f,$52,$c5          ; $d6 : restore
>119c	00					.byte	$00

;******  Return to file: files.asm

.119d					TokenControlByteTable:

;******  Processing file: generated/tokencbyte.inc

>119d	00					.byte	$00		; $80 : (eol)
>119e	00					.byte	$00		; $81 : )
>119f	00					.byte	$00		; $82 : :
>11a0	00					.byte	$00		; $83 : ,
>11a1	00					.byte	$00		; $84 : ;
>11a2	00					.byte	$00		; $85 : #
>11a3	11					.byte	$11		; $86 : and
>11a4	11					.byte	$11		; $87 : or
>11a5	11					.byte	$11		; $88 : xor
>11a6	12					.byte	$12		; $89 : >
>11a7	12					.byte	$12		; $8a : >=
>11a8	12					.byte	$12		; $8b : <
>11a9	12					.byte	$12		; $8c : <=
>11aa	12					.byte	$12		; $8d : =
>11ab	12					.byte	$12		; $8e : <>
>11ac	13					.byte	$13		; $8f : +
>11ad	13					.byte	$13		; $90 : -
>11ae	14					.byte	$14		; $91 : *
>11af	14					.byte	$14		; $92 : /
>11b0	14					.byte	$14		; $93 : mod
>11b1	40					.byte	$40		; $94 : len(
>11b2	40					.byte	$40		; $95 : rnd(
>11b3	40					.byte	$40		; $96 : asc(
>11b4	40					.byte	$40		; $97 : chr$(
>11b5	40					.byte	$40		; $98 : val(
>11b6	40					.byte	$40		; $99 : str$(
>11b7	40					.byte	$40		; $9a : spc(
>11b8	40					.byte	$40		; $9b : left$(
>11b9	40					.byte	$40		; $9c : mid$(
>11ba	40					.byte	$40		; $9d : right$(
>11bb	40					.byte	$40		; $9e : abs(
>11bc	40					.byte	$40		; $9f : sgn(
>11bd	40					.byte	$40		; $a0 : int(
>11be	40					.byte	$40		; $a1 : deek(
>11bf	40					.byte	$40		; $a2 : peek(
>11c0	40					.byte	$40		; $a3 : vpeek(
>11c1	40					.byte	$40		; $a4 : (
>11c2	40					.byte	$40		; $a5 : %
>11c3	40					.byte	$40		; $a6 : $
>11c4	82					.byte	$82		; $a7 : if
>11c5	82					.byte	$82		; $a8 : repeat
>11c6	82					.byte	$82		; $a9 : for
>11c7	82					.byte	$82		; $aa : while
>11c8	82					.byte	$82		; $ab : case
>11c9	80					.byte	$80		; $ac : then
>11ca	80					.byte	$80		; $ad : endif
>11cb	80					.byte	$80		; $ae : until
>11cc	80					.byte	$80		; $af : next
>11cd	80					.byte	$80		; $b0 : endwhile
>11ce	80					.byte	$80		; $b1 : endcase
>11cf	81					.byte	$81		; $b2 : to
>11d0	81					.byte	$81		; $b3 : step
>11d1	81					.byte	$81		; $b4 : proc
>11d2	81					.byte	$81		; $b5 : endproc
>11d3	81					.byte	$81		; $b6 : call
>11d4	81					.byte	$81		; $b7 : local
>11d5	81					.byte	$81		; $b8 : run
>11d6	81					.byte	$81		; $b9 : stop
>11d7	81					.byte	$81		; $ba : end
>11d8	81					.byte	$81		; $bb : print
>11d9	81					.byte	$81		; $bc : input
>11da	81					.byte	$81		; $bd : when
>11db	81					.byte	$81		; $be : default
>11dc	81					.byte	$81		; $bf : let
>11dd	81					.byte	$81		; $c0 : option
>11de	81					.byte	$81		; $c1 : list
>11df	81					.byte	$81		; $c2 : load
>11e0	81					.byte	$81		; $c3 : save
>11e1	81					.byte	$81		; $c4 : new
>11e2	81					.byte	$81		; $c5 : old
>11e3	81					.byte	$81		; $c6 : poke
>11e4	81					.byte	$81		; $c7 : doke
>11e5	81					.byte	$81		; $c8 : vpoke
>11e6	81					.byte	$81		; $c9 : rem
>11e7	81					.byte	$81		; $ca : goto
>11e8	81					.byte	$81		; $cb : gosub
>11e9	81					.byte	$81		; $cc : sys
>11ea	81					.byte	$81		; $cd : return
>11eb	81					.byte	$81		; $ce : assert
>11ec	81					.byte	$81		; $cf : on
>11ed	81					.byte	$81		; $d0 : open
>11ee	81					.byte	$81		; $d1 : close
>11ef	81					.byte	$81		; $d2 : dir
>11f0	81					.byte	$81		; $d3 : dim
>11f1	81					.byte	$81		; $d4 : read
>11f2	81					.byte	$81		; $d5 : data
>11f3	81					.byte	$81		; $d6 : restore

;******  Return to file: files.asm

>11f4							.align 	2 				; defense against old 6502 bug may be present.
.11f4					TokenVectors:

;******  Processing file: generated/tokenvectors.inc

>11f4	a2 12					.word	SyntaxError             		; $80 : (eol)
>11f6	a2 12					.word	SyntaxError             		; $81 : )
>11f8	a2 12					.word	SyntaxError             		; $82 : :
>11fa	a2 12					.word	SyntaxError             		; $83 : ,
>11fc	a2 12					.word	SyntaxError             		; $84 : ;
>11fe	a2 12					.word	SyntaxError             		; $85 : #
>1200	16 16					.word	BinaryAnd               		; $86 : and
>1202	34 16					.word	BinaryOr                		; $87 : or
>1204	52 16					.word	BinaryXor               		; $88 : xor
>1206	74 17					.word	Compare_Greater         		; $89 : >
>1208	67 17					.word	Compare_GreaterEquals   		; $8a : >=
>120a	6a 17					.word	Compare_Less            		; $8b : <
>120c	71 17					.word	Compare_LessEquals      		; $8c : <=
>120e	50 17					.word	Compare_Equals          		; $8d : =
>1210	53 17					.word	Compare_NotEquals       		; $8e : <>
>1212	d0 15					.word	BinaryAdd               		; $8f : +
>1214	f7 15					.word	BinarySub               		; $90 : -
>1216	70 16					.word	Multiply16x16           		; $91 : *
>1218	b1 16					.word	Divide16x16             		; $92 : /
>121a	c0 16					.word	Modulus16x16            		; $93 : mod
>121c	bd 18					.word	StringLength            		; $94 : len(
>121e	a2 12					.word	SyntaxError             		; $95 : rnd(
>1220	a2 12					.word	SyntaxError             		; $96 : asc(
>1222	a2 12					.word	SyntaxError             		; $97 : chr$(
>1224	a2 12					.word	SyntaxError             		; $98 : val(
>1226	a2 12					.word	SyntaxError             		; $99 : str$(
>1228	a2 12					.word	SyntaxError             		; $9a : spc(
>122a	a2 12					.word	SyntaxError             		; $9b : left$(
>122c	a2 12					.word	SyntaxError             		; $9c : mid$(
>122e	a2 12					.word	SyntaxError             		; $9d : right$(
>1230	6c 18					.word	AbsoluteValue           		; $9e : abs(
>1232	88 18					.word	SignValue               		; $9f : sgn(
>1234	a2 12					.word	SyntaxError             		; $a0 : int(
>1236	a2 12					.word	SyntaxError             		; $a1 : deek(
>1238	a2 12					.word	SyntaxError             		; $a2 : peek(
>123a	a2 12					.word	SyntaxError             		; $a3 : vpeek(
>123c	65 18					.word	Parenthesis             		; $a4 : (
>123e	61 18					.word	Dummy_Binary            		; $a5 : %
>1240	61 18					.word	Dummy_Hex               		; $a6 : $
>1242	a2 12					.word	SyntaxError             		; $a7 : if
>1244	a2 12					.word	SyntaxError             		; $a8 : repeat
>1246	a2 12					.word	SyntaxError             		; $a9 : for
>1248	a2 12					.word	SyntaxError             		; $aa : while
>124a	a2 12					.word	SyntaxError             		; $ab : case
>124c	a2 12					.word	SyntaxError             		; $ac : then
>124e	a2 12					.word	SyntaxError             		; $ad : endif
>1250	a2 12					.word	SyntaxError             		; $ae : until
>1252	a2 12					.word	SyntaxError             		; $af : next
>1254	a2 12					.word	SyntaxError             		; $b0 : endwhile
>1256	a2 12					.word	SyntaxError             		; $b1 : endcase
>1258	a2 12					.word	SyntaxError             		; $b2 : to
>125a	a2 12					.word	SyntaxError             		; $b3 : step
>125c	a2 12					.word	SyntaxError             		; $b4 : proc
>125e	a2 12					.word	SyntaxError             		; $b5 : endproc
>1260	a2 12					.word	SyntaxError             		; $b6 : call
>1262	a2 12					.word	SyntaxError             		; $b7 : local
>1264	35 14					.word	Command_RUN             		; $b8 : run
>1266	73 14					.word	Command_STOP            		; $b9 : stop
>1268	70 14					.word	Command_END             		; $ba : end
>126a	a2 12					.word	SyntaxError             		; $bb : print
>126c	a2 12					.word	SyntaxError             		; $bc : input
>126e	a2 12					.word	SyntaxError             		; $bd : when
>1270	a2 12					.word	SyntaxError             		; $be : default
>1272	a2 12					.word	SyntaxError             		; $bf : let
>1274	a2 12					.word	SyntaxError             		; $c0 : option
>1276	a2 12					.word	SyntaxError             		; $c1 : list
>1278	a2 12					.word	SyntaxError             		; $c2 : load
>127a	a2 12					.word	SyntaxError             		; $c3 : save
>127c	a2 12					.word	SyntaxError             		; $c4 : new
>127e	a2 12					.word	SyntaxError             		; $c5 : old
>1280	a2 12					.word	SyntaxError             		; $c6 : poke
>1282	a2 12					.word	SyntaxError             		; $c7 : doke
>1284	a2 12					.word	SyntaxError             		; $c8 : vpoke
>1286	a2 12					.word	SyntaxError             		; $c9 : rem
>1288	a2 12					.word	SyntaxError             		; $ca : goto
>128a	a2 12					.word	SyntaxError             		; $cb : gosub
>128c	a2 12					.word	SyntaxError             		; $cc : sys
>128e	a2 12					.word	SyntaxError             		; $cd : return
>1290	12 14					.word	Command_Assert          		; $ce : assert
>1292	a2 12					.word	SyntaxError             		; $cf : on
>1294	a2 12					.word	SyntaxError             		; $d0 : open
>1296	a2 12					.word	SyntaxError             		; $d1 : close
>1298	a2 12					.word	SyntaxError             		; $d2 : dir
>129a	a2 12					.word	SyntaxError             		; $d3 : dim
>129c	a2 12					.word	SyntaxError             		; $d4 : read
>129e	a2 12					.word	SyntaxError             		; $d5 : data
>12a0	a2 12					.word	SyntaxError             		; $d6 : restore

;******  Return to file: files.asm


;******  Processing file: generated/tokenconst.inc

=$d7					TOK_LAST_TOKEN = $d7
=$80					TOK_LPARENEOLRPAREN = $80
=$81					TOK_RPAREN = $81
=$82					TOK_COLON = $82
=$83					TOK_COMMA = $83
=$84					TOK_SEMICOLON = $84
=$85					TOK_HASH = $85
=$86					TOK_AND = $86
=$87					TOK_OR = $87
=$88					TOK_XOR = $88
=$89					TOK_GREATER = $89
=$8a					TOK_GREATEREQUAL = $8a
=$8b					TOK_LESS = $8b
=$8c					TOK_LESSEQUAL = $8c
=$8d					TOK_EQUAL = $8d
=$8e					TOK_LESSGREATER = $8e
=$8f					TOK_PLUS = $8f
=$90					TOK_MINUS = $90
=$91					TOK_STAR = $91
=$92					TOK_SLASH = $92
=$93					TOK_MOD = $93
=$94					TOK_LENLPAREN = $94
=$95					TOK_RNDLPAREN = $95
=$96					TOK_ASCLPAREN = $96
=$97					TOK_CHRDOLLARLPAREN = $97
=$98					TOK_VALLPAREN = $98
=$99					TOK_STRDOLLARLPAREN = $99
=$9a					TOK_SPCLPAREN = $9a
=$9b					TOK_LEFTDOLLARLPAREN = $9b
=$9c					TOK_MIDDOLLARLPAREN = $9c
=$9d					TOK_RIGHTDOLLARLPAREN = $9d
=$9e					TOK_ABSLPAREN = $9e
=$9f					TOK_SGNLPAREN = $9f
=$a0					TOK_INTLPAREN = $a0
=$a1					TOK_DEEKLPAREN = $a1
=$a2					TOK_PEEKLPAREN = $a2
=$a3					TOK_VPEEKLPAREN = $a3
=$a4					TOK_LPAREN = $a4
=$a5					TOK_PERCENT = $a5
=$a6					TOK_DOLLAR = $a6
=$a7					TOK_IF = $a7
=$a8					TOK_REPEAT = $a8
=$a9					TOK_FOR = $a9
=$aa					TOK_WHILE = $aa
=$ab					TOK_CASE = $ab
=$ac					TOK_THEN = $ac
=$ad					TOK_ENDIF = $ad
=$ae					TOK_UNTIL = $ae
=$af					TOK_NEXT = $af
=$b0					TOK_ENDWHILE = $b0
=$b1					TOK_ENDCASE = $b1
=$b2					TOK_TO = $b2
=$b3					TOK_STEP = $b3
=$b4					TOK_PROC = $b4
=$b5					TOK_ENDPROC = $b5
=$b6					TOK_CALL = $b6
=$b7					TOK_LOCAL = $b7
=$b8					TOK_RUN = $b8
=$b9					TOK_STOP = $b9
=$ba					TOK_END = $ba
=$bb					TOK_PRINT = $bb
=$bc					TOK_INPUT = $bc
=$bd					TOK_WHEN = $bd
=$be					TOK_DEFAULT = $be
=$bf					TOK_LET = $bf
=$c0					TOK_OPTION = $c0
=$c1					TOK_LIST = $c1
=$c2					TOK_LOAD = $c2
=$c3					TOK_SAVE = $c3
=$c4					TOK_NEW = $c4
=$c5					TOK_OLD = $c5
=$c6					TOK_POKE = $c6
=$c7					TOK_DOKE = $c7
=$c8					TOK_VPOKE = $c8
=$c9					TOK_REM = $c9
=$ca					TOK_GOTO = $ca
=$cb					TOK_GOSUB = $cb
=$cc					TOK_SYS = $cc
=$cd					TOK_RETURN = $cd
=$ce					TOK_ASSERT = $ce
=$cf					TOK_ON = $cf
=$d0					TOK_OPEN = $d0
=$d1					TOK_CLOSE = $d1
=$d2					TOK_DIR = $d2
=$d3					TOK_DIM = $d3
=$d4					TOK_READ = $d4
=$d5					TOK_DATA = $d5
=$d6					TOK_RESTORE = $d6

;******  Return to file: files.asm


;******  Processing file: code/error.asm

.12a2					SyntaxError:
.12a2	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>12a5	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>12ad	72 72 6f 72 00
.12b2					ErrorHandler:
.12b2	68		pla				pla 								; get message address
.12b3	7a		ply				ply
.12b4	1a		inc a				inc 	a
.12b5	d0 01		bne $12b8			bne 	_EHNoCarry
.12b7	c8		iny				iny
.12b8					_EHNoCarry:
.12b8	20 da 13	jsr $13da			jsr 	EXPrintString
.12bb	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.12bd	b1 00		lda ($00),y			lda 	(codePtr),y
.12bf	c8		iny				iny
.12c0	11 00		ora ($00),y			ora 	(codePtr),y
.12c2	f0 14		beq $12d8			beq 	_EHNoLine
.12c4	a9 e2		lda #$e2			lda 	#_EHMsg2 & $FF 				; print " at "
.12c6	a0 12		ldy #$12			ldy 	#_EHMsg2 >> 8
.12c8	20 da 13	jsr $13da			jsr 	EXPrintString
.12cb	a0 02		ldy #$02			ldy 	#2 							; print line number
.12cd	b1 00		lda ($00),y			lda 	(codePtr),y
.12cf	48		pha				pha
.12d0	88		dey				dey
.12d1	b1 00		lda ($00),y			lda 	(codePtr),y
.12d3	7a		ply				ply
.12d4	18		clc				clc
.12d5	20 ef 17	jsr $17ef			jsr 	PrintYA
.12d8					_EHNoLine:
.12d8	a9 0d		lda #$0d			lda 	#13
.12da	20 13 13	jsr $1313			jsr 	ExternPrint
.12dd	80 fe		bra $12dd	_h1:	bra 	_h1
.12df	4c 30 19	jmp $1930			jmp 	WarmStart
.12e2					_EHMsg2:
>12e2	20 61 74 20 00					.text 	" at ",0

;******  Return to file: files.asm


;******  Processing file: code/extern.asm

.12e7					ExternInitialise:
.12e7	a9 90		lda #$90			lda 	#144 						; set colour
.12e9	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.12ec	a9 01		lda #$01			lda 	#$01
.12ee	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.12f1	a9 0e		lda #$0e			lda 	#14							; lower case
.12f3	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.12f6	a9 93		lda #$93			lda 	#147 						; clear screen
.12f8	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.12fb	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.12fd	4c 1f 13	jmp $131f			jmp 	ExternColour
.1300					ExternCheckBreak:
.1300	da		phx				phx 								; make sure we keep XY
.1301	5a		phy				phy
.1302	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.1305	f0 03		beq $130a			beq		_ECBExit 					; stopped
.1307	7a		ply				ply 								; restore and exit.
.1308	fa		plx				plx
.1309	60		rts				rts
.130a					_ECBExit:
.130a	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>130d	42 72 65 61 6b 00				.text 	"Break",0
.1313					ExternPrint:
.1313	48		pha				pha
.1314	da		phx				phx
.1315	5a		phy				phy
.1316	29 7f		and #$7f			and 	#$7F
.1318	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.131b	7a		ply				ply
.131c	fa		plx				plx
.131d	68		pla				pla
.131e	60		rts				rts
.131f					ExternColour:
.131f	48		pha				pha
.1320	da		phx				phx
.1321	48		pha				pha
.1322	29 08		and #$08			and 	#8
.1324	0a		asl a				asl 	a
.1325	0a		asl a				asl 	a
.1326	0a		asl a				asl 	a
.1327	0a		asl a				asl 	a
.1328	49 92		eor #$92			eor 	#$92
.132a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.132d	68		pla				pla
.132e	29 07		and #$07			and 	#7
.1330	aa		tax				tax
.1331	bd 3a 13	lda $133a,x			lda 	_ECTable,x
.1334	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1337	fa		plx				plx
.1338	68		pla				pla
.1339	60		rts				rts
.133a					_ECTable:
>133a	90						.byte 	144
>133b	1c						.byte 	28
>133c	1e						.byte 	30
>133d	9e						.byte 	158
>133e	1f						.byte 	31
>133f	9c						.byte 	156
>1340	9f						.byte 	159
>1341	05						.byte 	5
.1342					ExternInput:
.1342	a9 00		lda #$00			lda 	#(textBuffer & $FF)
.1344	85 06		sta $06				sta 	zTemp3
.1346	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1348	85 07		sta $07				sta 	zTemp3+1
.134a	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.134d	c9 0d		cmp #$0d			cmp 	#13
.134f	f0 0c		beq $135d			beq 	_EIExit
.1351	29 7f		and #$7f			and 	#$7F
.1353	92 06		sta ($06)			sta 	(zTemp3)
.1355	e6 06		inc $06				inc 	zTemp3
.1357	d0 f1		bne $134a			bne 	_EIRead
.1359	e6 07		inc $07				inc 	zTemp3+1
.135b	80 ed		bra $134a			bra 	_EIRead
.135d	a9 00		lda #$00	_EIExit:lda 	#0
.135f	92 06		sta ($06)			sta 	(zTemp3)
.1361	a9 0d		lda #$0d			lda 	#13
.1363	20 13 13	jsr $1313			jsr 	ExternPrint
.1366	60		rts				rts
.1367					ExternSave:
.1367	da		phx				phx
.1368	5a		phy				phy
.1369	85 04		sta $04				sta 	zTemp2 						; save start
.136b	84 05		sty $05				sty 	zTemp2+1
.136d	20 cf 13	jsr $13cf			jsr 	EXGetLength 				; get length of file into A
.1370	a6 06		ldx $06				ldx 	zTemp3
.1372	a4 07		ldy $07				ldy 	zTemp3+1
.1374	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.1377	a9 01		lda #$01			lda 	#1
.1379	a2 08		ldx #$08			ldx 	#8	 						; device #8
.137b	a0 00		ldy #$00			ldy 	#0
.137d	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.1380	a6 02		ldx $02				ldx 	zTemp1 						; end address
.1382	a4 03		ldy $03				ldy 	zTemp1+1
.1384	a9 04		lda #$04			lda 	#zTemp2
.1386	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.1389	b0 03		bcs $138e			bcs 	_ESSave
.138b	7a		ply				ply
.138c	fa		plx				plx
.138d	60		rts				rts
.138e					_ESSave:
.138e	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>1391	4c 6f 61 64 20 46 61 69				.text 	"Load Failed",0
>1399	6c 65 64 00
.139d					ExternLoad:
.139d	da		phx				phx 								; save XY
.139e	5a		phy				phy
.139f	48		pha				pha 								; save target
.13a0	5a		phy				phy
.13a1	20 cf 13	jsr $13cf			jsr 	EXGetLength 				; get length of file into A
.13a4	a6 06		ldx $06				ldx 	zTemp3
.13a6	a4 07		ldy $07				ldy 	zTemp3+1
.13a8	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.13ab	a9 01		lda #$01			lda 	#1
.13ad	a2 08		ldx #$08			ldx 	#8	 						; device #8
.13af	a0 00		ldy #$00			ldy 	#0
.13b1	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.13b4	7a		ply				ply 								; restore target to YX and call load
.13b5	fa		plx				plx
.13b6	a9 00		lda #$00			lda 	#0 							; load command
.13b8	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.13bb	b0 03		bcs $13c0			bcs 	_ESLoad
.13bd	7a		ply				ply
.13be	fa		plx				plx
.13bf	60		rts				rts
.13c0					_ESLoad:
.13c0	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>13c3	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>13cb	4c 45 44 00
.13cf					EXGetLength:
.13cf	5a		phy				phy
.13d0	a0 ff		ldy #$ff			ldy 	#255
.13d2	c8		iny		_EXGL0:	iny
.13d3	b1 06		lda ($06),y			lda 	(zTemp3),y
.13d5	d0 fb		bne $13d2			bne 	_EXGL0
.13d7	98		tya				tya
.13d8	7a		ply				ply
.13d9	60		rts				rts
.13da					EXPrintString:
.13da	48		pha				pha
.13db	5a		phy				phy
.13dc	84 03		sty $03				sty 	zTemp1+1
.13de	85 02		sta $02				sta 	zTemp1
.13e0	a0 00		ldy #$00			ldy 	#0
.13e2					_EXPSLoop:
.13e2	b1 02		lda ($02),y			lda 	(zTemp1),y
.13e4	f0 13		beq $13f9			beq 	_EXPSExit
.13e6	29 7f		and #$7f			and 	#$7F
.13e8	c9 61		cmp #$61			cmp 	#'a'
.13ea	90 07		bcc $13f3			bcc 	_EXPSNoLC
.13ec	c9 7b		cmp #$7b			cmp 	#'z'+1
.13ee	b0 03		bcs $13f3			bcs 	_EXPSNoLC
.13f0	38		sec				sec
.13f1	e9 20		sbc #$20			sbc 	#32
.13f3					_EXPSNoLC:
.13f3	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.13f6	c8		iny				iny
.13f7	80 e9		bra $13e2			bra 	_EXPSLoop
.13f9					_EXPSExit:
.13f9	7a		ply				ply
.13fa	68		pla				pla
.13fb	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: code/syntax.asm

.13fc					SyntaxCheckRightBracket:
.13fc	b1 00		lda ($00),y			lda 	(codePtr),y
.13fe	c8		iny				iny
.13ff	c9 81		cmp #$81			cmp 	#TOK_RPAREN
.1401	d0 01		bne $1404			bne 	_SCRBError
.1403	60		rts				rts
.1404					_SCRBError:
.1404	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>1407	4d 69 73 73 69 6e 67 20				.text 	"Missing )",0
>140f	29 00

;******  Return to file: files.asm


;******  Processing file: commands/let.asm

.1411					Command_LET:
>1411	ff						.byte 	$FF

;******  Return to file: files.asm


;******  Processing file: commands/miscellany.asm

.1412					Command_Assert:
.1412	a2 00		ldx #$00			ldx 	#0 							; get a single parameter
.1414	20 7d 14	jsr $147d			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1417	20 56 15	jsr $1556			jsr 	DeReferenceUnary 			; convert term to value if reference.
.141a	20 90 15	jsr $1590			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.141d	90 03		bcc $1422			bcc 	_Integer
.141f	4c a2 12	jmp $12a2			jmp 	SyntaxError
.1422					_Integer:
.1422	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; check it is non-zero
.1425	1d 40 06	ora $0640,x			ora 	xsIntHigh,x
.1428	f0 01		beq $142b			beq 	_CAFail
.142a	60		rts				rts
.142b					_CAFail:
.142b	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>142e	41 73 73 65 72 74 00				.text 	"Assert",0

;******  Return to file: files.asm


;******  Processing file: commands/run.asm

.1435					Command_RUN:
.1435	a9 6a		lda #$6a			lda 	#(BasicProgram) & $FF
.1437	85 00		sta $00				sta 	0+(codePtr)
.1439	a9 19		lda #$19			lda 	#(BasicProgram) >> 8
.143b	85 01		sta $01				sta 	1+(codePtr)
.143d					_CRNewLine:
.143d	b2 00		lda ($00)			lda 	(codePtr) 					; check not at the end of the program
.143f	f0 2f		beq $1470			beq 	Command_END 				; reached the end of the program
.1441	a0 02		ldy #$02			ldy 	#2 							; first token of program line -1 for the INY
.1443					_CRNextToken:
.1443	c8		iny				iny 								;
.1444					_CRNextCommand:
.1444	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token.
.1446	10 25		bpl $146d			bpl 	_CRDefaultLet 				; is it a token, if not, try LET.
.1448	c9 82		cmp #$82			cmp 	#TOK_COLON 					; skip colons
.144a	f0 f7		beq $1443			beq 	_CRNextToken
.144c	c9 d7		cmp #$d7			cmp 	#TOK_LAST_TOKEN				; token too high, probably $F8-$FF
.144e	b0 1a		bcs $146a			bcs 	_CRSyntax
.1450	0a		asl a				asl 	a 							; put token x 2 in X, clears bit 7.
.1451	f0 07		beq $145a			beq 	_CRNextLine 				; if this is zero now it was $80, so end of line
.1453	aa		tax				tax
.1454	c8		iny				iny 								; advance over token.
.1455	20 67 14	jsr $1467			jsr 	_CRCallRoutine 				; call that routine
.1458	80 ea		bra $1444			bra 	_CRNextCommand 				; and carry on.
.145a					_CRNextLine:
.145a	18		clc				clc
.145b	a5 00		lda $00				lda 	codePtr
.145d	72 00		adc ($00)			adc 	(codePtr)
.145f	85 00		sta $00				sta 	codePtr
.1461	90 02		bcc $1465			bcc 	_NoCarryAdv
.1463	e6 01		inc $01				inc 	codePtr+1
.1465					_NoCarryAdv:
.1465	80 d6		bra $143d			bra 	_CRNewLine 					; do new line code.
.1467					_CRCallRoutine:
.1467	7c f4 11	jmp ($11f4,x)			jmp 	(TokenVectors,x)
.146a					_CRSyntax:
.146a	4c a2 12	jmp $12a2			jmp 	SyntaxError
.146d					_CRDefaultLet:
.146d	4c 11 14	jmp $1411			jmp 	Command_LET
.1470					Command_END:
.1470	4c 30 19	jmp $1930			jmp 	WarmStart
.1473					Command_STOP:
.1473	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>1476	53 74 6f 70 00					.text 	"Stop",0

;******  Return to file: files.asm


;******  Processing file: expression/evaluate.asm

.147b					EvaluateExpression:
.147b	a2 00		ldx #$00			ldx 	#0 							; reset the evaluation stack pointer in X
.147d					EvaluateExpressionAtX:
.147d	a9 10		lda #$10			lda 	#$10 						; this is the lowest precedence.
.147f					EvaluateExpressionAtXPrecA:
.147f	48		pha				pha 								; save lowest stack level.
.1480	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first term.
.1482	30 4f		bmi $14d3			bmi 	_EXAKeywordData 			; is it keyword, or data.
.1484	c9 60		cmp #$60			cmp 	#$60 						; is it a variable
.1486	90 46		bcc $14ce			bcc 	_EXAVariable
.1488	c8		iny				iny 								; skip over the short constant
.1489	29 1f		and #$1f			and 	#$1F 						; short constant $00-$1F
.148b	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and put as an integer
.148e	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.1491	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; integer, number, not a reference.
.1494					_EXAHaveTerm:
.1494	68		pla				pla 	 							; restore current precedence and save in zTemp1
.1495	85 02		sta $02				sta 	zTemp1
.1497	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by a binary operation.
.1499	da		phx				phx
.149a	aa		tax				tax
.149b	bd 1d 11	lda $111d,x			lda 	TokenControlByteTable-$80,x ; get the control byte.
.149e	fa		plx				plx
.149f	c9 20		cmp #$20			cmp 	#$20 						; must be $10-$17 (or possibly $00, will be < precedence)
.14a1	b0 06		bcs $14a9			bcs 	_EXAExit
.14a3	c5 02		cmp $02				cmp 	zTemp1 						; check against current precedence.
.14a5	f0 02		beq $14a9			beq 	_EXAExit
.14a7	b0 01		bcs $14aa			bcs		_EXABinaryOp 				; if >, do a binary operation.
.14a9					_EXAExit:
.14a9	60		rts				rts 								; exit expression evaluation.
.14aa					_EXABinaryOp:
.14aa	85 03		sta $03				sta 	zTemp1+1 					; save operator.
.14ac	a5 02		lda $02				lda 	zTemp1 						; get and save current precedence
.14ae	48		pha				pha
.14af	b1 00		lda ($00),y			lda 	(codePtr),y 				; push binary operator on stack
.14b1	48		pha				pha
.14b2	c8		iny				iny 								; and skip over it.
.14b3	e8		inx				inx 								; calculate the RHS in the next slot up.
.14b4	a5 03		lda $03				lda 	zTemp1+1 					; at operator precedence level.
.14b6	20 7f 14	jsr $147f			jsr 	EvaluateExpressionAtXPrecA
.14b9	ca		dex				dex
.14ba	68		pla				pla 								; get binary operator.
.14bb	da		phx				phx 								; save stack depth.
.14bc	0a		asl a				asl 	a 							; double binary operator and put into X, loses MSB
.14bd	aa		tax				tax
.14be	bd f4 11	lda $11f4,x			lda 	TokenVectors,x 				; get address => zTemp2
.14c1	85 04		sta $04				sta 	zTemp2
.14c3	bd f5 11	lda $11f5,x			lda 	TokenVectors+1,x
.14c6	85 05		sta $05				sta 	zTemp2+1
.14c8	fa		plx				plx 								; restore stack depth.
.14c9	20 48 15	jsr $1548			jsr 	_EXACallZTemp2 				; call the routine
.14cc	80 c6		bra $1494			bra 	_EXAHaveTerm 				; and loop round again.
.14ce					_EXAVariable:
.14ce	20 df 18	jsr $18df			jsr 	VariableLookup 				; look up the variable value perhaps creating it.
.14d1	80 c1		bra $1494			bra 	_EXAHaveTerm 				; and carry on with the expression
.14d3					_EXAKeywordData:
.14d3	c9 90		cmp #$90			cmp 	#TOK_MINUS 					; special case as - is unary and binary operator.
.14d5	d0 09		bne $14e0			bne 	_EXANotNegate
.14d7	c8		iny				iny
.14d8	20 4b 15	jsr $154b			jsr 	EvaluateTermAtX 			; the term
.14db	20 3c 17	jsr $173c			jsr 	IntegerNegate 				; negate it
.14de	80 b4		bra $1494			bra 	_EXAHaveTerm 				; and loop back.
.14e0					_EXANotNegate:
.14e0	c9 f8		cmp #$f8			cmp 	#$F8 						; $80-$F8 are unary functions
.14e2	90 45		bcc $1529			bcc 	_EXAUnaryFunction
.14e4	c9 fb		cmp #$fb			cmp 	#$FB 						; $FB is a string.
.14e6	f0 25		beq $150d			beq 	_EXAString
.14e8	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; it is now either $FE (short int) or $FF (long int)
.14eb	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.14ee	48		pha				pha 								; save identifier
.14ef	c8		iny				iny 								; do the low byte
.14f0	b1 00		lda ($00),y			lda 	(codePtr),y
.14f2	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.14f5	c8		iny				iny
.14f6	68		pla				pla 								; get identifier
.14f7	c9 fe		cmp #$fe			cmp 	#$FE  						; if short then done.
.14f9	f0 99		beq $1494			beq 	_EXAHaveTerm
.14fb	c9 ff		cmp #$ff			cmp 	#$FF 						; should be $FF
.14fd	d0 08		bne $1507			bne 	_EXACrash
.14ff	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy high byte
.1501	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1504	c8		iny				iny
.1505	80 8d		bra $1494			bra 	_EXAHaveTerm
.1507					_EXACrash:
.1507	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>150a	23 58 00					.text 	"#X",0
.150d					_EXAString:
.150d	c8		iny				iny 								; point to string length, which is the string start.
.150e	98		tya				tya 								; work out the physical address of the string
.150f	18		clc				clc
.1510	65 00		adc $00				adc 	codePtr
.1512	9d 20 06	sta $0620,x			sta 	xsAddrLow,x
.1515	a5 01		lda $01				lda 	codePtr+1
.1517	69 00		adc #$00			adc 	#0
.1519	9d 40 06	sta $0640,x			sta 	xsAddrHigh,x
.151c	a9 40		lda #$40			lda 	#$40 						; set the type to string
.151e	9d 00 06	sta $0600,x			sta 	xsStatus,x
.1521	98		tya				tya 								; add the length to the current position
.1522	38		sec				sec 								; +1 for the length byte itself.
.1523	71 00		adc ($00),y			adc 	(codePtr),y
.1525	a8		tay				tay
.1526	4c 94 14	jmp $1494			jmp 	_EXAHaveTerm
.1529					_EXAUnaryFunction:
.1529	da		phx				phx 								; get the table entry to check it is a unary function
.152a	aa		tax				tax
.152b	3c 1d 11	bit $111d,x			bit 	TokenControlByteTable-$80,x ; if bit 6 is not set, it's not a unary function.
.152e	50 15		bvc $1545			bvc 	_EXANotUnaryFunction
.1530	8a		txa				txa 								; now copy the routine address, put token x 2 in.
.1531	0a		asl a				asl 	a
.1532	aa		tax				tax
.1533	bd f4 11	lda $11f4,x			lda 	TokenVectors,x 				; get address => zTemp2
.1536	85 04		sta $04				sta 	zTemp2
.1538	bd f5 11	lda $11f5,x			lda 	TokenVectors+1,x
.153b	85 05		sta $05				sta 	zTemp2+1
.153d	fa		plx				plx 								; restore stack depth.
.153e	c8		iny				iny 								; skip unary function token.
.153f	20 48 15	jsr $1548			jsr 	_EXACallZTemp2 				; call the routine
.1542	4c 94 14	jmp $1494			jmp 	_EXAHaveTerm 				; and loop round again.
.1545					_EXANotUnaryFunction:
.1545	4c a2 12	jmp $12a2			jmp 	SyntaxError
.1548					_EXACallZTemp2:
.1548	6c 04 00	jmp ($0004)			jmp 	(zTemp2)

;******  Return to file: files.asm


;******  Processing file: expression/exprutils.asm

.154b					EvaluateTermAtX:
.154b	a9 1f		lda #$1f			lda 	#$1F 						; too high precedence so just term
.154d	20 7f 14	jsr $147f			jsr 	EvaluateExpressionAtXPrecA
.1550	60		rts				rts
.1551					DeReferenceBinary:
.1551	e8		inx				inx
.1552	20 56 15	jsr $1556			jsr 	DeReferenceUnary
.1555	ca		dex				dex
.1556					DeReferenceUnary:
.1556	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; the reference flag is in bit 0
.1559	6a		ror a				ror 	a 							; shift into carry.
.155a	90 33		bcc $158f			bcc 	_DRNotReference 			; if clear, it's already a reference.
.155c	0a		asl a				asl 	a 							; get back, but with bit 0 cleared
.155d	9d 00 06	sta $0600,x			sta 	xsStatus,x
.1560	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put the address to dereference into zTemp1
.1563	85 02		sta $02				sta 	zTemp1
.1565	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.1568	85 03		sta $03				sta 	zTemp1+1
.156a	5a		phy				phy 								; save position in code
.156b	b2 02		lda ($02)			lda 	(zTemp1) 					; dereference the first two bytes - this will be
.156d	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; for float, int and string, and will go in these
.1570	a0 01		ldy #$01			ldy 	#1 							; which are also the address, and mantissa3 & 2
.1572	b1 02		lda ($02),y			lda 	(zTemp1),y
.1574	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1577	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; check if it's a float (bit 7)
.157a	10 12		bpl $158e			bpl 	_DRNotFloat 				; if not, we are complete
.157c	c8		iny				iny 								; if float, copy all five bytes of the floating point
.157d	b1 02		lda ($02),y			lda 	(zTemp1),y 					; number into the stack.
.157f	9d 60 06	sta $0660,x			sta 	xsMantissa1,x
.1582	c8		iny				iny
.1583	b1 02		lda ($02),y			lda 	(zTemp1),y
.1585	9d 80 06	sta $0680,x			sta 	xsMantissa0,x
.1588	c8		iny				iny
.1589	b1 02		lda ($02),y			lda 	(zTemp1),y
.158b	9d a0 06	sta $06a0,x			sta 	xsExponent,x
.158e					_DRNotFloat:
.158e	7a		ply				ply 								; restore code position.
.158f					_DRNotReference:
.158f	60		rts				rts
.1590					UnaryNumberTypeCheck:
.1590	bd 00 06	lda $0600,x			lda 	xsStatus,x
.1593	80 06		bra $159b			bra 	BNTCMain
.1595					BinaryNumberTypeCheck:
.1595	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; bit 7 set if either float, bit 6 set if either string.
.1598	1d 01 06	ora $0601,x			ora 	xsStatus+1,x
.159b					BNTCMain:
.159b	0a		asl a				asl 	a 							; carry set if either float, bit 7 set if either string
.159c	30 01		bmi $159f			bmi 	_NTCError 					; so fail if string, we want int
.159e	60		rts				rts
.159f					_NTCError:
.159f	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>15a2	4e 75 6d 62 65 72 20 65				.text 	"Number expected",0
>15aa	78 70 65 63 74 65 64 00
.15b2					BinaryStringTypeCheck:
.15b2	3c 01 06	bit $0601,x			bit 	xsStatus+1,x
.15b5	50 06		bvc $15bd			bvc 	STCError
.15b7					UnaryStringTypeCheck:
.15b7	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; check if string
.15ba	50 01		bvc $15bd			bvc 	STCError
.15bc	60		rts				rts
.15bd					STCError:
.15bd	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>15c0	53 74 72 69 6e 67 20 65				.text 	"String expected",0
>15c8	78 70 65 63 74 65 64 00

;******  Return to file: files.asm


;******  Processing file: expression/integer/arithmetic.asm

.15d0					BinaryAdd:
.15d0	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.15d3	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.15d6	50 06		bvc $15de			bvc 	_NumericType
.15d8	20 b2 15	jsr $15b2			jsr 	BinaryStringTypeCheck 		; check both are strings
.15db	4c a2 12	jmp $12a2			jmp 	SyntaxError 							; and do the string handler
.15de					_NumericType:
.15de	90 03		bcc $15e3			bcc 	_Integer
.15e0	4c 06 19	jmp $1906			jmp 	FPAdd
.15e3					_Integer:
.15e3	18		clc				clc
.15e4	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.15e7	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.15ea	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.15ed	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.15f0	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.15f3	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.15f6	60		rts				rts
.15f7					BinarySub:
.15f7	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.15fa	20 95 15	jsr $1595			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.15fd	90 03		bcc $1602			bcc 	_Integer
.15ff	4c 06 19	jmp $1906			jmp 	FPSub
.1602					_Integer:
.1602	38		sec				sec
.1603	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1606	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.1609	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.160c	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.160f	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.1612	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1615	60		rts				rts
.1616					BinaryAnd:
.1616	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.1619	20 95 15	jsr $1595			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.161c	90 03		bcc $1621			bcc 	_Integer
.161e	20 06 19	jsr $1906			jsr 	FPFloatToInteger
.1621					_Integer:
.1621	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1624	3d 21 06	and $0621,x			and 	xsIntLow+1,x
.1627	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.162a	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.162d	3d 41 06	and $0641,x			and 	xsIntHigh+1,x
.1630	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1633	60		rts				rts
.1634					BinaryOr:
.1634	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.1637	20 95 15	jsr $1595			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.163a	90 03		bcc $163f			bcc 	_Integer
.163c	20 06 19	jsr $1906			jsr 	FPFloatToInteger
.163f					_Integer:
.163f	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1642	1d 21 06	ora $0621,x			ora 	xsIntLow+1,x
.1645	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1648	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.164b	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.164e	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1651	60		rts				rts
.1652					BinaryXor:
.1652	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.1655	20 95 15	jsr $1595			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.1658	90 03		bcc $165d			bcc 	_Integer
.165a	20 06 19	jsr $1906			jsr 	FPFloatToInteger
.165d					_Integer:
.165d	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1660	5d 21 06	eor $0621,x			eor 	xsIntLow+1,x
.1663	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1666	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.1669	5d 41 06	eor $0641,x			eor 	xsIntHigh+1,x
.166c	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.166f	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/multiply.asm

.1670					Multiply16x16:
.1670	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.1673	20 95 15	jsr $1595			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.1676	90 03		bcc $167b			bcc 	_Integer
.1678	4c 06 19	jmp $1906			jmp 	FPMultiply
.167b					_Integer:
.167b	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; 1st value to zTemp1
.167e	85 04		sta $04				sta 	zTemp2
.1680	bd 40 06	lda $0640,x			lda		xsIntHigh,x
.1683	85 05		sta $05				sta 	zTemp2+1
.1685	9e 20 06	stz $0620,x			stz 	xsIntLow,x 					; zero 1st on stack
.1688	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.168b					_MultLoop:
.168b	46 05		lsr $05				lsr 	zTemp2+1 					; ror zTemp2 into C
.168d	66 04		ror $04				ror 	zTemp2
.168f	90 13		bcc $16a4			bcc 	_MultNoAdd
.1691	18		clc				clc 								; add 2nd to 1st.
.1692	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1695	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.1698	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.169b	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.169e	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.16a1	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.16a4					_MultNoAdd:
.16a4	1e 21 06	asl $0621,x			asl 	xsIntLow+1,x 				; shift 2nd left
.16a7	3e 41 06	rol $0641,x			rol 	xsIntHigh+1,x
.16aa	a5 04		lda $04				lda 	zTemp2	 					; until multiplier is zero
.16ac	05 05		ora $05				ora 	zTemp2+1
.16ae	d0 db		bne $168b			bne 	_MultLoop
.16b0	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/divide.asm

.16b1					Divide16x16:
.16b1	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.16b4	20 95 15	jsr $1595			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.16b7	90 03		bcc $16bc			bcc 	_Integer
.16b9	4c 06 19	jmp $1906			jmp 	FPDivide
.16bc					_Integer:
.16bc	20 dd 16	jsr $16dd			jsr 	IntegerDivide
.16bf	60		rts				rts
.16c0					Modulus16x16:
.16c0	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.16c3	20 95 15	jsr $1595			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.16c6	90 03		bcc $16cb			bcc 	_Integer
.16c8	4c 06 19	jmp $1906			jmp 	FPModulus
.16cb					_Integer:
.16cb	20 dd 16	jsr $16dd			jsr 	IntegerDivide
.16ce	a5 02		lda $02				lda 	zTemp1
.16d0	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.16d3	a5 03		lda $03				lda 	zTemp1+1
.16d5	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.16d8	60		rts				rts
.16d9					UnsignedIntegerDivide:
.16d9	64 0a		stz $0a				stz 	SignCount 					; Count of signs.
.16db	80 1e		bra $16fb			bra 	DivideMain
.16dd					IntegerDivide:
.16dd	bd 21 06	lda $0621,x			lda 	xsIntLow+1,x 				; check for division by zero.
.16e0	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.16e3	d0 14		bne $16f9			bne 	_BFDOkay
.16e5	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>16e8	44 69 76 69 73 69 6f 6e				.text 	"Division by Zero",0
>16f0	20 62 79 20 5a 65 72 6f 00
.16f9					_BFDOkay:
.16f9	64 0a		stz $0a				stz 	SignCount 					; Count of signs.
.16fb					DivideMain:
.16fb	64 02		stz $02				stz 	zTemp1 						; Q/Dividend/Left in +0
.16fd	64 03		stz $03				stz 	zTemp1+1 					; M/Divisor/Right in +1
.16ff	5a		phy				phy 								; Y is the counter, save position
.1700	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1702					_BFDLoop:
.1702	1e 20 06	asl $0620,x			asl 	xsIntLow,x 					; shift AQ left.
.1705	3e 40 06	rol $0640,x			rol 	xsIntHigh,x
.1708	26 02		rol $02				rol 	zTemp1
.170a	26 03		rol $03				rol 	zTemp1+1
.170c	38		sec				sec
.170d	a5 02		lda $02				lda 	zTemp1+0 					; Calculate A-M on stack.
.170f	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.1712	48		pha				pha
.1713	a5 03		lda $03				lda 	zTemp1+1
.1715	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.1718	90 0f		bcc $1729			bcc 	_BFDNoAdd
.171a	85 03		sta $03				sta 	zTemp1+1
.171c	68		pla				pla
.171d	85 02		sta $02				sta 	zTemp1+0
.171f	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; set Q bit 1.
.1722	09 01		ora #$01			ora 	#1
.1724	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1727	80 01		bra $172a			bra 	_BFDNext
.1729					_BFDNoAdd:
.1729	68		pla				pla 								; Throw away the intermediate calculations
.172a					_BFDNext:
.172a	88		dey				dey
.172b	d0 d5		bne $1702			bne 	_BFDLoop
.172d	7a		ply				ply 								; restore Y
.172e	46 0a		lsr $0a				lsr 	SignCount 					; if sign count odd,
.1730	90 03		bcc $1735			bcc 	_BFDUnsigned 				; then the result is signed
.1732	20 3c 17	jsr $173c			jsr		IntegerNegate 				; negate the result
.1735					_BFDUnsigned:
.1735	60		rts				rts
.1736					CheckIntegerNegate:
.1736	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; is it -ve = MSB set ?
.1739	30 01		bmi $173c			bmi 	IntegerNegate 				; if so negate it
.173b	60		rts				rts
.173c					IntegerNegate:
.173c	e6 0a		inc $0a				inc 	SignCount 					; bump the count of signs
.173e	38		sec				sec 								; negate
.173f	a9 00		lda #$00			lda 	#0
.1741	fd 20 06	sbc $0620,x			sbc 	xsIntLow,x
.1744	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1747	a9 00		lda #$00			lda 	#0
.1749	fd 40 06	sbc $0640,x			sbc 	xsIntHigh,x
.174c	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.174f	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/icompare.asm

.1750					Compare_Equals:
.1750	18		clc				clc
.1751	80 01		bra $1754			bra 	CEMain
.1753					Compare_NotEquals:
.1753	38		sec				sec
.1754					CEMain:
.1754	08		php				php 								; carry set flips the result
.1755	20 7e 17	jsr $177e			jsr 	EqualityComparison
.1758					CEWriteResult:
.1758	28		plp				plp  								; get the flip flag
.1759	90 02		bcc $175d			bcc 	_CENoFlip
.175b	49 ff		eor #$ff			eor 	#$FF 						; if so invert the result
.175d					_CENoFlip:
.175d	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; write it out
.1760	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1763	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; its an integer
.1766	60		rts				rts
.1767					Compare_GreaterEquals:
.1767	18		clc				clc
.1768	80 01		bra $176b			bra 	GEMain
.176a					Compare_Less:
.176a	38		sec				sec
.176b					GEMain:
.176b	08		php				php 								; carry set flips the result
.176c	20 a7 17	jsr $17a7			jsr 	MagnitudeComparison
.176f	80 e7		bra $1758			bra 	CEWriteResult
.1771					Compare_LessEquals:
.1771	18		clc				clc
.1772	80 01		bra $1775			bra 	LEMain
.1774					Compare_Greater:
.1774	38		sec				sec
.1775					LEMain:
.1775	08		php				php 								; carry set flips the result
.1776	20 d2 17	jsr $17d2			jsr 	SwapStackTop 				; swap the top two over. Not that efficient, probably doesn't matter
.1779	20 a7 17	jsr $17a7			jsr 	MagnitudeComparison 		; so the comparison is backwards.
.177c	80 da		bra $1758			bra 	CEWriteResult
.177e					EqualityComparison:
.177e	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.1781	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.1784	50 06		bvc $178c			bvc 	_NumericType
.1786	20 b2 15	jsr $15b2			jsr 	BinaryStringTypeCheck 		; check both are strings
.1789	4c a2 12	jmp $12a2			jmp 	SyntaxError 							; and do the string handler
.178c					_NumericType:
.178c	90 03		bcc $1791			bcc 	_Integer
.178e	4c 06 19	jmp $1906			jmp 	FPEquality
.1791					_Integer:
.1791	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1794	dd 21 06	cmp $0621,x			cmp 	xsIntLow+1,x
.1797	d0 0b		bne $17a4			bne 	_NECFail
.1799	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.179c	dd 41 06	cmp $0641,x			cmp 	xsIntHigh+1,x
.179f	d0 03		bne $17a4			bne 	_NECFail
.17a1	a9 ff		lda #$ff			lda 	#$FF
.17a3	60		rts				rts
.17a4					_NECFail:
.17a4	a9 00		lda #$00			lda 	#$00
.17a6	60		rts				rts
.17a7					MagnitudeComparison:
.17a7	20 51 15	jsr $1551			jsr 	DeReferenceBinary 			; convert references to values
.17aa	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.17ad	50 06		bvc $17b5			bvc 	_NumericType
.17af	20 b2 15	jsr $15b2			jsr 	BinaryStringTypeCheck 		; check both are strings
.17b2	4c a2 12	jmp $12a2			jmp 	SyntaxError 							; and do the string handler
.17b5					_NumericType:
.17b5	90 03		bcc $17ba			bcc 	_Integer
.17b7	4c 06 19	jmp $1906			jmp 	FPMagnitude
.17ba					_Integer:
.17ba	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.17bd	dd 21 06	cmp $0621,x			cmp 	xsIntLow+1,x
.17c0	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.17c3	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.17c6	50 02		bvc $17ca			bvc 	_MCNoOverflow
.17c8	49 80		eor #$80			eor 	#$80
.17ca					_MCNoOverflow:
.17ca	30 03		bmi $17cf			bmi 	_NECFail
.17cc	a9 ff		lda #$ff			lda 	#$FF
.17ce	60		rts				rts
.17cf					_NECFail:
.17cf	a9 00		lda #$00			lda 	#$00
.17d1	60		rts				rts
.17d2					SwapStackTop:
.17d2	da		phx				phx
.17d3	5a		phy				phy
.17d4	a0 06		ldy #$06			ldy 	#6 							; swap count
.17d6					_SSTLoop:
.17d6	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; the first stack entry, flip it over.
.17d9	48		pha				pha
.17da	bd 01 06	lda $0601,x			lda 	xsStatus+1,x
.17dd	9d 00 06	sta $0600,x			sta 	xsStatus,x
.17e0	68		pla				pla
.17e1	9d 01 06	sta $0601,x			sta 	xsStatus+1,x
.17e4	8a		txa				txa 								; go forward to the next stack chunk.
.17e5	18		clc				clc
.17e6	69 20		adc #$20			adc 	#stackSize
.17e8	aa		tax				tax
.17e9	88		dey				dey 								; do it for the whole of this stack
.17ea	d0 ea		bne $17d6			bne 	_SSTLoop
.17ec	7a		ply				ply
.17ed	fa		plx				plx
.17ee	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/tostring.asm

.17ef					PrintYA:
.17ef	a2 00		ldx #$00			ldx 	#0 							; put on stack.
.17f1	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.17f4	98		tya				tya
.17f5	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.17f8	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; tell system it is an integer.
.17fb	a9 0a		lda #$0a			lda 	#10 						; base
.17fd	20 04 18	jsr $1804			jsr 	ConvertIntegerUnsigned 		; unsigned integer conversion.
.1800	20 da 13	jsr $13da			jsr 	EXPrintString 				; print the result
.1803	60		rts				rts
.1804					ConvertIntegerUnsigned:
.1804	da		phx				phx
.1805	48		pha				pha 								; save base on stack
.1806	64 0b		stz $0b				stz 	convertPtr 					; reset conversion position
.1808	80 11		bra $181b			bra 	CIMain
.180a					ConvertIntegerSigned:
.180a	da		phx				phx
.180b	48		pha				pha 								; save base on stack.
.180c	64 0b		stz $0b				stz 	convertPtr 					; reset conversion position
.180e	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; is it -ve ?
.1811	10 08		bpl $181b			bpl 	CIMain
.1813	20 3c 17	jsr $173c			jsr 	IntegerNegate 				; make it positive
.1816	a9 2d		lda #$2d			lda 	#"-" 						; write a - sign out.
.1818	20 54 18	jsr $1854			jsr 	CIWriteCharacter
.181b					CIMain:
.181b	7a		ply				ply									; get base back
.181c	a9 ff		lda #$ff			lda 	#$FF 						; push marker on stack.
.181e	48		pha				pha
.181f	5a		phy				phy  								; push base back.
.1820					_CILoop:
.1820	68		pla				pla 								; get and save base.
.1821	48		pha				pha
.1822	9d 21 06	sta $0621,x			sta 	xsIntLow+1,x 				; put it in the next stack level and set type
.1825	9e 41 06	stz $0641,x			stz 	xsIntHigh+1,x
.1828	9e 00 06	stz $0600,x			stz 	xsStatus,x
.182b	20 d9 16	jsr $16d9			jsr 	UnsignedIntegerDivide 		; divide.
.182e	7a		ply				ply 								; get base into Y
.182f	a5 02		lda $02				lda 	zTemp1 						; push the remainder on the stack.
.1831	48		pha				pha
.1832	5a		phy				phy 								; push the base back.
.1833	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; complete
.1836	1d 40 06	ora $0640,x			ora 	xsIntHigh,x
.1839	d0 e5		bne $1820			bne 	_CILoop
.183b	68		pla				pla 								; throw the base
.183c					_CIUnpack:
.183c	68		pla				pla 								; pull off stack so in the right order
.183d	30 0f		bmi $184e			bmi 	_CIExit
.183f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.1841	90 03		bcc $1846			bcc 	_CINotAlpha
.1843	18		clc				clc
.1844	69 07		adc #$07			adc 	#7
.1846					_CINotAlpha:
.1846	18		clc				clc
.1847	69 30		adc #$30			adc 	#48
.1849	20 54 18	jsr $1854			jsr 	CIWriteCharacter 			; keep going till reach the marker
.184c	80 ee		bra $183c			bra 	_CIUnpack
.184e					_CIExit:
.184e	fa		plx				plx
.184f	a9 00		lda #$00			lda 	#textBuffer & $FF 			; return with pointer in YA
.1851	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.1853	60		rts				rts
.1854					CIWriteCharacter:
.1854	da		phx				phx
.1855	a6 0b		ldx $0b				ldx		convertPtr
.1857	9d 00 08	sta $0800,x			sta 	textBuffer,x
.185a	9e 01 08	stz $0801,x			stz 	textBuffer+1,x
.185d	fa		plx				plx
.185e	e6 0b		inc $0b				inc 	convertPtr
.1860	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/unary.asm

.1861					Dummy_Binary:
.1861					Dummy_Hex:
.1861	20 4b 15	jsr $154b			jsr 	EvaluateTermAtX
.1864	60		rts				rts
.1865					Parenthesis:
.1865	20 7d 14	jsr $147d			jsr 	EvaluateExpressionAtX 		; parenthesised expression
.1868	20 fc 13	jsr $13fc			jsr 	SyntaxCheckRightBracket 	; check followed by )
.186b	60		rts				rts
.186c					AbsoluteValue:
.186c	20 7d 14	jsr $147d			jsr 	EvaluateExpressionAtX 		; evaluate the term
.186f	20 56 15	jsr $1556			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1872	20 90 15	jsr $1590			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1875	90 03		bcc $187a			bcc 	_Integer
.1877	4c 81 18	jmp $1881			jmp 	AVFloat
.187a					_Integer:
.187a	20 36 17	jsr $1736			jsr 	CheckIntegerNegate 			; use absolute value in divide
.187d	20 fc 13	jsr $13fc			jsr 	SyntaxCheckRightBracket
.1880	60		rts				rts
.1881					AVFloat:
.1881	20 06 19	jsr $1906			jsr 	FPAbs
.1884	20 fc 13	jsr $13fc			jsr 	SyntaxCheckRightBracket
.1887	60		rts				rts
.1888					SignValue:
.1888	20 7d 14	jsr $147d			jsr 	EvaluateExpressionAtX 		; evaluate the term
.188b	20 56 15	jsr $1556			jsr 	DeReferenceUnary 			; convert term to value if reference.
.188e	20 90 15	jsr $1590			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1891	90 03		bcc $1896			bcc 	_Integer
.1893	4c b6 18	jmp $18b6			jmp 	SVFloat
.1896					_Integer:
.1896	20 fc 13	jsr $13fc			jsr 	SyntaxCheckRightBracket
.1899	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; Check zero
.189c	1d 20 06	ora $0620,x			ora 	xsIntLow,x
.189f	f0 05		beq $18a6			beq 	_SVSetLH
.18a1	0a		asl a				asl 	a 							; msb into carry
.18a2	90 09		bcc $18ad			bcc 	_SVGreater0 				; if CC then it's positive and non zero
.18a4	a9 ff		lda #$ff			lda 	#$FF 						; -ve so return -1
.18a6					_SVSetLH:
.18a6	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.18a9	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.18ac	60		rts				rts
.18ad					_SVGreater0:
.18ad	a9 01		lda #$01			lda 	#1
.18af	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.18b2	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.18b5	60		rts				rts
.18b6					SVFloat:
.18b6	20 06 19	jsr $1906			jsr 	FPSgn
.18b9	20 fc 13	jsr $13fc			jsr 	SyntaxCheckRightBracket
.18bc	60		rts				rts
.18bd					StringLength:
.18bd	20 7d 14	jsr $147d			jsr 	EvaluateExpressionAtX 		; evaluate the term
.18c0	20 56 15	jsr $1556			jsr 	DeReferenceUnary 			; convert term to value if reference.
.18c3	20 b7 15	jsr $15b7			jsr 	UnaryStringTypeCheck 		; check string.
.18c6	20 fc 13	jsr $13fc			jsr 	SyntaxCheckRightBracket
.18c9	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put address of string into zTemp1
.18cc	85 02		sta $02				sta 	zTemp1
.18ce	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.18d1	85 03		sta $03				sta 	zTemp1+1
.18d3	b2 02		lda ($02)			lda 	(zTemp1)					; get the length (strings are len prefixed)
.18d5	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and return it
.18d8	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.18db	9e 00 06	stz $0600,x			stz 	xsStatus,x
.18de	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: variables/variable.asm

.18df					VariableLookup:
.18df	c9 1a		cmp #$1a			cmp 	#26 						; multi character variables.
.18e1	b0 13		bcs $18f6			bcs 	_VLError
.18e3	0a		asl a				asl 	a 							; multiply by 5, do not move for float
.18e4	0a		asl a				asl 	a
.18e5	71 00		adc ($00),y			adc 	(codePtr),y
.18e7	c8		iny				iny 								; skip over variable token
.18e8	9d 20 06	sta $0620,x			sta 	xsAddrLow,x
.18eb	a9 07		lda #$07			lda 	#variables >> 8
.18ed	9d 40 06	sta $0640,x			sta 	xsAddrHigh,x
.18f0	a9 01		lda #$01			lda 	#$01 						; integer reference.
.18f2	9d 00 06	sta $0600,x			sta 	xsStatus,x
.18f5	60		rts				rts
.18f6					_VLError:
.18f6	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>18f9	42 61 64 20 56 61 72 69				.text 	"Bad Variable",0
>1901	61 62 6c 65 00

;******  Return to file: files.asm


;******  Processing file: expression/float/floatdummy.asm

.1906					FPAdd:
.1906					FPSub:
.1906					FPMultiply:
.1906					FPDivide:
.1906					FPModulus:
.1906					FPAbs:
.1906					FPSgn:
.1906					FPFloatToInteger:
.1906					FPIntegerToFloat:
.1906					FPEquality:
.1906					FPMagnitude:
.1906	20 b2 12	jsr $12b2			jsr 	ErrorHandler
>1909	46 6c 6f 61 74 20 4e 6f				.text 	"Float Not Implemented",0
>1911	74 20 49 6d 70 6c 65 6d 65 6e 74 65 64 00

;******  Return to file: files.asm


;******  Return to file: basic.asm

.191f					ColdStart:
.191f	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1921	9a		txs				txs
>1922	ff						.byte 	$FF
.1923	20 e7 12	jsr $12e7			jsr 	ExternInitialise
.1926	a9 33		lda #$33			lda 	#BootMessage & $FF
.1928	a0 19		ldy #$19			ldy 	#BootMessage >> 8
.192a	20 da 13	jsr $13da			jsr 	EXPrintString
.192d	4c 35 14	jmp $1435			jmp 	Command_Run
.1930					WarmStart:
.1930	4c ff ff	jmp $ffff			jmp 	$FFFF
.1933					BootMessage:
>1933	2a 2a 2a 2a 20 43 6f 6d				.text 	"**** Commander X16 Basic Alpha 1 ****",13,13
>193b	6d 61 6e 64 65 72 20 58 31 36 20 42 61 73 69 63
>194b	20 41 6c 70 68 61 20 31 20 2a 2a 2a 2a 0d 0d
>195a	35 31 32 4b 20 48 69 67				.text 	"512K High RAM",13,13,0
>1962	68 20 52 41 4d 0d 0d 00
.196a					BasicProgram:

;******  End of listing
