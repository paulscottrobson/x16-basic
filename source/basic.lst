
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o basic.prg -L basic.lst -l basic.lbl basic.asm
; Sat Feb 08 09:30:18 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: code/data.asm

.0000					codePtr:
>0000							.word 	?
.0002					zTemp1:
>0002							.word 	?
.0004					zTemp2:
>0004							.word 	?
.0006					zTemp3:
>0006							.word 	?
.0008					zTemp4:
>0008							.word 	?
.000a					signCount:
>000a							.byte 	?
=$600					xsStatus = $600								; expression stack.
=$620					xsAddrLow = $620 							; these values are shared depending on type.
=$640					xsAddrHigh = $640
=$620					xsIntLow = xsAddrLow
=$640					xsIntHigh = xsAddrHigh
=$620					xsMantissa3 = xsAddrLow
=$640					xsMantissa2 = xsAddrHigh
=$660					xsMantissa1 = $660
=$680					xsMantissa0 = $680
=$6a0					xsExponent = $6A0

;******  Return to file: basic.asm


;******  Processing file: code/macros.asm


;******  Return to file: basic.asm

.6000	4c c7 65	jmp $65c7			jmp 	ColdStart

;******  Processing file: files.asm

.6003					TokenTextTable:

;******  Processing file: generated/tokentext.inc

>6003	05 28 45 4f 4c a9			.byte	$05,$28,$45,$4f,$4c,$a9                  ; $80 : (eol)
>6009	03 41 4e c4				.byte	$03,$41,$4e,$c4                          ; $81 : and
>600d	02 4f d2				.byte	$02,$4f,$d2                              ; $82 : or
>6010	03 58 4f d2				.byte	$03,$58,$4f,$d2                          ; $83 : xor
>6014	01 be					.byte	$01,$be                                  ; $84 : >
>6016	02 3e bd				.byte	$02,$3e,$bd                              ; $85 : >=
>6019	01 bc					.byte	$01,$bc                                  ; $86 : <
>601b	02 3c bd				.byte	$02,$3c,$bd                              ; $87 : <=
>601e	01 bd					.byte	$01,$bd                                  ; $88 : =
>6020	02 3c be				.byte	$02,$3c,$be                              ; $89 : <>
>6023	01 ab					.byte	$01,$ab                                  ; $8a : +
>6025	01 ad					.byte	$01,$ad                                  ; $8b : -
>6027	01 aa					.byte	$01,$aa                                  ; $8c : *
>6029	01 af					.byte	$01,$af                                  ; $8d : /
>602b	03 4d 4f c4				.byte	$03,$4d,$4f,$c4                          ; $8e : mod
>602f	04 4c 45 4e a8				.byte	$04,$4c,$45,$4e,$a8                      ; $8f : len(
>6034	04 52 4e 44 a8				.byte	$04,$52,$4e,$44,$a8                      ; $90 : rnd(
>6039	04 41 53 43 a8				.byte	$04,$41,$53,$43,$a8                      ; $91 : asc(
>603e	05 43 48 52 24 a8			.byte	$05,$43,$48,$52,$24,$a8                  ; $92 : chr$(
>6044	04 56 41 4c a8				.byte	$04,$56,$41,$4c,$a8                      ; $93 : val(
>6049	05 53 54 52 24 a8			.byte	$05,$53,$54,$52,$24,$a8                  ; $94 : str$(
>604f	04 53 50 43 a8				.byte	$04,$53,$50,$43,$a8                      ; $95 : spc(
>6054	06 4c 45 46 54 24 a8			.byte	$06,$4c,$45,$46,$54,$24,$a8              ; $96 : left$(
>605b	05 4d 49 44 24 a8			.byte	$05,$4d,$49,$44,$24,$a8                  ; $97 : mid$(
>6061	07 52 49 47 48 54 24 a8			.byte	$07,$52,$49,$47,$48,$54,$24,$a8          ; $98 : right$(
>6069	04 41 42 53 a8				.byte	$04,$41,$42,$53,$a8                      ; $99 : abs(
>606e	04 53 47 4e a8				.byte	$04,$53,$47,$4e,$a8                      ; $9a : sgn(
>6073	04 49 4e 54 a8				.byte	$04,$49,$4e,$54,$a8                      ; $9b : int(
>6078	05 44 45 45 4b a8			.byte	$05,$44,$45,$45,$4b,$a8                  ; $9c : deek(
>607e	05 50 45 45 4b a8			.byte	$05,$50,$45,$45,$4b,$a8                  ; $9d : peek(
>6084	06 56 50 45 45 4b a8			.byte	$06,$56,$50,$45,$45,$4b,$a8              ; $9e : vpeek(
>608b	01 a8					.byte	$01,$a8                                  ; $9f : (
>608d	01 a5					.byte	$01,$a5                                  ; $a0 : %
>608f	01 a4					.byte	$01,$a4                                  ; $a1 : $
>6091	02 49 c6				.byte	$02,$49,$c6                              ; $a2 : if
>6094	06 52 45 50 45 41 d4			.byte	$06,$52,$45,$50,$45,$41,$d4              ; $a3 : repeat
>609b	03 46 4f d2				.byte	$03,$46,$4f,$d2                          ; $a4 : for
>609f	05 57 48 49 4c c5			.byte	$05,$57,$48,$49,$4c,$c5                  ; $a5 : while
>60a5	04 43 41 53 c5				.byte	$04,$43,$41,$53,$c5                      ; $a6 : case
>60aa	04 54 48 45 ce				.byte	$04,$54,$48,$45,$ce                      ; $a7 : then
>60af	05 45 4e 44 49 c6			.byte	$05,$45,$4e,$44,$49,$c6                  ; $a8 : endif
>60b5	05 55 4e 54 49 cc			.byte	$05,$55,$4e,$54,$49,$cc                  ; $a9 : until
>60bb	04 4e 45 58 d4				.byte	$04,$4e,$45,$58,$d4                      ; $aa : next
>60c0	08 45 4e 44 57 48 49 4c			.byte	$08,$45,$4e,$44,$57,$48,$49,$4c,$c5      ; $ab : endwhile
>60c8	c5
>60c9	07 45 4e 44 43 41 53 c5			.byte	$07,$45,$4e,$44,$43,$41,$53,$c5          ; $ac : endcase
>60d1	02 54 cf				.byte	$02,$54,$cf                              ; $ad : to
>60d4	04 53 54 45 d0				.byte	$04,$53,$54,$45,$d0                      ; $ae : step
>60d9	07 44 45 46 50 52 4f c3			.byte	$07,$44,$45,$46,$50,$52,$4f,$c3          ; $af : defproc
>60e1	07 45 4e 44 50 52 4f c3			.byte	$07,$45,$4e,$44,$50,$52,$4f,$c3          ; $b0 : endproc
>60e9	04 50 52 4f c3				.byte	$04,$50,$52,$4f,$c3                      ; $b1 : proc
>60ee	05 4c 4f 43 41 cc			.byte	$05,$4c,$4f,$43,$41,$cc                  ; $b2 : local
>60f4	03 4c 45 d4				.byte	$03,$4c,$45,$d4                          ; $b3 : let
>60f8	03 52 55 ce				.byte	$03,$52,$55,$ce                          ; $b4 : run
>60fc	04 53 54 4f d0				.byte	$04,$53,$54,$4f,$d0                      ; $b5 : stop
>6101	03 45 4e c4				.byte	$03,$45,$4e,$c4                          ; $b6 : end
>6105	05 50 52 49 4e d4			.byte	$05,$50,$52,$49,$4e,$d4                  ; $b7 : print
>610b	05 49 4e 50 55 d4			.byte	$05,$49,$4e,$50,$55,$d4                  ; $b8 : input
>6111	04 57 48 45 ce				.byte	$04,$57,$48,$45,$ce                      ; $b9 : when
>6116	07 44 45 46 41 55 4c d4			.byte	$07,$44,$45,$46,$41,$55,$4c,$d4          ; $ba : default
>611e	06 4f 50 54 49 4f ce			.byte	$06,$4f,$50,$54,$49,$4f,$ce              ; $bb : option
>6125	04 4c 49 53 d4				.byte	$04,$4c,$49,$53,$d4                      ; $bc : list
>612a	04 4c 4f 41 c4				.byte	$04,$4c,$4f,$41,$c4                      ; $bd : load
>612f	04 53 41 56 c5				.byte	$04,$53,$41,$56,$c5                      ; $be : save
>6134	03 4e 45 d7				.byte	$03,$4e,$45,$d7                          ; $bf : new
>6138	03 4f 4c c4				.byte	$03,$4f,$4c,$c4                          ; $c0 : old
>613c	04 50 4f 4b c5				.byte	$04,$50,$4f,$4b,$c5                      ; $c1 : poke
>6141	04 44 4f 4b c5				.byte	$04,$44,$4f,$4b,$c5                      ; $c2 : doke
>6146	05 56 50 4f 4b c5			.byte	$05,$56,$50,$4f,$4b,$c5                  ; $c3 : vpoke
>614c	03 52 45 cd				.byte	$03,$52,$45,$cd                          ; $c4 : rem
>6150	04 47 4f 54 cf				.byte	$04,$47,$4f,$54,$cf                      ; $c5 : goto
>6155	05 47 4f 53 55 c2			.byte	$05,$47,$4f,$53,$55,$c2                  ; $c6 : gosub
>615b	03 53 59 d3				.byte	$03,$53,$59,$d3                          ; $c7 : sys
>615f	06 52 45 54 55 52 ce			.byte	$06,$52,$45,$54,$55,$52,$ce              ; $c8 : return
>6166	01 a9					.byte	$01,$a9                                  ; $c9 : )
>6168	01 ba					.byte	$01,$ba                                  ; $ca : :
>616a	00					.byte	$00

;******  Return to file: files.asm

.616b					TokenControlByteTable:

;******  Processing file: generated/tokencbyte.inc

>616b	00					.byte	$00		; $80 : (eol)
>616c	11					.byte	$11		; $81 : and
>616d	11					.byte	$11		; $82 : or
>616e	11					.byte	$11		; $83 : xor
>616f	12					.byte	$12		; $84 : >
>6170	12					.byte	$12		; $85 : >=
>6171	12					.byte	$12		; $86 : <
>6172	12					.byte	$12		; $87 : <=
>6173	12					.byte	$12		; $88 : =
>6174	12					.byte	$12		; $89 : <>
>6175	13					.byte	$13		; $8a : +
>6176	13					.byte	$13		; $8b : -
>6177	14					.byte	$14		; $8c : *
>6178	14					.byte	$14		; $8d : /
>6179	14					.byte	$14		; $8e : mod
>617a	40					.byte	$40		; $8f : len(
>617b	40					.byte	$40		; $90 : rnd(
>617c	40					.byte	$40		; $91 : asc(
>617d	40					.byte	$40		; $92 : chr$(
>617e	40					.byte	$40		; $93 : val(
>617f	40					.byte	$40		; $94 : str$(
>6180	40					.byte	$40		; $95 : spc(
>6181	40					.byte	$40		; $96 : left$(
>6182	40					.byte	$40		; $97 : mid$(
>6183	40					.byte	$40		; $98 : right$(
>6184	40					.byte	$40		; $99 : abs(
>6185	40					.byte	$40		; $9a : sgn(
>6186	40					.byte	$40		; $9b : int(
>6187	40					.byte	$40		; $9c : deek(
>6188	40					.byte	$40		; $9d : peek(
>6189	40					.byte	$40		; $9e : vpeek(
>618a	40					.byte	$40		; $9f : (
>618b	40					.byte	$40		; $a0 : %
>618c	40					.byte	$40		; $a1 : $
>618d	82					.byte	$82		; $a2 : if
>618e	82					.byte	$82		; $a3 : repeat
>618f	82					.byte	$82		; $a4 : for
>6190	82					.byte	$82		; $a5 : while
>6191	82					.byte	$82		; $a6 : case
>6192	80					.byte	$80		; $a7 : then
>6193	80					.byte	$80		; $a8 : endif
>6194	80					.byte	$80		; $a9 : until
>6195	80					.byte	$80		; $aa : next
>6196	80					.byte	$80		; $ab : endwhile
>6197	80					.byte	$80		; $ac : endcase
>6198	81					.byte	$81		; $ad : to
>6199	81					.byte	$81		; $ae : step
>619a	81					.byte	$81		; $af : defproc
>619b	81					.byte	$81		; $b0 : endproc
>619c	81					.byte	$81		; $b1 : proc
>619d	81					.byte	$81		; $b2 : local
>619e	81					.byte	$81		; $b3 : let
>619f	81					.byte	$81		; $b4 : run
>61a0	81					.byte	$81		; $b5 : stop
>61a1	81					.byte	$81		; $b6 : end
>61a2	81					.byte	$81		; $b7 : print
>61a3	81					.byte	$81		; $b8 : input
>61a4	81					.byte	$81		; $b9 : when
>61a5	81					.byte	$81		; $ba : default
>61a6	81					.byte	$81		; $bb : option
>61a7	81					.byte	$81		; $bc : list
>61a8	81					.byte	$81		; $bd : load
>61a9	81					.byte	$81		; $be : save
>61aa	81					.byte	$81		; $bf : new
>61ab	81					.byte	$81		; $c0 : old
>61ac	81					.byte	$81		; $c1 : poke
>61ad	81					.byte	$81		; $c2 : doke
>61ae	81					.byte	$81		; $c3 : vpoke
>61af	81					.byte	$81		; $c4 : rem
>61b0	81					.byte	$81		; $c5 : goto
>61b1	81					.byte	$81		; $c6 : gosub
>61b2	81					.byte	$81		; $c7 : sys
>61b3	81					.byte	$81		; $c8 : return
>61b4	00					.byte	$00		; $c9 : )
>61b5	00					.byte	$00		; $ca : :

;******  Return to file: files.asm

.61b6					TokenVectors:

;******  Processing file: generated/tokenvectors.inc

>61b6	e4 65					.word	SyntaxError             		; $80 : (eol)
>61b8	ef 63					.word	BinaryAnd               		; $81 : and
>61ba	0d 64					.word	BinaryOr                		; $82 : or
>61bc	2b 64					.word	BinaryXor               		; $83 : xor
>61be	e4 65					.word	SyntaxError             		; $84 : >
>61c0	e4 65					.word	SyntaxError             		; $85 : >=
>61c2	e4 65					.word	SyntaxError             		; $86 : <
>61c4	e4 65					.word	SyntaxError             		; $87 : <=
>61c6	e4 65					.word	SyntaxError             		; $88 : =
>61c8	e4 65					.word	SyntaxError             		; $89 : <>
>61ca	b1 63					.word	BinaryAdd               		; $8a : +
>61cc	d0 63					.word	BinarySub               		; $8b : -
>61ce	49 64					.word	Multiply16x16           		; $8c : *
>61d0	8a 64					.word	Divide16x16             		; $8d : /
>61d2	99 64					.word	Modulus16x16            		; $8e : mod
>61d4	89 65					.word	StringLength            		; $8f : len(
>61d6	e4 65					.word	SyntaxError             		; $90 : rnd(
>61d8	e4 65					.word	SyntaxError             		; $91 : asc(
>61da	e4 65					.word	SyntaxError             		; $92 : chr$(
>61dc	e4 65					.word	SyntaxError             		; $93 : val(
>61de	e4 65					.word	SyntaxError             		; $94 : str$(
>61e0	e4 65					.word	SyntaxError             		; $95 : spc(
>61e2	e4 65					.word	SyntaxError             		; $96 : left$(
>61e4	e4 65					.word	SyntaxError             		; $97 : mid$(
>61e6	e4 65					.word	SyntaxError             		; $98 : right$(
>61e8	38 65					.word	AbsoluteValue           		; $99 : abs(
>61ea	54 65					.word	SignValue               		; $9a : sgn(
>61ec	e4 65					.word	SyntaxError             		; $9b : int(
>61ee	e4 65					.word	SyntaxError             		; $9c : deek(
>61f0	e4 65					.word	SyntaxError             		; $9d : peek(
>61f2	e4 65					.word	SyntaxError             		; $9e : vpeek(
>61f4	31 65					.word	Parenthesis             		; $9f : (
>61f6	2d 65					.word	Dummy_Binary            		; $a0 : %
>61f8	2d 65					.word	Dummy_Hex               		; $a1 : $
>61fa	e4 65					.word	SyntaxError             		; $a2 : if
>61fc	e4 65					.word	SyntaxError             		; $a3 : repeat
>61fe	e4 65					.word	SyntaxError             		; $a4 : for
>6200	e4 65					.word	SyntaxError             		; $a5 : while
>6202	e4 65					.word	SyntaxError             		; $a6 : case
>6204	e4 65					.word	SyntaxError             		; $a7 : then
>6206	e4 65					.word	SyntaxError             		; $a8 : endif
>6208	e4 65					.word	SyntaxError             		; $a9 : until
>620a	e4 65					.word	SyntaxError             		; $aa : next
>620c	e4 65					.word	SyntaxError             		; $ab : endwhile
>620e	e4 65					.word	SyntaxError             		; $ac : endcase
>6210	e4 65					.word	SyntaxError             		; $ad : to
>6212	e4 65					.word	SyntaxError             		; $ae : step
>6214	e4 65					.word	SyntaxError             		; $af : defproc
>6216	e4 65					.word	SyntaxError             		; $b0 : endproc
>6218	e4 65					.word	SyntaxError             		; $b1 : proc
>621a	e4 65					.word	SyntaxError             		; $b2 : local
>621c	e4 65					.word	SyntaxError             		; $b3 : let
>621e	e4 65					.word	SyntaxError             		; $b4 : run
>6220	e4 65					.word	SyntaxError             		; $b5 : stop
>6222	e4 65					.word	SyntaxError             		; $b6 : end
>6224	e4 65					.word	SyntaxError             		; $b7 : print
>6226	e4 65					.word	SyntaxError             		; $b8 : input
>6228	e4 65					.word	SyntaxError             		; $b9 : when
>622a	e4 65					.word	SyntaxError             		; $ba : default
>622c	e4 65					.word	SyntaxError             		; $bb : option
>622e	e4 65					.word	SyntaxError             		; $bc : list
>6230	e4 65					.word	SyntaxError             		; $bd : load
>6232	e4 65					.word	SyntaxError             		; $be : save
>6234	e4 65					.word	SyntaxError             		; $bf : new
>6236	e4 65					.word	SyntaxError             		; $c0 : old
>6238	e4 65					.word	SyntaxError             		; $c1 : poke
>623a	e4 65					.word	SyntaxError             		; $c2 : doke
>623c	e4 65					.word	SyntaxError             		; $c3 : vpoke
>623e	e4 65					.word	SyntaxError             		; $c4 : rem
>6240	e4 65					.word	SyntaxError             		; $c5 : goto
>6242	e4 65					.word	SyntaxError             		; $c6 : gosub
>6244	e4 65					.word	SyntaxError             		; $c7 : sys
>6246	e4 65					.word	SyntaxError             		; $c8 : return
>6248	e4 65					.word	SyntaxError             		; $c9 : )
>624a	e4 65					.word	SyntaxError             		; $ca : :

;******  Return to file: files.asm


;******  Processing file: generated/tokenconst.inc

=$80					TOK_LPARENEOLRPAREN = $80
=$81					TOK_AND = $81
=$82					TOK_OR = $82
=$83					TOK_XOR = $83
=$84					TOK_GREATER = $84
=$85					TOK_GREATEREQUAL = $85
=$86					TOK_LESS = $86
=$87					TOK_LESSEQUAL = $87
=$88					TOK_EQUAL = $88
=$89					TOK_LESSGREATER = $89
=$8a					TOK_PLUS = $8a
=$8b					TOK_MINUS = $8b
=$8c					TOK_STAR = $8c
=$8d					TOK_SLASH = $8d
=$8e					TOK_MOD = $8e
=$8f					TOK_LENLPAREN = $8f
=$90					TOK_RNDLPAREN = $90
=$91					TOK_ASCLPAREN = $91
=$92					TOK_CHRDOLLARLPAREN = $92
=$93					TOK_VALLPAREN = $93
=$94					TOK_STRDOLLARLPAREN = $94
=$95					TOK_SPCLPAREN = $95
=$96					TOK_LEFTDOLLARLPAREN = $96
=$97					TOK_MIDDOLLARLPAREN = $97
=$98					TOK_RIGHTDOLLARLPAREN = $98
=$99					TOK_ABSLPAREN = $99
=$9a					TOK_SGNLPAREN = $9a
=$9b					TOK_INTLPAREN = $9b
=$9c					TOK_DEEKLPAREN = $9c
=$9d					TOK_PEEKLPAREN = $9d
=$9e					TOK_VPEEKLPAREN = $9e
=$9f					TOK_LPAREN = $9f
=$a0					TOK_PERCENT = $a0
=$a1					TOK_DOLLAR = $a1
=$a2					TOK_IF = $a2
=$a3					TOK_REPEAT = $a3
=$a4					TOK_FOR = $a4
=$a5					TOK_WHILE = $a5
=$a6					TOK_CASE = $a6
=$a7					TOK_THEN = $a7
=$a8					TOK_ENDIF = $a8
=$a9					TOK_UNTIL = $a9
=$aa					TOK_NEXT = $aa
=$ab					TOK_ENDWHILE = $ab
=$ac					TOK_ENDCASE = $ac
=$ad					TOK_TO = $ad
=$ae					TOK_STEP = $ae
=$af					TOK_DEFPROC = $af
=$b0					TOK_ENDPROC = $b0
=$b1					TOK_PROC = $b1
=$b2					TOK_LOCAL = $b2
=$b3					TOK_LET = $b3
=$b4					TOK_RUN = $b4
=$b5					TOK_STOP = $b5
=$b6					TOK_END = $b6
=$b7					TOK_PRINT = $b7
=$b8					TOK_INPUT = $b8
=$b9					TOK_WHEN = $b9
=$ba					TOK_DEFAULT = $ba
=$bb					TOK_OPTION = $bb
=$bc					TOK_LIST = $bc
=$bd					TOK_LOAD = $bd
=$be					TOK_SAVE = $be
=$bf					TOK_NEW = $bf
=$c0					TOK_OLD = $c0
=$c1					TOK_POKE = $c1
=$c2					TOK_DOKE = $c2
=$c3					TOK_VPOKE = $c3
=$c4					TOK_REM = $c4
=$c5					TOK_GOTO = $c5
=$c6					TOK_GOSUB = $c6
=$c7					TOK_SYS = $c7
=$c8					TOK_RETURN = $c8
=$c9					TOK_RPAREN = $c9
=$ca					TOK_COLON = $ca

;******  Return to file: files.asm


;******  Processing file: code/syntax.asm

.624c					SyntaxCheckRightBracket:
.624c	b1 00		lda ($00),y			lda 	(codePtr),y
.624e	c8		iny				iny
.624f	c9 c9		cmp #$c9			cmp 	#TOK_RPAREN
.6251	d0 01		bne $6254			bne 	_SCRBError
.6253	60		rts				rts
.6254					_SCRBError:
.6254	20 e7 65	jsr $65e7			jsr 	ErrorHandler
>6257	4d 69 73 73 69 6e 67 20				.text 	"Missing )",0
>625f	29 00

;******  Return to file: files.asm


;******  Processing file: expression/evaluate.asm

.6261					EvaluateExpression:
.6261	a2 00		ldx #$00			ldx 	#0 							; reset the evaluation stack pointer in X
.6263					EvaluateExpressionAtX:
.6263	a9 10		lda #$10			lda 	#$10 						; this is the lowest precedence.
.6265					EvaluateExpressionAtXPrecA:
.6265	48		pha				pha 								; save lowest stack level.
.6266	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first term.
.6268	30 4f		bmi $62b9			bmi 	_EXAKeywordData 			; is it keyword, or data.
.626a	c9 60		cmp #$60			cmp 	#$60 						; is it a variable
.626c	90 46		bcc $62b4			bcc 	_EXAVariable
.626e	c8		iny				iny 								; skip over the short constant
.626f	29 1f		and #$1f			and 	#$1F 						; short constant $00-$1F
.6271	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and put as an integer
.6274	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.6277	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; integer, number, not a reference.
.627a					_EXAHaveTerm:
.627a	68		pla				pla 	 							; restore current precedence and save in zTemp1
.627b	85 02		sta $02				sta 	zTemp1
.627d	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by a binary operation.
.627f	da		phx				phx
.6280	aa		tax				tax
.6281	bd eb 60	lda $60eb,x			lda 	TokenControlByteTable-$80,x ; get the control byte.
.6284	fa		plx				plx
.6285	c9 20		cmp #$20			cmp 	#$20 						; must be $10-$17 (or possibly $00, will be < precedence)
.6287	b0 06		bcs $628f			bcs 	_EXAExit
.6289	c5 02		cmp $02				cmp 	zTemp1 						; check against current precedence.
.628b	f0 02		beq $628f			beq 	_EXAExit
.628d	b0 01		bcs $6290			bcs		_EXABinaryOp 				; if >, do a binary operation.
.628f					_EXAExit:
.628f	60		rts				rts 								; exit expression evaluation.
.6290					_EXABinaryOp:
.6290	85 03		sta $03				sta 	zTemp1+1 					; save operator.
.6292	a5 02		lda $02				lda 	zTemp1 						; get and save current precedence
.6294	48		pha				pha
.6295	b1 00		lda ($00),y			lda 	(codePtr),y 				; push binary operator on stack
.6297	48		pha				pha
.6298	c8		iny				iny 								; and skip over it.
.6299	e8		inx				inx 								; calculate the RHS in the next slot up.
.629a	a5 03		lda $03				lda 	zTemp1+1 					; at operator precedence level.
.629c	20 65 62	jsr $6265			jsr 	EvaluateExpressionAtXPrecA
.629f	ca		dex				dex
.62a0	68		pla				pla 								; get binary operator.
.62a1	da		phx				phx 								; save stack depth.
.62a2	0a		asl a				asl 	a 							; double binary operator and put into X, loses MSB
.62a3	aa		tax				tax
.62a4	bd b6 61	lda $61b6,x			lda 	TokenVectors,x 				; get address => zTemp2
.62a7	85 04		sta $04				sta 	zTemp2
.62a9	bd b7 61	lda $61b7,x			lda 	TokenVectors+1,x
.62ac	85 05		sta $05				sta 	zTemp2+1
.62ae	fa		plx				plx 								; restore stack depth.
.62af	20 2e 63	jsr $632e			jsr 	_EXACallZTemp2 				; call the routine
.62b2	80 c6		bra $627a			bra 	_EXAHaveTerm 				; and loop round again.
.62b4					_EXAVariable:
.62b4	20 bf 65	jsr $65bf			jsr 	VariableLookup 				; look up the variable value perhaps creating it.
.62b7	80 c1		bra $627a			bra 	_EXAHaveTerm 				; and carry on with the expression
.62b9					_EXAKeywordData:
.62b9	c9 8b		cmp #$8b			cmp 	#TOK_MINUS 					; special case as - is unary and binary operator.
.62bb	d0 09		bne $62c6			bne 	_EXANotNegate
.62bd	c8		iny				iny
.62be	20 63 62	jsr $6263			jsr 	EvaluateExpressionAtX 		; the term
.62c1	20 19 65	jsr $6519			jsr 	IntegerNegate 				; negate it
.62c4	80 b4		bra $627a			bra 	_EXAHaveTerm 				; and loop back.
.62c6					_EXANotNegate:
.62c6	c9 f8		cmp #$f8			cmp 	#$F8 						; $80-$F8 are unary functions
.62c8	90 45		bcc $630f			bcc 	_EXAUnaryFunction
.62ca	c9 fb		cmp #$fb			cmp 	#$FB 						; $FB is a string.
.62cc	f0 25		beq $62f3			beq 	_EXAString
.62ce	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; it is now either $FE (short int) or $FF (long int)
.62d1	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.62d4	48		pha				pha 								; save identifier
.62d5	c8		iny				iny 								; do the low byte
.62d6	b1 00		lda ($00),y			lda 	(codePtr),y
.62d8	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.62db	c8		iny				iny
.62dc	68		pla				pla 								; get identifier
.62dd	c9 fe		cmp #$fe			cmp 	#$FE  						; if short then done.
.62df	f0 99		beq $627a			beq 	_EXAHaveTerm
.62e1	c9 ff		cmp #$ff			cmp 	#$FF 						; should be $FF
.62e3	d0 08		bne $62ed			bne 	_EXACrash
.62e5	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy high byte
.62e7	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.62ea	c8		iny				iny
.62eb	80 8d		bra $627a			bra 	_EXAHaveTerm
.62ed					_EXACrash:
.62ed	20 e7 65	jsr $65e7			jsr 	ErrorHandler
>62f0	23 58 00					.text 	"#X",0
.62f3					_EXAString:
.62f3	c8		iny				iny 								; point to string length, which is the string start.
.62f4	98		tya				tya 								; work out the physical address of the string
.62f5	18		clc				clc
.62f6	65 00		adc $00				adc 	codePtr
.62f8	9d 20 06	sta $0620,x			sta 	xsAddrLow,x
.62fb	a5 01		lda $01				lda 	codePtr+1
.62fd	69 00		adc #$00			adc 	#0
.62ff	9d 40 06	sta $0640,x			sta 	xsAddrHigh,x
.6302	a9 40		lda #$40			lda 	#$40 						; set the type to string
.6304	9d 00 06	sta $0600,x			sta 	xsStatus,x
.6307	98		tya				tya 								; add the length to the current position
.6308	38		sec				sec 								; +1 for the length byte itself.
.6309	71 00		adc ($00),y			adc 	(codePtr),y
.630b	a8		tay				tay
.630c	4c 7a 62	jmp $627a			jmp 	_EXAHaveTerm
.630f					_EXAUnaryFunction:
.630f	da		phx				phx 								; get the table entry to check it is a unary function
.6310	aa		tax				tax
.6311	3c eb 60	bit $60eb,x			bit 	TokenControlByteTable-$80,x ; if bit 6 is not set, it's not a unary function.
.6314	50 15		bvc $632b			bvc 	_EXANotUnaryFunction
.6316	8a		txa				txa 								; now copy the routine address, put token x 2 in.
.6317	0a		asl a				asl 	a
.6318	aa		tax				tax
.6319	bd b6 61	lda $61b6,x			lda 	TokenVectors,x 				; get address => zTemp2
.631c	85 04		sta $04				sta 	zTemp2
.631e	bd b7 61	lda $61b7,x			lda 	TokenVectors+1,x
.6321	85 05		sta $05				sta 	zTemp2+1
.6323	fa		plx				plx 								; restore stack depth.
.6324	c8		iny				iny 								; skip unary function token.
.6325	20 2e 63	jsr $632e			jsr 	_EXACallZTemp2 				; call the routine
.6328	4c 7a 62	jmp $627a			jmp 	_EXAHaveTerm 				; and loop round again.
.632b					_EXANotUnaryFunction:
.632b	4c e4 65	jmp $65e4			jmp 	SyntaxError
.632e					_EXACallZTemp2:
.632e	6c 04 00	jmp ($0004)			jmp 	(zTemp2)

;******  Return to file: files.asm


;******  Processing file: expression/exprutils.asm

.6331					EvaluateTermAtX:
.6331	a9 1f		lda #$1f			lda 	#$1F 						; too high precedence so just term
.6333	20 65 62	jsr $6265			jsr 	EvaluateExpressionAtXPrecA
.6336	60		rts				rts
.6337					DeReferenceBinary:
.6337	e8		inx				inx
.6338	20 3c 63	jsr $633c			jsr 	DeReferenceUnary
.633b	ca		dex				dex
.633c					DeReferenceUnary:
.633c	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; the reference flag is in bit 0
.633f	6a		ror a				ror 	a 							; shift into carry.
.6340	90 33		bcc $6375			bcc 	_DRNotReference 			; if clear, it's already a reference.
.6342	0a		asl a				asl 	a 							; get back, but with bit 0 cleared
.6343	9d 00 06	sta $0600,x			sta 	xsStatus,x
.6346	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put the address to dereference into zTemp1
.6349	85 02		sta $02				sta 	zTemp1
.634b	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.634e	85 03		sta $03				sta 	zTemp1+1
.6350	5a		phy				phy 								; save position in code
.6351	b2 02		lda ($02)			lda 	(zTemp1) 					; dereference the first two bytes - this will be
.6353	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; for float, int and string, and will go in these
.6356	a0 01		ldy #$01			ldy 	#1 							; which are also the address, and mantissa3 & 2
.6358	b1 02		lda ($02),y			lda 	(zTemp1),y
.635a	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.635d	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; check if it's a float (bit 7)
.6360	10 12		bpl $6374			bpl 	_DRNotFloat 				; if not, we are complete
.6362	c8		iny				iny 								; if float, copy all five bytes of the floating point
.6363	b1 02		lda ($02),y			lda 	(zTemp1),y 					; number into the stack.
.6365	9d 60 06	sta $0660,x			sta 	xsMantissa1,x
.6368	c8		iny				iny
.6369	b1 02		lda ($02),y			lda 	(zTemp1),y
.636b	9d 80 06	sta $0680,x			sta 	xsMantissa0,x
.636e	c8		iny				iny
.636f	b1 02		lda ($02),y			lda 	(zTemp1),y
.6371	9d a0 06	sta $06a0,x			sta 	xsExponent,x
.6374					_DRNotFloat:
.6374	7a		ply				ply 								; restore code position.
.6375					_DRNotReference:
.6375	60		rts				rts
.6376					UnaryNumberTypeCheck:
.6376	bd 00 06	lda $0600,x			lda 	xsStatus,x
.6379	80 06		bra $6381			bra 	BNTCMain
.637b					BinaryNumberTypeCheck:
.637b	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; bit 7 set if either float, bit 6 set if either string.
.637e	1d 01 06	ora $0601,x			ora 	xsStatus+1,x
.6381					BNTCMain:
.6381	0a		asl a				asl 	a 							; carry set if either float, bit 7 set if either string
.6382	30 01		bmi $6385			bmi 	_NTCError 					; so fail if string, we want int
.6384	60		rts				rts
.6385					_NTCError:
.6385	20 e7 65	jsr $65e7			jsr 	ErrorHandler
>6388	4e 75 6d 62 65 72 20 65				.text 	"Number expected",0
>6390	78 70 65 63 74 65 64 00
.6398					UnaryStringTypeCheck:
.6398	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; check if string
.639b	50 01		bvc $639e			bvc 	_STCError
.639d	60		rts				rts
.639e					_STCError:
.639e	20 e7 65	jsr $65e7			jsr 	ErrorHandler
>63a1	53 74 72 69 6e 67 20 65				.text 	"String expected",0
>63a9	78 70 65 63 74 65 64 00

;******  Return to file: files.asm


;******  Processing file: expression/integer/arithmetic.asm

.63b1					BinaryAdd:
.63b1	20 37 63	jsr $6337			jsr 	DeReferenceBinary 			; convert references to values
.63b4	20 7b 63	jsr $637b			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.63b7	90 03		bcc $63bc			bcc 	_Integer
.63b9	4c ac 65	jmp $65ac			jmp 	FPAdd
.63bc					_Integer:
.63bc	18		clc				clc
.63bd	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.63c0	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.63c3	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.63c6	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.63c9	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.63cc	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.63cf	60		rts				rts
.63d0					BinarySub:
.63d0	20 37 63	jsr $6337			jsr 	DeReferenceBinary 			; convert references to values
.63d3	20 7b 63	jsr $637b			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.63d6	90 03		bcc $63db			bcc 	_Integer
.63d8	4c ac 65	jmp $65ac			jmp 	FPSub
.63db					_Integer:
.63db	38		sec				sec
.63dc	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.63df	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.63e2	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.63e5	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.63e8	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.63eb	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.63ee	60		rts				rts
.63ef					BinaryAnd:
.63ef	20 37 63	jsr $6337			jsr 	DeReferenceBinary 			; convert references to values
.63f2	20 7b 63	jsr $637b			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.63f5	90 03		bcc $63fa			bcc 	_Integer
.63f7	20 ac 65	jsr $65ac			jsr 	FPFloatToInteger
.63fa					_Integer:
.63fa	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.63fd	3d 21 06	and $0621,x			and 	xsIntLow+1,x
.6400	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6403	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6406	3d 41 06	and $0641,x			and 	xsIntHigh+1,x
.6409	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.640c	60		rts				rts
.640d					BinaryOr:
.640d	20 37 63	jsr $6337			jsr 	DeReferenceBinary 			; convert references to values
.6410	20 7b 63	jsr $637b			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.6413	90 03		bcc $6418			bcc 	_Integer
.6415	20 ac 65	jsr $65ac			jsr 	FPFloatToInteger
.6418					_Integer:
.6418	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.641b	1d 21 06	ora $0621,x			ora 	xsIntLow+1,x
.641e	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6421	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6424	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.6427	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.642a	60		rts				rts
.642b					BinaryXor:
.642b	20 37 63	jsr $6337			jsr 	DeReferenceBinary 			; convert references to values
.642e	20 7b 63	jsr $637b			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.6431	90 03		bcc $6436			bcc 	_Integer
.6433	20 ac 65	jsr $65ac			jsr 	FPFloatToInteger
.6436					_Integer:
.6436	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.6439	5d 21 06	eor $0621,x			eor 	xsIntLow+1,x
.643c	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.643f	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6442	5d 41 06	eor $0641,x			eor 	xsIntHigh+1,x
.6445	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.6448	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/multiply.asm

.6449					Multiply16x16:
.6449	20 37 63	jsr $6337			jsr 	DeReferenceBinary 			; convert references to values
.644c	20 7b 63	jsr $637b			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.644f	90 03		bcc $6454			bcc 	_Integer
.6451	4c ac 65	jmp $65ac			jmp 	FPMultiply
.6454					_Integer:
.6454	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; 1st value to zTemp1
.6457	85 04		sta $04				sta 	zTemp2
.6459	bd 40 06	lda $0640,x			lda		xsIntHigh,x
.645c	85 05		sta $05				sta 	zTemp2+1
.645e	9e 20 06	stz $0620,x			stz 	xsIntLow,x 					; zero 1st on stack
.6461	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.6464					_MultLoop:
.6464	46 05		lsr $05				lsr 	zTemp2+1 					; ror zTemp2 into C
.6466	66 04		ror $04				ror 	zTemp2
.6468	90 13		bcc $647d			bcc 	_MultNoAdd
.646a	18		clc				clc 								; add 2nd to 1st.
.646b	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.646e	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.6471	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6474	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.6477	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.647a	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.647d					_MultNoAdd:
.647d	1e 21 06	asl $0621,x			asl 	xsIntLow+1,x 				; shift 2nd left
.6480	3e 41 06	rol $0641,x			rol 	xsIntHigh+1,x
.6483	a5 04		lda $04				lda 	zTemp2	 					; until multiplier is zero
.6485	05 05		ora $05				ora 	zTemp2+1
.6487	d0 db		bne $6464			bne 	_MultLoop
.6489	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/divide.asm

.648a					Divide16x16:
.648a	20 37 63	jsr $6337			jsr 	DeReferenceBinary 			; convert references to values
.648d	20 7b 63	jsr $637b			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.6490	90 03		bcc $6495			bcc 	_Integer
.6492	4c ac 65	jmp $65ac			jmp 	FPDivide
.6495					_Integer:
.6495	20 b2 64	jsr $64b2			jsr 	IntegerDivide
.6498	60		rts				rts
.6499					Modulus16x16:
.6499	20 37 63	jsr $6337			jsr 	DeReferenceBinary 			; convert references to values
.649c	20 7b 63	jsr $637b			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.649f	90 03		bcc $64a4			bcc 	_Integer
.64a1	4c ac 65	jmp $65ac			jmp 	FPModulus
.64a4					_Integer:
.64a4	20 b2 64	jsr $64b2			jsr 	IntegerDivide
.64a7	a5 02		lda $02				lda 	zTemp1
.64a9	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.64ac	a5 03		lda $03				lda 	zTemp1+1
.64ae	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.64b1	60		rts				rts
.64b2					IntegerDivide:
.64b2	bd 21 06	lda $0621,x			lda 	xsIntLow+1,x 				; check for division by zero.
.64b5	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.64b8	d0 14		bne $64ce			bne 	_BFDOkay
.64ba	20 e7 65	jsr $65e7			jsr 	ErrorHandler
>64bd	44 69 76 69 73 69 6f 6e				.text 	"Division by Zero",0
>64c5	20 62 79 20 5a 65 72 6f 00
.64ce					_BFDOkay:
.64ce	64 02		stz $02				stz 	zTemp1 						; Q/Dividend/Left in +0
.64d0	64 03		stz $03				stz 	zTemp1+1 					; M/Divisor/Right in +1
.64d2	64 0a		stz $0a				stz 	SignCount 					; Count of signs.
.64d4	20 13 65	jsr $6513			jsr 	CheckIntegerNegate 			; negate 1st (and bump sign count)
.64d7	e8		inx				inx
.64d8	20 13 65	jsr $6513			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.64db	ca		dex				dex
.64dc	5a		phy				phy 								; Y is the counter, save position
.64dd	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.64df					_BFDLoop:
.64df	1e 20 06	asl $0620,x			asl 	xsIntLow,x 					; shift AQ left.
.64e2	3e 40 06	rol $0640,x			rol 	xsIntHigh,x
.64e5	26 02		rol $02				rol 	zTemp1
.64e7	26 03		rol $03				rol 	zTemp1+1
.64e9	38		sec				sec
.64ea	a5 02		lda $02				lda 	zTemp1+0 					; Calculate A-M on stack.
.64ec	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.64ef	48		pha				pha
.64f0	a5 03		lda $03				lda 	zTemp1+1
.64f2	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.64f5	90 0f		bcc $6506			bcc 	_BFDNoAdd
.64f7	85 03		sta $03				sta 	zTemp1+1
.64f9	68		pla				pla
.64fa	85 02		sta $02				sta 	zTemp1+0
.64fc	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; set Q bit 1.
.64ff	09 01		ora #$01			ora 	#1
.6501	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6504	80 01		bra $6507			bra 	_BFDNext
.6506					_BFDNoAdd:
.6506	68		pla				pla 								; Throw away the intermediate calculations
.6507					_BFDNext:
.6507	88		dey				dey
.6508	d0 d5		bne $64df			bne 	_BFDLoop
.650a	7a		ply				ply 								; restore Y
.650b	46 0a		lsr $0a				lsr 	SignCount 					; if sign count odd,
.650d	90 03		bcc $6512			bcc 	_BFDUnsigned 				; then the result is signed
.650f	20 19 65	jsr $6519			jsr		IntegerNegate 				; negate the result
.6512					_BFDUnsigned:
.6512	60		rts				rts
.6513					CheckIntegerNegate:
.6513	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; is it -ve = MSB set ?
.6516	30 01		bmi $6519			bmi 	IntegerNegate 				; if so negate it
.6518	60		rts				rts
.6519					IntegerNegate:
.6519	e6 0a		inc $0a				inc 	SignCount 					; bump the count of signs
.651b	38		sec				sec 								; negate
.651c	a9 00		lda #$00			lda 	#0
.651e	fd 20 06	sbc $0620,x			sbc 	xsIntLow,x
.6521	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6524	a9 00		lda #$00			lda 	#0
.6526	fd 40 06	sbc $0640,x			sbc 	xsIntHigh,x
.6529	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.652c	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/unary.asm

.652d					Dummy_Binary:
.652d					Dummy_Hex:
.652d	20 31 63	jsr $6331			jsr 	EvaluateTermAtX
.6530	60		rts				rts
.6531					Parenthesis:
.6531	20 63 62	jsr $6263			jsr 	EvaluateExpressionAtX 		; parenthesised expression
.6534	20 4c 62	jsr $624c			jsr 	SyntaxCheckRightBracket 	; check followed by )
.6537	60		rts				rts
.6538					AbsoluteValue:
.6538	20 63 62	jsr $6263			jsr 	EvaluateExpressionAtX 		; evaluate the term
.653b	20 3c 63	jsr $633c			jsr 	DeReferenceUnary 			; convert term to value if reference.
.653e	20 76 63	jsr $6376			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.6541	90 03		bcc $6546			bcc 	_Integer
.6543	4c 4d 65	jmp $654d			jmp 	AVFloat
.6546					_Integer:
.6546	20 13 65	jsr $6513			jsr 	CheckIntegerNegate 			; use absolute value in divide
.6549	20 4c 62	jsr $624c			jsr 	SyntaxCheckRightBracket
.654c	60		rts				rts
.654d					AVFloat:
.654d	20 ac 65	jsr $65ac			jsr 	FPAbs
.6550	20 4c 62	jsr $624c			jsr 	SyntaxCheckRightBracket
.6553	60		rts				rts
.6554					SignValue:
.6554	20 63 62	jsr $6263			jsr 	EvaluateExpressionAtX 		; evaluate the term
.6557	20 3c 63	jsr $633c			jsr 	DeReferenceUnary 			; convert term to value if reference.
.655a	20 76 63	jsr $6376			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.655d	90 03		bcc $6562			bcc 	_Integer
.655f	4c 82 65	jmp $6582			jmp 	SVFloat
.6562					_Integer:
.6562	20 4c 62	jsr $624c			jsr 	SyntaxCheckRightBracket
.6565	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; Check zero
.6568	1d 20 06	ora $0620,x			ora 	xsIntLow,x
.656b	f0 05		beq $6572			beq 	_SVSetLH
.656d	0a		asl a				asl 	a 							; msb into carry
.656e	90 09		bcc $6579			bcc 	_SVGreater0 				; if CC then it's positive and non zero
.6570	a9 ff		lda #$ff			lda 	#$FF 						; -ve so return -1
.6572					_SVSetLH:
.6572	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.6575	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.6578	60		rts				rts
.6579					_SVGreater0:
.6579	a9 01		lda #$01			lda 	#1
.657b	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.657e	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.6581	60		rts				rts
.6582					SVFloat:
.6582	20 ac 65	jsr $65ac			jsr 	FPSgn
.6585	20 4c 62	jsr $624c			jsr 	SyntaxCheckRightBracket
.6588	60		rts				rts
.6589					StringLength:
>6589	ff						.byte 	$FF
.658a	20 63 62	jsr $6263			jsr 	EvaluateExpressionAtX 		; evaluate the term
.658d	20 3c 63	jsr $633c			jsr 	DeReferenceUnary 			; convert term to value if reference.
.6590	20 98 63	jsr $6398			jsr 	UnaryStringTypeCheck 		; check string.
.6593	20 4c 62	jsr $624c			jsr 	SyntaxCheckRightBracket
.6596	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put address of string into zTemp1
.6599	85 02		sta $02				sta 	zTemp1
.659b	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.659e	85 03		sta $03				sta 	zTemp1+1
.65a0	b2 02		lda ($02)			lda 	(zTemp1)					; get the length (strings are len prefixed)
.65a2	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and return it
.65a5	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.65a8	9e 00 06	stz $0600,x			stz 	xsStatus,x
.65ab	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/float/floatdummy.asm

.65ac					FPAdd:
.65ac					FPSub:
.65ac					FPMultiply:
.65ac					FPDivide:
.65ac					FPModulus:
.65ac					FPAbs:
.65ac					FPSgn:
.65ac					FPFloatToInteger:
.65ac					FPIntegerToFloat:
.65ac	20 e7 65	jsr $65e7			jsr 	ErrorHandler
>65af	4e 6f 74 20 49 6d 70 6c				.text 	"Not Implemented",0
>65b7	65 6d 65 6e 74 65 64 00

;******  Return to file: files.asm


;******  Processing file: variables/variable.asm

.65bf					VariableLookup:
.65bf	20 e7 65	jsr $65e7			jsr 	ErrorHandler
>65c2	3f 49 4d 50 00					.text 	"?IMP",0

;******  Return to file: files.asm


;******  Return to file: basic.asm

.65c7					ColdStart:
.65c7	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.65c9	9a		txs				txs
.65ca	a9 da		lda #$da			lda 	#(TestProgram) & $FF
.65cc	85 00		sta $00				sta 	0+(codePtr)
.65ce	a9 65		lda #$65			lda 	#(TestProgram) >> 8
.65d0	85 01		sta $01				sta 	1+(codePtr)
.65d2	a0 00		ldy #$00			ldy 	#0
.65d4	20 61 62	jsr $6261			jsr 	EvaluateExpression
.65d7	4c ff ff	jmp $ffff			jmp 	$FFFF
.65da					TestProgram:

;******  Processing file: generated/testcode.inc

>65da	8f fb 05 48 65 6c 6c 6f			.byte	$8f,$fb,$05,$48,$65,$6c,$6c,$6f,$c9
>65e2	c9

;******  Return to file: basic.asm

>65e3	80						.byte 	$80
.65e4					SyntaxError:
.65e4	a2 5e		ldx #$5e			ldx 	#$5E
>65e6	ff						.byte 	$FF
.65e7					ErrorHandler:
>65e7	ff						.byte 	$FF
.65e8	a2 ee		ldx #$ee			ldx 	#$EE

;******  End of listing
