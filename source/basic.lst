
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o basic_nocode.prg -L basic.lst -l basic.lbl basic.asm
; Sat Feb 08 19:20:13 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: code/data.asm

.0000					codePtr:
>0000							.word 	?
.0002					structSP:
>0002							.byte 	?
.0003					zTemp1:
>0003							.word 	?
.0005					zTemp2:
>0005							.word 	?
.0007					zTemp3:
>0007							.word 	?
.0009					zTemp4:
>0009							.word 	?
.000b					signCount:
>000b							.byte 	?
.000c					convertPtr:
>000c							.byte 	?
.000d					randomSeed:
>000d							.word 	?
=$600					xsStatus = $600								; expression stack (must all fit in one page)
=$20					stackSize = $20 							; stack elements allowed (max 256/6)
=1568					xsAddrLow = xsStatus+stackSize 				; these values are shared depending on type.
=1600					xsAddrHigh = xsStatus+stackSize*2
=1568					xsIntLow = xsAddrLow
=1600					xsIntHigh = xsAddrHigh
=1568					xsMantissa3 = xsAddrLow
=1600					xsMantissa2 = xsAddrHigh
=1632					xsMantissa1 = xsStatus+stackSize*3
=1664					xsMantissa0 = xsStatus+stackSize*4
=1696					xsExponent = xsStatus+stackSize*5
=$700					variables = $700							; 26 variables A-Z. Must be on a page boundary.
=$780					structStack = $780 							; structure stack.
=$800					textBuffer = $800							; text buffer for input command lines.
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: basic.asm


;******  Processing file: code/macros.asm


;******  Return to file: basic.asm

.1000	4c 4d 1b	jmp $1b4d			jmp 	ColdStart

;******  Processing file: files.asm

.1003					TokenTextTable:

;******  Processing file: generated/tokentext.inc

>1003	05 28 45 4f 4c a9			.byte	$05,$28,$45,$4f,$4c,$a9                  ; $80 : (eol)
>1009	01 a9					.byte	$01,$a9                                  ; $81 : )
>100b	01 ba					.byte	$01,$ba                                  ; $82 : :
>100d	01 ac					.byte	$01,$ac                                  ; $83 : ,
>100f	01 bb					.byte	$01,$bb                                  ; $84 : ;
>1011	01 a3					.byte	$01,$a3                                  ; $85 : #
>1013	03 41 4e c4				.byte	$03,$41,$4e,$c4                          ; $86 : and
>1017	02 4f d2				.byte	$02,$4f,$d2                              ; $87 : or
>101a	03 58 4f d2				.byte	$03,$58,$4f,$d2                          ; $88 : xor
>101e	01 be					.byte	$01,$be                                  ; $89 : >
>1020	02 3e bd				.byte	$02,$3e,$bd                              ; $8a : >=
>1023	01 bc					.byte	$01,$bc                                  ; $8b : <
>1025	02 3c bd				.byte	$02,$3c,$bd                              ; $8c : <=
>1028	01 bd					.byte	$01,$bd                                  ; $8d : =
>102a	02 3c be				.byte	$02,$3c,$be                              ; $8e : <>
>102d	01 ab					.byte	$01,$ab                                  ; $8f : +
>102f	01 ad					.byte	$01,$ad                                  ; $90 : -
>1031	01 aa					.byte	$01,$aa                                  ; $91 : *
>1033	01 af					.byte	$01,$af                                  ; $92 : /
>1035	03 4d 4f c4				.byte	$03,$4d,$4f,$c4                          ; $93 : mod
>1039	04 4c 45 4e a8				.byte	$04,$4c,$45,$4e,$a8                      ; $94 : len(
>103e	04 52 4e 44 a8				.byte	$04,$52,$4e,$44,$a8                      ; $95 : rnd(
>1043	04 41 53 43 a8				.byte	$04,$41,$53,$43,$a8                      ; $96 : asc(
>1048	05 43 48 52 24 a8			.byte	$05,$43,$48,$52,$24,$a8                  ; $97 : chr$(
>104e	04 56 41 4c a8				.byte	$04,$56,$41,$4c,$a8                      ; $98 : val(
>1053	05 53 54 52 24 a8			.byte	$05,$53,$54,$52,$24,$a8                  ; $99 : str$(
>1059	04 53 50 43 a8				.byte	$04,$53,$50,$43,$a8                      ; $9a : spc(
>105e	06 4c 45 46 54 24 a8			.byte	$06,$4c,$45,$46,$54,$24,$a8              ; $9b : left$(
>1065	05 4d 49 44 24 a8			.byte	$05,$4d,$49,$44,$24,$a8                  ; $9c : mid$(
>106b	07 52 49 47 48 54 24 a8			.byte	$07,$52,$49,$47,$48,$54,$24,$a8          ; $9d : right$(
>1073	04 41 42 53 a8				.byte	$04,$41,$42,$53,$a8                      ; $9e : abs(
>1078	04 53 47 4e a8				.byte	$04,$53,$47,$4e,$a8                      ; $9f : sgn(
>107d	04 49 4e 54 a8				.byte	$04,$49,$4e,$54,$a8                      ; $a0 : int(
>1082	07 52 41 4e 44 4f 4d a8			.byte	$07,$52,$41,$4e,$44,$4f,$4d,$a8          ; $a1 : random(
>108a	05 44 45 45 4b a8			.byte	$05,$44,$45,$45,$4b,$a8                  ; $a2 : deek(
>1090	05 50 45 45 4b a8			.byte	$05,$50,$45,$45,$4b,$a8                  ; $a3 : peek(
>1096	06 56 50 45 45 4b a8			.byte	$06,$56,$50,$45,$45,$4b,$a8              ; $a4 : vpeek(
>109d	01 a8					.byte	$01,$a8                                  ; $a5 : (
>109f	01 a5					.byte	$01,$a5                                  ; $a6 : %
>10a1	01 a4					.byte	$01,$a4                                  ; $a7 : $
>10a3	02 49 c6				.byte	$02,$49,$c6                              ; $a8 : if
>10a6	06 52 45 50 45 41 d4			.byte	$06,$52,$45,$50,$45,$41,$d4              ; $a9 : repeat
>10ad	03 46 4f d2				.byte	$03,$46,$4f,$d2                          ; $aa : for
>10b1	05 57 48 49 4c c5			.byte	$05,$57,$48,$49,$4c,$c5                  ; $ab : while
>10b7	04 43 41 53 c5				.byte	$04,$43,$41,$53,$c5                      ; $ac : case
>10bc	04 54 48 45 ce				.byte	$04,$54,$48,$45,$ce                      ; $ad : then
>10c1	05 45 4e 44 49 c6			.byte	$05,$45,$4e,$44,$49,$c6                  ; $ae : endif
>10c7	05 55 4e 54 49 cc			.byte	$05,$55,$4e,$54,$49,$cc                  ; $af : until
>10cd	04 4e 45 58 d4				.byte	$04,$4e,$45,$58,$d4                      ; $b0 : next
>10d2	08 45 4e 44 57 48 49 4c			.byte	$08,$45,$4e,$44,$57,$48,$49,$4c,$c5      ; $b1 : endwhile
>10da	c5
>10db	07 45 4e 44 43 41 53 c5			.byte	$07,$45,$4e,$44,$43,$41,$53,$c5          ; $b2 : endcase
>10e3	02 54 cf				.byte	$02,$54,$cf                              ; $b3 : to
>10e6	04 53 54 45 d0				.byte	$04,$53,$54,$45,$d0                      ; $b4 : step
>10eb	04 50 52 4f c3				.byte	$04,$50,$52,$4f,$c3                      ; $b5 : proc
>10f0	07 45 4e 44 50 52 4f c3			.byte	$07,$45,$4e,$44,$50,$52,$4f,$c3          ; $b6 : endproc
>10f8	04 43 41 4c cc				.byte	$04,$43,$41,$4c,$cc                      ; $b7 : call
>10fd	05 4c 4f 43 41 cc			.byte	$05,$4c,$4f,$43,$41,$cc                  ; $b8 : local
>1103	03 52 55 ce				.byte	$03,$52,$55,$ce                          ; $b9 : run
>1107	04 53 54 4f d0				.byte	$04,$53,$54,$4f,$d0                      ; $ba : stop
>110c	03 45 4e c4				.byte	$03,$45,$4e,$c4                          ; $bb : end
>1110	05 50 52 49 4e d4			.byte	$05,$50,$52,$49,$4e,$d4                  ; $bc : print
>1116	05 49 4e 50 55 d4			.byte	$05,$49,$4e,$50,$55,$d4                  ; $bd : input
>111c	04 57 48 45 ce				.byte	$04,$57,$48,$45,$ce                      ; $be : when
>1121	07 44 45 46 41 55 4c d4			.byte	$07,$44,$45,$46,$41,$55,$4c,$d4          ; $bf : default
>1129	03 4c 45 d4				.byte	$03,$4c,$45,$d4                          ; $c0 : let
>112d	06 4f 50 54 49 4f ce			.byte	$06,$4f,$50,$54,$49,$4f,$ce              ; $c1 : option
>1134	04 4c 49 53 d4				.byte	$04,$4c,$49,$53,$d4                      ; $c2 : list
>1139	04 4c 4f 41 c4				.byte	$04,$4c,$4f,$41,$c4                      ; $c3 : load
>113e	04 53 41 56 c5				.byte	$04,$53,$41,$56,$c5                      ; $c4 : save
>1143	03 4e 45 d7				.byte	$03,$4e,$45,$d7                          ; $c5 : new
>1147	03 4f 4c c4				.byte	$03,$4f,$4c,$c4                          ; $c6 : old
>114b	04 50 4f 4b c5				.byte	$04,$50,$4f,$4b,$c5                      ; $c7 : poke
>1150	04 44 4f 4b c5				.byte	$04,$44,$4f,$4b,$c5                      ; $c8 : doke
>1155	05 56 50 4f 4b c5			.byte	$05,$56,$50,$4f,$4b,$c5                  ; $c9 : vpoke
>115b	03 52 45 cd				.byte	$03,$52,$45,$cd                          ; $ca : rem
>115f	04 47 4f 54 cf				.byte	$04,$47,$4f,$54,$cf                      ; $cb : goto
>1164	05 47 4f 53 55 c2			.byte	$05,$47,$4f,$53,$55,$c2                  ; $cc : gosub
>116a	03 53 59 d3				.byte	$03,$53,$59,$d3                          ; $cd : sys
>116e	06 52 45 54 55 52 ce			.byte	$06,$52,$45,$54,$55,$52,$ce              ; $ce : return
>1175	06 41 53 53 45 52 d4			.byte	$06,$41,$53,$53,$45,$52,$d4              ; $cf : assert
>117c	02 4f ce				.byte	$02,$4f,$ce                              ; $d0 : on
>117f	04 4f 50 45 ce				.byte	$04,$4f,$50,$45,$ce                      ; $d1 : open
>1184	05 43 4c 4f 53 c5			.byte	$05,$43,$4c,$4f,$53,$c5                  ; $d2 : close
>118a	03 44 49 d2				.byte	$03,$44,$49,$d2                          ; $d3 : dir
>118e	03 44 49 cd				.byte	$03,$44,$49,$cd                          ; $d4 : dim
>1192	04 52 45 41 c4				.byte	$04,$52,$45,$41,$c4                      ; $d5 : read
>1197	04 44 41 54 c1				.byte	$04,$44,$41,$54,$c1                      ; $d6 : data
>119c	07 52 45 53 54 4f 52 c5			.byte	$07,$52,$45,$53,$54,$4f,$52,$c5          ; $d7 : restore
>11a4	00					.byte	$00

;******  Return to file: files.asm

.11a5					TokenControlByteTable:

;******  Processing file: generated/tokencbyte.inc

>11a5	00					.byte	$00		; $80 : (eol)
>11a6	00					.byte	$00		; $81 : )
>11a7	00					.byte	$00		; $82 : :
>11a8	00					.byte	$00		; $83 : ,
>11a9	00					.byte	$00		; $84 : ;
>11aa	00					.byte	$00		; $85 : #
>11ab	11					.byte	$11		; $86 : and
>11ac	11					.byte	$11		; $87 : or
>11ad	11					.byte	$11		; $88 : xor
>11ae	12					.byte	$12		; $89 : >
>11af	12					.byte	$12		; $8a : >=
>11b0	12					.byte	$12		; $8b : <
>11b1	12					.byte	$12		; $8c : <=
>11b2	12					.byte	$12		; $8d : =
>11b3	12					.byte	$12		; $8e : <>
>11b4	13					.byte	$13		; $8f : +
>11b5	13					.byte	$13		; $90 : -
>11b6	14					.byte	$14		; $91 : *
>11b7	14					.byte	$14		; $92 : /
>11b8	14					.byte	$14		; $93 : mod
>11b9	40					.byte	$40		; $94 : len(
>11ba	40					.byte	$40		; $95 : rnd(
>11bb	40					.byte	$40		; $96 : asc(
>11bc	40					.byte	$40		; $97 : chr$(
>11bd	40					.byte	$40		; $98 : val(
>11be	40					.byte	$40		; $99 : str$(
>11bf	40					.byte	$40		; $9a : spc(
>11c0	40					.byte	$40		; $9b : left$(
>11c1	40					.byte	$40		; $9c : mid$(
>11c2	40					.byte	$40		; $9d : right$(
>11c3	40					.byte	$40		; $9e : abs(
>11c4	40					.byte	$40		; $9f : sgn(
>11c5	40					.byte	$40		; $a0 : int(
>11c6	40					.byte	$40		; $a1 : random(
>11c7	40					.byte	$40		; $a2 : deek(
>11c8	40					.byte	$40		; $a3 : peek(
>11c9	40					.byte	$40		; $a4 : vpeek(
>11ca	40					.byte	$40		; $a5 : (
>11cb	40					.byte	$40		; $a6 : %
>11cc	40					.byte	$40		; $a7 : $
>11cd	82					.byte	$82		; $a8 : if
>11ce	82					.byte	$82		; $a9 : repeat
>11cf	82					.byte	$82		; $aa : for
>11d0	82					.byte	$82		; $ab : while
>11d1	82					.byte	$82		; $ac : case
>11d2	80					.byte	$80		; $ad : then
>11d3	80					.byte	$80		; $ae : endif
>11d4	80					.byte	$80		; $af : until
>11d5	80					.byte	$80		; $b0 : next
>11d6	80					.byte	$80		; $b1 : endwhile
>11d7	80					.byte	$80		; $b2 : endcase
>11d8	81					.byte	$81		; $b3 : to
>11d9	81					.byte	$81		; $b4 : step
>11da	81					.byte	$81		; $b5 : proc
>11db	81					.byte	$81		; $b6 : endproc
>11dc	81					.byte	$81		; $b7 : call
>11dd	81					.byte	$81		; $b8 : local
>11de	81					.byte	$81		; $b9 : run
>11df	81					.byte	$81		; $ba : stop
>11e0	81					.byte	$81		; $bb : end
>11e1	81					.byte	$81		; $bc : print
>11e2	81					.byte	$81		; $bd : input
>11e3	81					.byte	$81		; $be : when
>11e4	81					.byte	$81		; $bf : default
>11e5	81					.byte	$81		; $c0 : let
>11e6	81					.byte	$81		; $c1 : option
>11e7	81					.byte	$81		; $c2 : list
>11e8	81					.byte	$81		; $c3 : load
>11e9	81					.byte	$81		; $c4 : save
>11ea	81					.byte	$81		; $c5 : new
>11eb	81					.byte	$81		; $c6 : old
>11ec	81					.byte	$81		; $c7 : poke
>11ed	81					.byte	$81		; $c8 : doke
>11ee	81					.byte	$81		; $c9 : vpoke
>11ef	81					.byte	$81		; $ca : rem
>11f0	81					.byte	$81		; $cb : goto
>11f1	81					.byte	$81		; $cc : gosub
>11f2	81					.byte	$81		; $cd : sys
>11f3	81					.byte	$81		; $ce : return
>11f4	81					.byte	$81		; $cf : assert
>11f5	81					.byte	$81		; $d0 : on
>11f6	81					.byte	$81		; $d1 : open
>11f7	81					.byte	$81		; $d2 : close
>11f8	81					.byte	$81		; $d3 : dir
>11f9	81					.byte	$81		; $d4 : dim
>11fa	81					.byte	$81		; $d5 : read
>11fb	81					.byte	$81		; $d6 : data
>11fc	81					.byte	$81		; $d7 : restore

;******  Return to file: files.asm

>11fd							.align 	2 				; defense against old 6502 bug may be present.
.11fe					TokenVectors:

;******  Processing file: generated/tokenvectors.inc

>11fe	ae 12					.word	SyntaxError             		; $80 : (eol)
>1200	ae 12					.word	SyntaxError             		; $81 : )
>1202	ae 12					.word	SyntaxError             		; $82 : :
>1204	ae 12					.word	SyntaxError             		; $83 : ,
>1206	ae 12					.word	SyntaxError             		; $84 : ;
>1208	ae 12					.word	SyntaxError             		; $85 : #
>120a	d7 17					.word	BinaryAnd               		; $86 : and
>120c	f5 17					.word	BinaryOr                		; $87 : or
>120e	13 18					.word	BinaryXor               		; $88 : xor
>1210	35 19					.word	Compare_Greater         		; $89 : >
>1212	28 19					.word	Compare_GreaterEquals   		; $8a : >=
>1214	2b 19					.word	Compare_Less            		; $8b : <
>1216	32 19					.word	Compare_LessEquals      		; $8c : <=
>1218	11 19					.word	Compare_Equals          		; $8d : =
>121a	14 19					.word	Compare_NotEquals       		; $8e : <>
>121c	8e 17					.word	BinaryAdd               		; $8f : +
>121e	b8 17					.word	BinarySub               		; $90 : -
>1220	31 18					.word	Multiply16x16           		; $91 : *
>1222	72 18					.word	Divide16x16             		; $92 : /
>1224	81 18					.word	Modulus16x16            		; $93 : mod
>1226	b3 1a					.word	StringLength            		; $94 : len(
>1228	ae 12					.word	SyntaxError             		; $95 : rnd(
>122a	ae 12					.word	SyntaxError             		; $96 : asc(
>122c	ae 12					.word	SyntaxError             		; $97 : chr$(
>122e	ae 12					.word	SyntaxError             		; $98 : val(
>1230	ae 12					.word	SyntaxError             		; $99 : str$(
>1232	ae 12					.word	SyntaxError             		; $9a : spc(
>1234	ae 12					.word	SyntaxError             		; $9b : left$(
>1236	ae 12					.word	SyntaxError             		; $9c : mid$(
>1238	ae 12					.word	SyntaxError             		; $9d : right$(
>123a	62 1a					.word	AbsoluteValue           		; $9e : abs(
>123c	7e 1a					.word	SignValue               		; $9f : sgn(
>123e	ae 12					.word	SyntaxError             		; $a0 : int(
>1240	b6 19					.word	RandomNumber            		; $a1 : random(
>1242	d8 1a					.word	DeekMemory              		; $a2 : deek(
>1244	d5 1a					.word	PeekMemory              		; $a3 : peek(
>1246	ae 12					.word	SyntaxError             		; $a4 : vpeek(
>1248	5b 1a					.word	Parenthesis             		; $a5 : (
>124a	57 1a					.word	Dummy_Binary            		; $a6 : %
>124c	57 1a					.word	Dummy_Hex               		; $a7 : $
>124e	ae 12					.word	SyntaxError             		; $a8 : if
>1250	ae 12					.word	SyntaxError             		; $a9 : repeat
>1252	ae 12					.word	SyntaxError             		; $aa : for
>1254	ae 12					.word	SyntaxError             		; $ab : while
>1256	ae 12					.word	SyntaxError             		; $ac : case
>1258	ae 12					.word	SyntaxError             		; $ad : then
>125a	ae 12					.word	SyntaxError             		; $ae : endif
>125c	ae 12					.word	SyntaxError             		; $af : until
>125e	ae 12					.word	SyntaxError             		; $b0 : next
>1260	ae 12					.word	SyntaxError             		; $b1 : endwhile
>1262	ae 12					.word	SyntaxError             		; $b2 : endcase
>1264	ae 12					.word	SyntaxError             		; $b3 : to
>1266	ae 12					.word	SyntaxError             		; $b4 : step
>1268	ae 12					.word	SyntaxError             		; $b5 : proc
>126a	ae 12					.word	SyntaxError             		; $b6 : endproc
>126c	ae 12					.word	SyntaxError             		; $b7 : call
>126e	ae 12					.word	SyntaxError             		; $b8 : local
>1270	ee 15					.word	Command_RUN             		; $b9 : run
>1272	31 16					.word	Command_STOP            		; $ba : stop
>1274	2e 16					.word	Command_END             		; $bb : end
>1276	ae 12					.word	SyntaxError             		; $bc : print
>1278	ae 12					.word	SyntaxError             		; $bd : input
>127a	ae 12					.word	SyntaxError             		; $be : when
>127c	ae 12					.word	SyntaxError             		; $bf : default
>127e	ae 12					.word	SyntaxError             		; $c0 : let
>1280	ae 12					.word	SyntaxError             		; $c1 : option
>1282	ae 12					.word	SyntaxError             		; $c2 : list
>1284	ae 12					.word	SyntaxError             		; $c3 : load
>1286	ae 12					.word	SyntaxError             		; $c4 : save
>1288	ae 12					.word	SyntaxError             		; $c5 : new
>128a	ae 12					.word	SyntaxError             		; $c6 : old
>128c	a2 15					.word	Command_Poke            		; $c7 : poke
>128e	a5 15					.word	Command_Doke            		; $c8 : doke
>1290	ae 12					.word	SyntaxError             		; $c9 : vpoke
>1292	95 15					.word	Command_Rem             		; $ca : rem
>1294	1c 15					.word	Command_GOTO            		; $cb : goto
>1296	ae 12					.word	SyntaxError             		; $cc : gosub
>1298	ae 12					.word	SyntaxError             		; $cd : sys
>129a	ae 12					.word	SyntaxError             		; $ce : return
>129c	72 15					.word	Command_Assert          		; $cf : assert
>129e	ae 12					.word	SyntaxError             		; $d0 : on
>12a0	ae 12					.word	SyntaxError             		; $d1 : open
>12a2	ae 12					.word	SyntaxError             		; $d2 : close
>12a4	ae 12					.word	SyntaxError             		; $d3 : dir
>12a6	ae 12					.word	SyntaxError             		; $d4 : dim
>12a8	ae 12					.word	SyntaxError             		; $d5 : read
>12aa	ae 12					.word	SyntaxError             		; $d6 : data
>12ac	ae 12					.word	SyntaxError             		; $d7 : restore

;******  Return to file: files.asm


;******  Processing file: generated/tokenconst.inc

=$d8					TOK_LAST_TOKEN = $d8
=$80					TOK_LPARENEOLRPAREN = $80
=$81					TOK_RPAREN = $81
=$82					TOK_COLON = $82
=$83					TOK_COMMA = $83
=$84					TOK_SEMICOLON = $84
=$85					TOK_HASH = $85
=$86					TOK_AND = $86
=$87					TOK_OR = $87
=$88					TOK_XOR = $88
=$89					TOK_GREATER = $89
=$8a					TOK_GREATEREQUAL = $8a
=$8b					TOK_LESS = $8b
=$8c					TOK_LESSEQUAL = $8c
=$8d					TOK_EQUAL = $8d
=$8e					TOK_LESSGREATER = $8e
=$8f					TOK_PLUS = $8f
=$90					TOK_MINUS = $90
=$91					TOK_STAR = $91
=$92					TOK_SLASH = $92
=$93					TOK_MOD = $93
=$94					TOK_LENLPAREN = $94
=$95					TOK_RNDLPAREN = $95
=$96					TOK_ASCLPAREN = $96
=$97					TOK_CHRDOLLARLPAREN = $97
=$98					TOK_VALLPAREN = $98
=$99					TOK_STRDOLLARLPAREN = $99
=$9a					TOK_SPCLPAREN = $9a
=$9b					TOK_LEFTDOLLARLPAREN = $9b
=$9c					TOK_MIDDOLLARLPAREN = $9c
=$9d					TOK_RIGHTDOLLARLPAREN = $9d
=$9e					TOK_ABSLPAREN = $9e
=$9f					TOK_SGNLPAREN = $9f
=$a0					TOK_INTLPAREN = $a0
=$a1					TOK_RANDOMLPAREN = $a1
=$a2					TOK_DEEKLPAREN = $a2
=$a3					TOK_PEEKLPAREN = $a3
=$a4					TOK_VPEEKLPAREN = $a4
=$a5					TOK_LPAREN = $a5
=$a6					TOK_PERCENT = $a6
=$a7					TOK_DOLLAR = $a7
=$a8					TOK_IF = $a8
=$a9					TOK_REPEAT = $a9
=$aa					TOK_FOR = $aa
=$ab					TOK_WHILE = $ab
=$ac					TOK_CASE = $ac
=$ad					TOK_THEN = $ad
=$ae					TOK_ENDIF = $ae
=$af					TOK_UNTIL = $af
=$b0					TOK_NEXT = $b0
=$b1					TOK_ENDWHILE = $b1
=$b2					TOK_ENDCASE = $b2
=$b3					TOK_TO = $b3
=$b4					TOK_STEP = $b4
=$b5					TOK_PROC = $b5
=$b6					TOK_ENDPROC = $b6
=$b7					TOK_CALL = $b7
=$b8					TOK_LOCAL = $b8
=$b9					TOK_RUN = $b9
=$ba					TOK_STOP = $ba
=$bb					TOK_END = $bb
=$bc					TOK_PRINT = $bc
=$bd					TOK_INPUT = $bd
=$be					TOK_WHEN = $be
=$bf					TOK_DEFAULT = $bf
=$c0					TOK_LET = $c0
=$c1					TOK_OPTION = $c1
=$c2					TOK_LIST = $c2
=$c3					TOK_LOAD = $c3
=$c4					TOK_SAVE = $c4
=$c5					TOK_NEW = $c5
=$c6					TOK_OLD = $c6
=$c7					TOK_POKE = $c7
=$c8					TOK_DOKE = $c8
=$c9					TOK_VPOKE = $c9
=$ca					TOK_REM = $ca
=$cb					TOK_GOTO = $cb
=$cc					TOK_GOSUB = $cc
=$cd					TOK_SYS = $cd
=$ce					TOK_RETURN = $ce
=$cf					TOK_ASSERT = $cf
=$d0					TOK_ON = $d0
=$d1					TOK_OPEN = $d1
=$d2					TOK_CLOSE = $d2
=$d3					TOK_DIR = $d3
=$d4					TOK_DIM = $d4
=$d5					TOK_READ = $d5
=$d6					TOK_DATA = $d6
=$d7					TOK_RESTORE = $d7

;******  Return to file: files.asm


;******  Processing file: code/error.asm

.12ae					SyntaxError:
.12ae	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>12b1	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>12b9	72 72 6f 72 00
.12be					TypeMismatch:
.12be	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>12c1	54 79 70 65 20 4d 69 73				.text 	"Type Mismatch",0
>12c9	6d 61 74 63 68 00
.12cf					ParameterError:
.12cf	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>12d2	50 61 72 61 6d 65 74 65				.text 	"Parameter",0
>12da	72 00
.12dc					ErrorHandler:
.12dc	68		pla				pla 								; get message address
.12dd	7a		ply				ply
.12de	1a		inc a				inc 	a
.12df	d0 01		bne $12e2			bne 	_EHNoCarry
.12e1	c8		iny				iny
.12e2					_EHNoCarry:
.12e2	20 04 14	jsr $1404			jsr 	EXPrintString
.12e5	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.12e7	b1 00		lda ($00),y			lda 	(codePtr),y
.12e9	c8		iny				iny
.12ea	11 00		ora ($00),y			ora 	(codePtr),y
.12ec	f0 14		beq $1302			beq 	_EHNoLine
.12ee	a9 0c		lda #$0c			lda 	#_EHMsg2 & $FF 				; print " at "
.12f0	a0 13		ldy #$13			ldy 	#_EHMsg2 >> 8
.12f2	20 04 14	jsr $1404			jsr 	EXPrintString
.12f5	a0 02		ldy #$02			ldy 	#2 							; print line number
.12f7	b1 00		lda ($00),y			lda 	(codePtr),y
.12f9	48		pha				pha
.12fa	88		dey				dey
.12fb	b1 00		lda ($00),y			lda 	(codePtr),y
.12fd	7a		ply				ply
.12fe	18		clc				clc
.12ff	20 e5 19	jsr $19e5			jsr 	PrintYA
.1302					_EHNoLine:
.1302	a9 0d		lda #$0d			lda 	#13
.1304	20 3d 13	jsr $133d			jsr 	ExternPrint
.1307	80 fe		bra $1307	_h1:	bra 	_h1
.1309	4c 5d 1b	jmp $1b5d			jmp 	WarmStart
.130c					_EHMsg2:
>130c	20 61 74 20 00					.text 	" at ",0

;******  Return to file: files.asm


;******  Processing file: code/extern.asm

.1311					ExternInitialise:
.1311	a9 90		lda #$90			lda 	#144 						; set colour
.1313	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1316	a9 01		lda #$01			lda 	#$01
.1318	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.131b	a9 0e		lda #$0e			lda 	#14							; lower case
.131d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1320	a9 93		lda #$93			lda 	#147 						; clear screen
.1322	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1325	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.1327	4c 49 13	jmp $1349			jmp 	ExternColour
.132a					ExternCheckBreak:
.132a	da		phx				phx 								; make sure we keep XY
.132b	5a		phy				phy
.132c	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.132f	f0 03		beq $1334			beq		_ECBExit 					; stopped
.1331	7a		ply				ply 								; restore and exit.
.1332	fa		plx				plx
.1333	60		rts				rts
.1334					_ECBExit:
.1334	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>1337	42 72 65 61 6b 00				.text 	"Break",0
.133d					ExternPrint:
.133d	48		pha				pha
.133e	da		phx				phx
.133f	5a		phy				phy
.1340	29 7f		and #$7f			and 	#$7F
.1342	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1345	7a		ply				ply
.1346	fa		plx				plx
.1347	68		pla				pla
.1348	60		rts				rts
.1349					ExternColour:
.1349	48		pha				pha
.134a	da		phx				phx
.134b	48		pha				pha
.134c	29 08		and #$08			and 	#8
.134e	0a		asl a				asl 	a
.134f	0a		asl a				asl 	a
.1350	0a		asl a				asl 	a
.1351	0a		asl a				asl 	a
.1352	49 92		eor #$92			eor 	#$92
.1354	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1357	68		pla				pla
.1358	29 07		and #$07			and 	#7
.135a	aa		tax				tax
.135b	bd 64 13	lda $1364,x			lda 	_ECTable,x
.135e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1361	fa		plx				plx
.1362	68		pla				pla
.1363	60		rts				rts
.1364					_ECTable:
>1364	90						.byte 	144
>1365	1c						.byte 	28
>1366	1e						.byte 	30
>1367	9e						.byte 	158
>1368	1f						.byte 	31
>1369	9c						.byte 	156
>136a	9f						.byte 	159
>136b	05						.byte 	5
.136c					ExternInput:
.136c	a9 00		lda #$00			lda 	#(textBuffer & $FF)
.136e	85 07		sta $07				sta 	zTemp3
.1370	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1372	85 08		sta $08				sta 	zTemp3+1
.1374	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1377	c9 0d		cmp #$0d			cmp 	#13
.1379	f0 0c		beq $1387			beq 	_EIExit
.137b	29 7f		and #$7f			and 	#$7F
.137d	92 07		sta ($07)			sta 	(zTemp3)
.137f	e6 07		inc $07				inc 	zTemp3
.1381	d0 f1		bne $1374			bne 	_EIRead
.1383	e6 08		inc $08				inc 	zTemp3+1
.1385	80 ed		bra $1374			bra 	_EIRead
.1387	a9 00		lda #$00	_EIExit:lda 	#0
.1389	92 07		sta ($07)			sta 	(zTemp3)
.138b	a9 0d		lda #$0d			lda 	#13
.138d	20 3d 13	jsr $133d			jsr 	ExternPrint
.1390	60		rts				rts
.1391					ExternSave:
.1391	da		phx				phx
.1392	5a		phy				phy
.1393	85 05		sta $05				sta 	zTemp2 						; save start
.1395	84 06		sty $06				sty 	zTemp2+1
.1397	20 f9 13	jsr $13f9			jsr 	EXGetLength 				; get length of file into A
.139a	a6 07		ldx $07				ldx 	zTemp3
.139c	a4 08		ldy $08				ldy 	zTemp3+1
.139e	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.13a1	a9 01		lda #$01			lda 	#1
.13a3	a2 08		ldx #$08			ldx 	#8	 						; device #8
.13a5	a0 00		ldy #$00			ldy 	#0
.13a7	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.13aa	a6 03		ldx $03				ldx 	zTemp1 						; end address
.13ac	a4 04		ldy $04				ldy 	zTemp1+1
.13ae	a9 05		lda #$05			lda 	#zTemp2
.13b0	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.13b3	b0 03		bcs $13b8			bcs 	_ESSave
.13b5	7a		ply				ply
.13b6	fa		plx				plx
.13b7	60		rts				rts
.13b8					_ESSave:
.13b8	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>13bb	4c 6f 61 64 20 46 61 69				.text 	"Load Failed",0
>13c3	6c 65 64 00
.13c7					ExternLoad:
.13c7	da		phx				phx 								; save XY
.13c8	5a		phy				phy
.13c9	48		pha				pha 								; save target
.13ca	5a		phy				phy
.13cb	20 f9 13	jsr $13f9			jsr 	EXGetLength 				; get length of file into A
.13ce	a6 07		ldx $07				ldx 	zTemp3
.13d0	a4 08		ldy $08				ldy 	zTemp3+1
.13d2	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.13d5	a9 01		lda #$01			lda 	#1
.13d7	a2 08		ldx #$08			ldx 	#8	 						; device #8
.13d9	a0 00		ldy #$00			ldy 	#0
.13db	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.13de	7a		ply				ply 								; restore target to YX and call load
.13df	fa		plx				plx
.13e0	a9 00		lda #$00			lda 	#0 							; load command
.13e2	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.13e5	b0 03		bcs $13ea			bcs 	_ESLoad
.13e7	7a		ply				ply
.13e8	fa		plx				plx
.13e9	60		rts				rts
.13ea					_ESLoad:
.13ea	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>13ed	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>13f5	4c 45 44 00
.13f9					EXGetLength:
.13f9	5a		phy				phy
.13fa	a0 ff		ldy #$ff			ldy 	#255
.13fc	c8		iny		_EXGL0:	iny
.13fd	b1 07		lda ($07),y			lda 	(zTemp3),y
.13ff	d0 fb		bne $13fc			bne 	_EXGL0
.1401	98		tya				tya
.1402	7a		ply				ply
.1403	60		rts				rts
.1404					EXPrintString:
.1404	48		pha				pha
.1405	5a		phy				phy
.1406	84 04		sty $04				sty 	zTemp1+1
.1408	85 03		sta $03				sta 	zTemp1
.140a	a0 00		ldy #$00			ldy 	#0
.140c					_EXPSLoop:
.140c	b1 03		lda ($03),y			lda 	(zTemp1),y
.140e	f0 13		beq $1423			beq 	_EXPSExit
.1410	29 7f		and #$7f			and 	#$7F
.1412	c9 61		cmp #$61			cmp 	#'a'
.1414	90 07		bcc $141d			bcc 	_EXPSNoLC
.1416	c9 7b		cmp #$7b			cmp 	#'z'+1
.1418	b0 03		bcs $141d			bcs 	_EXPSNoLC
.141a	38		sec				sec
.141b	e9 20		sbc #$20			sbc 	#32
.141d					_EXPSNoLC:
.141d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1420	c8		iny				iny
.1421	80 e9		bra $140c			bra 	_EXPSLoop
.1423					_EXPSExit:
.1423	7a		ply				ply
.1424	68		pla				pla
.1425	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: code/structstack.asm

.1426					StructReset:
.1426	a9 7f		lda #$7f			lda 	#$7F	 					; reset the SP points to TOS
.1428	85 02		sta $02				sta 	structSP
.142a	a9 ff		lda #$ff			lda 	#$FF 						; put a dummy marker that can't be a struct marker
.142c	8d ff 07	sta $07ff			sta 	structStack+$7F
.142f	60		rts				rts
.1430					StructPushA:
.1430	da		phx				phx 								; save X
.1431	c6 02		dec $02				dec 	structSP 					; make space on stack
.1433	f0 07		beq $143c			beq 	SPUnderflow 				; no space left
.1435	a6 02		ldx $02				ldx 	structSP 					; get offset into X
.1437	9d 80 07	sta $0780,x			sta 	structStack,x 				; and save
.143a	fa		plx				plx
.143b	60		rts				rts
.143c					SPUnderflow:
.143c	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>143f	53 74 72 75 63 74 75 72				.text 	"Structure Stack",0
>1447	65 20 53 74 61 63 6b 00
.144f					StructPushPos:
.144f	da		phx				phx
.1450	a5 02		lda $02				lda 	structSP 					; make space for 3 bytes
.1452	38		sec				sec
.1453	e9 03		sbc #$03			sbc 	#3
.1455	90 e5		bcc $143c			bcc 	SPUnderflow 				; borrowed, so underflowed.
.1457	85 02		sta $02				sta 	structSP
.1459	aa		tax				tax 								; X points to space
.145a	98		tya				tya 								; save offset
.145b	9d 80 07	sta $0780,x			sta 	structStack,x
.145e	a5 00		lda $00				lda 	codePtr 					; save address of line
.1460	9d 81 07	sta $0781,x			sta 	structStack+1,x
.1463	a5 01		lda $01				lda 	codePtr+1
.1465	9d 82 07	sta $0782,x			sta 	structStack+2,x
.1468	fa		plx				plx
.1469	60		rts				rts
.146a					StructGetPos:
.146a	bd 80 07	lda $0780,x			lda 	structStack,x 				; Y offset
.146d	a8		tay				tay
.146e	bd 81 07	lda $0781,x			lda 	structStack+1,x
.1471	85 00		sta $00				sta 	codePtr
.1473	bd 82 07	lda $0782,x			lda 	structStack+2,x
.1476	85 01		sta $01				sta 	codePtr+1
.1478	60		rts				rts
.1479					StructPopABytes:
.1479	18		clc				clc
.147a	65 02		adc $02				adc 	structSP
.147c	85 02		sta $02				sta 	structSP
.147e	60		rts				rts
.147f					StructCheckTOS:
.147f	da		phx				phx
.1480	a6 02		ldx $02				ldx 	structSP 					; get offset to TOS
.1482	5d 80 07	eor $0780,x			eor 	structStack,x 				; zero if match, non zero if didn't
.1485	18		clc				clc
.1486	69 ff		adc #$ff			adc 	#$FF 						; carry will now be set if it doesn't match
.1488	fa		plx				plx 								; restore X and exit
.1489	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: code/syntax.asm

.148a					SyntaxCheckRightBracket:
.148a	b1 00		lda ($00),y			lda 	(codePtr),y
.148c	c8		iny				iny
.148d	c9 81		cmp #$81			cmp 	#TOK_RPAREN
.148f	d0 01		bne $1492			bne 	_SCRBError
.1491	60		rts				rts
.1492					_SCRBError:
.1492	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>1495	4d 69 73 73 69 6e 67 20				.text 	"Missing )",0
>149d	29 00
.149f					SyntaxCheckComma:
.149f	b1 00		lda ($00),y			lda 	(codePtr),y
.14a1	c8		iny				iny
.14a2	c9 83		cmp #$83			cmp 	#TOK_COMMA
.14a4	d0 01		bne $14a7			bne 	_SCRCError
.14a6	60		rts				rts
.14a7					_SCRCError:
.14a7	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>14aa	4d 69 73 73 69 6e 67 20				.text 	"Missing ,",0
>14b2	2c 00
.14b4					SyntaxCheckA:
.14b4	d1 00		cmp ($00),y			cmp 	(codePtr),y
.14b6	d0 02		bne $14ba			bne 	_SCAError
.14b8	c8		iny				iny
.14b9	60		rts				rts
.14ba					_SCAError:
.14ba	4c ae 12	jmp $12ae			jmp 	SyntaxError

;******  Return to file: files.asm


;******  Processing file: commands/let.asm

.14bd					Command_LET:
.14bd	a2 00		ldx #$00			ldx 	#0 							; get the L-Expr
.14bf	20 09 17	jsr $1709			jsr 	EvaluateTermAtX
.14c2	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; check to see if it is a reference.
.14c5	6a		ror a				ror 	a
.14c6	90 38		bcc $1500			bcc 	_CLTNotVar 					; if not, then we have an error.
.14c8	a9 8d		lda #$8d			lda 	#TOK_EQUAL					; next token must be an equals.
.14ca	20 b4 14	jsr $14b4			jsr 	SyntaxCheckA
.14cd	e8		inx				inx
.14ce	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; calculate the R-Expr in level 1.
.14d1	ad 20 06	lda $0620			lda 	xsAddrLow
.14d4	85 03		sta $03				sta 	zTemp1
.14d6	ad 40 06	lda $0640			lda 	xsAddrHigh
.14d9	85 04		sta $04				sta 	zTemp1+1
.14db	ad 00 06	lda $0600			lda 	xsStatus 					; check the same types.
.14de	4d 01 06	eor $0601			eor 	xsStatus+1
.14e1	29 40		and #$40			and 	#$40
.14e3	d0 1e		bne $1503			bne 	_CLTTypeMismatch
.14e5	2c 00 06	bit $0600			bit 	xsStatus 					; string to string assignment
.14e8	70 30		bvs $151a			bvs 	_CLTStringAssignment
.14ea	30 2c		bmi $1518			bmi 	_CLTFloatAssignment
.14ec	2c 01 06	bit $0601			bit 	xsStatus+1 					; are we assigning a float to an integer ?
.14ef	70 15		bvs $1506			bvs 	_CLTFloatToInt 				; yes, then we do not auto truncate.
.14f1	5a		phy				phy 								; copy value into reference.
.14f2	ad 21 06	lda $0621			lda 	xsIntLow+1
.14f5	92 03		sta ($03)			sta 	(zTemp1)
.14f7	a0 01		ldy #$01			ldy 	#1
.14f9	ad 41 06	lda $0641			lda 	xsIntHigh+1
.14fc	91 03		sta ($03),y			sta 	(zTemp1),y
.14fe	7a		ply				ply
.14ff	60		rts				rts
.1500					_CLTNotVar:
.1500	4c ae 12	jmp $12ae			jmp 	SyntaxError
.1503					_CLTTypeMismatch:
.1503	4c be 12	jmp $12be			jmp 	TypeMismatch
.1506					_CLTFloatToInt:
.1506	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>1509	50 72 65 63 69 73 69 6f				.text 	"Precision Lost",0
>1511	6e 20 4c 6f 73 74 00
.1518					_CLTFloatAssignment:
.1518	80 fe		bra $1518			bra 	_CLTFloatAssignment
.151a					_CLTStringAssignment:
.151a	80 fe		bra $151a			bra 	_CLTStringAssignment

;******  Return to file: files.asm


;******  Processing file: commands/goto.asm

.151c					Command_GOTO:
.151c	20 39 16	jsr $1639			jsr 	EvaluateExpression 			; get the line number.
.151f	20 23 15	jsr $1523			jsr 	TransferControlToStack		; branch to there
.1522	60		rts				rts
.1523					TransferControlToStack:
.1523	20 14 17	jsr $1714			jsr 	DeReferenceUnary 			; remove a reference.
.1526	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; must be an integer.
.1529	d0 35		bne $1560			bne 	_TCTBadLine
.152b	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; copy line # to zTemp1
.152e	85 03		sta $03				sta 	zTemp1
.1530	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.1533	85 04		sta $04				sta 	zTemp1+1
.1535	a9 b8		lda #$b8			lda 	#(BasicProgram) & $FF
.1537	85 00		sta $00				sta 	0+(codePtr)
.1539	a9 1b		lda #$1b			lda 	#(BasicProgram) >> 8
.153b	85 01		sta $01				sta 	1+(codePtr)
.153d					_TCTLoop:
.153d	b2 00		lda ($00)			lda 	(codePtr) 					; didn't find it
.153f	f0 22		beq $1563			beq 	_TCTUnknown
.1541	a0 01		ldy #$01			ldy 	#1 		 					; does it match ?
.1543	b1 00		lda ($00),y			lda		(codePtr),y
.1545	c5 03		cmp $03				cmp 	zTemp1
.1547	d0 07		bne $1550			bne 	_TCTGoNext
.1549	c8		iny				iny
.154a	b1 00		lda ($00),y			lda		(codePtr),y
.154c	c5 04		cmp $04				cmp 	zTemp1+1
.154e	f0 0d		beq $155d			beq 	_TCTFound
.1550					_TCTGoNext:
.1550	18		clc				clc
.1551	a5 00		lda $00				lda 	codePtr
.1553	72 00		adc ($00)			adc 	(codePtr)
.1555	85 00		sta $00				sta 	codePtr
.1557	90 02		bcc $155b			bcc 	_NoCarryAdv
.1559	e6 01		inc $01				inc 	codePtr+1
.155b					_NoCarryAdv:
.155b	80 e0		bra $153d			bra 	_TCTLoop 					; loop round
.155d					_TCTFound:
.155d	a0 03		ldy #$03			ldy 	#3 							; from start of the line
.155f	60		rts				rts
.1560					_TCTBadLine:
.1560	4c cf 12	jmp $12cf			jmp 	ParameterError
.1563					_TCTUnknown:
.1563	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>1566	4c 69 6e 65 20 6e 75 6d				.text 	"Line number",0
>156e	62 65 72 00

;******  Return to file: files.asm


;******  Processing file: commands/miscellany.asm

.1572					Command_Assert:
.1572	a2 00		ldx #$00			ldx 	#0 							; get a single parameter
.1574	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1577	20 14 17	jsr $1714			jsr 	DeReferenceUnary 			; convert term to value if reference.
.157a	20 4e 17	jsr $174e			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.157d	90 03		bcc $1582			bcc 	_Integer
.157f	4c ae 12	jmp $12ae			jmp 	SyntaxError
.1582					_Integer:
.1582	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; check it is non-zero
.1585	1d 40 06	ora $0640,x			ora 	xsIntHigh,x
.1588	f0 01		beq $158b			beq 	_CAFail
.158a	60		rts				rts
.158b					_CAFail:
.158b	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>158e	41 73 73 65 72 74 00				.text 	"Assert",0
.1595					Command_Rem:
.1595	b1 00		lda ($00),y			lda 	(codePtr),y
.1597	c9 fb		cmp #$fb			cmp 	#$FB 						; is there a string ?
.1599	d0 06		bne $15a1			bne 	_CRExit
.159b	c8		iny				iny 								; then skip over it.
.159c	38		sec				sec
.159d	98		tya				tya
.159e	71 00		adc ($00),y			adc 	(codePtr),y
.15a0	a8		tay				tay
.15a1					_CRExit:
.15a1	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: commands/pokedoke.asm

.15a2					Command_Poke:
.15a2	18		clc				clc
.15a3	80 01		bra $15a6			bra 	WriteMemoryMain
.15a5					Command_Doke:
.15a5	38		sec				sec
.15a6					WriteMemoryMain:
.15a6	08		php				php									; save cc byte cs word
.15a7	a2 00		ldx #$00			ldx 	#0 							; get address and parameter.
.15a9	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; evaluate the term
.15ac	20 14 17	jsr $1714			jsr 	DeReferenceUnary 			; convert term to value if reference.
.15af	20 4e 17	jsr $174e			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.15b2	90 03		bcc $15b7			bcc 	_Integer
.15b4	4c be 12	jmp $12be			jmp 	TypeMismatch
.15b7					_Integer:
.15b7	20 9f 14	jsr $149f			jsr 	SyntaxCheckComma
.15ba	e8		inx				inx
.15bb	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; evaluate the term
.15be	20 14 17	jsr $1714			jsr 	DeReferenceUnary 			; convert term to value if reference.
.15c1	20 4e 17	jsr $174e			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.15c4	90 03		bcc $15c9			bcc 	_Integer
.15c6	4c be 12	jmp $12be			jmp 	TypeMismatch
.15c9					_Integer:
.15c9	ad 20 06	lda $0620			lda 	xsAddrLow 					; transfer address
.15cc	85 03		sta $03				sta 	zTemp1
.15ce	ad 40 06	lda $0640			lda 	xsAddrHigh
.15d1	85 04		sta $04				sta 	zTemp1+1
.15d3	ad 21 06	lda $0621			lda 	xsIntLow+1 					; do the poke anyway
.15d6	92 03		sta ($03)			sta 	(zTemp1)
.15d8	28		plp				plp
.15d9	b0 09		bcs $15e4			bcs 	_WMMWord
.15db	ad 41 06	lda $0641			lda 	xsIntHigh+1 				; get high byte
.15de	d0 01		bne $15e1			bne 	_WMMByteReq 				; should be zero
.15e0	60		rts				rts
.15e1					_WMMByteReq:
.15e1	4c cf 12	jmp $12cf			jmp 	ParameterError
.15e4					_WMMWord:
.15e4	5a		phy				phy
.15e5	a0 01		ldy #$01			ldy 	#1
.15e7	ad 41 06	lda $0641			lda 	xsIntHigh+1
.15ea	91 03		sta ($03),y			sta 	(zTemp1),y
.15ec	7a		ply				ply
.15ed	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: commands/run.asm

.15ee					Command_RUN:
.15ee	20 26 14	jsr $1426			jsr 	StructReset 				; reset the structure stack.
.15f1	a9 b8		lda #$b8			lda 	#(BasicProgram) & $FF
.15f3	85 00		sta $00				sta 	0+(codePtr)
.15f5	a9 1b		lda #$1b			lda 	#(BasicProgram) >> 8
.15f7	85 01		sta $01				sta 	1+(codePtr)
.15f9					_CRNewLine:
.15f9	b2 00		lda ($00)			lda 	(codePtr) 					; check not at the end of the program
.15fb	f0 31		beq $162e			beq 	Command_END 				; reached the end of the program
.15fd	a0 02		ldy #$02			ldy 	#2 							; first token of program line -1 for the INY
.15ff					_CRNextToken:
.15ff	c8		iny				iny 								;
.1600					_CRNextCommand:
.1600	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token.
.1602	10 25		bpl $1629			bpl 	_CRDefaultLet 				; is it a token, if not, try LET.
.1604	c9 82		cmp #$82			cmp 	#TOK_COLON 					; skip colons
.1606	f0 f7		beq $15ff			beq 	_CRNextToken
.1608	c9 d8		cmp #$d8			cmp 	#TOK_LAST_TOKEN				; token too high, probably $F8-$FF
.160a	b0 1a		bcs $1626			bcs 	_CRSyntax
.160c	0a		asl a				asl 	a 							; put token x 2 in X, clears bit 7.
.160d	f0 07		beq $1616			beq 	_CRNextLine 				; if this is zero now it was $80, so end of line
.160f	aa		tax				tax
.1610	c8		iny				iny 								; advance over token.
.1611	20 23 16	jsr $1623			jsr 	_CRCallRoutine 				; call that routine
.1614	80 ea		bra $1600			bra 	_CRNextCommand 				; and carry on.
.1616					_CRNextLine:
.1616	18		clc				clc
.1617	a5 00		lda $00				lda 	codePtr
.1619	72 00		adc ($00)			adc 	(codePtr)
.161b	85 00		sta $00				sta 	codePtr
.161d	90 02		bcc $1621			bcc 	_NoCarryAdv
.161f	e6 01		inc $01				inc 	codePtr+1
.1621					_NoCarryAdv:
.1621	80 d6		bra $15f9			bra 	_CRNewLine 					; do new line code.
.1623					_CRCallRoutine:
.1623	7c fe 11	jmp ($11fe,x)			jmp 	(TokenVectors,x)
.1626					_CRSyntax:
.1626	4c ae 12	jmp $12ae			jmp 	SyntaxError
.1629					_CRDefaultLet:
.1629	20 bd 14	jsr $14bd			jsr 	Command_LET
.162c	80 d2		bra $1600			bra 	_CRNextCommand
.162e					Command_END:
.162e	4c 5d 1b	jmp $1b5d			jmp 	WarmStart
.1631					Command_STOP:
.1631	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>1634	53 74 6f 70 00					.text 	"Stop",0

;******  Return to file: files.asm


;******  Processing file: expression/evaluate.asm

.1639					EvaluateExpression:
.1639	a2 00		ldx #$00			ldx 	#0 							; reset the evaluation stack pointer in X
.163b					EvaluateExpressionAtX:
.163b	a9 10		lda #$10			lda 	#$10 						; this is the lowest precedence.
.163d					EvaluateExpressionAtXPrecA:
.163d	48		pha				pha 								; save lowest stack level.
.163e	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first term.
.1640	30 4f		bmi $1691			bmi 	_EXAKeywordData 			; is it keyword, or data.
.1642	c9 60		cmp #$60			cmp 	#$60 						; is it a variable
.1644	90 46		bcc $168c			bcc 	_EXAVariable
.1646	c8		iny				iny 								; skip over the short constant
.1647	29 1f		and #$1f			and 	#$1F 						; short constant $00-$1F
.1649	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and put as an integer
.164c	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.164f	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; integer, number, not a reference.
.1652					_EXAHaveTerm:
.1652	68		pla				pla 	 							; restore current precedence and save in zTemp1
.1653	85 03		sta $03				sta 	zTemp1
.1655	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by a binary operation.
.1657	da		phx				phx
.1658	aa		tax				tax
.1659	bd 25 11	lda $1125,x			lda 	TokenControlByteTable-$80,x ; get the control byte.
.165c	fa		plx				plx
.165d	c9 20		cmp #$20			cmp 	#$20 						; must be $10-$17 (or possibly $00, will be < precedence)
.165f	b0 06		bcs $1667			bcs 	_EXAExit
.1661	c5 03		cmp $03				cmp 	zTemp1 						; check against current precedence.
.1663	f0 02		beq $1667			beq 	_EXAExit
.1665	b0 01		bcs $1668			bcs		_EXABinaryOp 				; if >, do a binary operation.
.1667					_EXAExit:
.1667	60		rts				rts 								; exit expression evaluation.
.1668					_EXABinaryOp:
.1668	85 04		sta $04				sta 	zTemp1+1 					; save operator.
.166a	a5 03		lda $03				lda 	zTemp1 						; get and save current precedence
.166c	48		pha				pha
.166d	b1 00		lda ($00),y			lda 	(codePtr),y 				; push binary operator on stack
.166f	48		pha				pha
.1670	c8		iny				iny 								; and skip over it.
.1671	e8		inx				inx 								; calculate the RHS in the next slot up.
.1672	a5 04		lda $04				lda 	zTemp1+1 					; at operator precedence level.
.1674	20 3d 16	jsr $163d			jsr 	EvaluateExpressionAtXPrecA
.1677	ca		dex				dex
.1678	68		pla				pla 								; get binary operator.
.1679	da		phx				phx 								; save stack depth.
.167a	0a		asl a				asl 	a 							; double binary operator and put into X, loses MSB
.167b	aa		tax				tax
.167c	bd fe 11	lda $11fe,x			lda 	TokenVectors,x 				; get address => zTemp2
.167f	85 05		sta $05				sta 	zTemp2
.1681	bd ff 11	lda $11ff,x			lda 	TokenVectors+1,x
.1684	85 06		sta $06				sta 	zTemp2+1
.1686	fa		plx				plx 								; restore stack depth.
.1687	20 06 17	jsr $1706			jsr 	_EXACallZTemp2 				; call the routine
.168a	80 c6		bra $1652			bra 	_EXAHaveTerm 				; and loop round again.
.168c					_EXAVariable:
.168c	20 0d 1b	jsr $1b0d			jsr 	VariableLookup 				; look up the variable value perhaps creating it.
.168f	80 c1		bra $1652			bra 	_EXAHaveTerm 				; and carry on with the expression
.1691					_EXAKeywordData:
.1691	c9 90		cmp #$90			cmp 	#TOK_MINUS 					; special case as - is unary and binary operator.
.1693	d0 09		bne $169e			bne 	_EXANotNegate
.1695	c8		iny				iny
.1696	20 09 17	jsr $1709			jsr 	EvaluateTermAtX 			; the term
.1699	20 fd 18	jsr $18fd			jsr 	IntegerNegate 				; negate it
.169c	80 b4		bra $1652			bra 	_EXAHaveTerm 				; and loop back.
.169e					_EXANotNegate:
.169e	c9 f8		cmp #$f8			cmp 	#$F8 						; $80-$F8 are unary functions
.16a0	90 45		bcc $16e7			bcc 	_EXAUnaryFunction
.16a2	c9 fb		cmp #$fb			cmp 	#$FB 						; $FB is a string.
.16a4	f0 25		beq $16cb			beq 	_EXAString
.16a6	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; it is now either $FE (short int) or $FF (long int)
.16a9	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.16ac	48		pha				pha 								; save identifier
.16ad	c8		iny				iny 								; do the low byte
.16ae	b1 00		lda ($00),y			lda 	(codePtr),y
.16b0	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.16b3	c8		iny				iny
.16b4	68		pla				pla 								; get identifier
.16b5	c9 fe		cmp #$fe			cmp 	#$FE  						; if short then done.
.16b7	f0 99		beq $1652			beq 	_EXAHaveTerm
.16b9	c9 ff		cmp #$ff			cmp 	#$FF 						; should be $FF
.16bb	d0 08		bne $16c5			bne 	_EXACrash
.16bd	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy high byte
.16bf	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.16c2	c8		iny				iny
.16c3	80 8d		bra $1652			bra 	_EXAHaveTerm
.16c5					_EXACrash:
.16c5	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>16c8	23 58 00					.text 	"#X",0
.16cb					_EXAString:
.16cb	c8		iny				iny 								; point to string length, which is the string start.
.16cc	98		tya				tya 								; work out the physical address of the string
.16cd	18		clc				clc
.16ce	65 00		adc $00				adc 	codePtr
.16d0	9d 20 06	sta $0620,x			sta 	xsAddrLow,x
.16d3	a5 01		lda $01				lda 	codePtr+1
.16d5	69 00		adc #$00			adc 	#0
.16d7	9d 40 06	sta $0640,x			sta 	xsAddrHigh,x
.16da	a9 40		lda #$40			lda 	#$40 						; set the type to string
.16dc	9d 00 06	sta $0600,x			sta 	xsStatus,x
.16df	98		tya				tya 								; add the length to the current position
.16e0	38		sec				sec 								; +1 for the length byte itself.
.16e1	71 00		adc ($00),y			adc 	(codePtr),y
.16e3	a8		tay				tay
.16e4	4c 52 16	jmp $1652			jmp 	_EXAHaveTerm
.16e7					_EXAUnaryFunction:
.16e7	da		phx				phx 								; get the table entry to check it is a unary function
.16e8	aa		tax				tax
.16e9	3c 25 11	bit $1125,x			bit 	TokenControlByteTable-$80,x ; if bit 6 is not set, it's not a unary function.
.16ec	50 15		bvc $1703			bvc 	_EXANotUnaryFunction
.16ee	8a		txa				txa 								; now copy the routine address, put token x 2 in.
.16ef	0a		asl a				asl 	a
.16f0	aa		tax				tax
.16f1	bd fe 11	lda $11fe,x			lda 	TokenVectors,x 				; get address => zTemp2
.16f4	85 05		sta $05				sta 	zTemp2
.16f6	bd ff 11	lda $11ff,x			lda 	TokenVectors+1,x
.16f9	85 06		sta $06				sta 	zTemp2+1
.16fb	fa		plx				plx 								; restore stack depth.
.16fc	c8		iny				iny 								; skip unary function token.
.16fd	20 06 17	jsr $1706			jsr 	_EXACallZTemp2 				; call the routine
.1700	4c 52 16	jmp $1652			jmp 	_EXAHaveTerm 				; and loop round again.
.1703					_EXANotUnaryFunction:
.1703	4c ae 12	jmp $12ae			jmp 	SyntaxError
.1706					_EXACallZTemp2:
.1706	6c 05 00	jmp ($0005)			jmp 	(zTemp2)

;******  Return to file: files.asm


;******  Processing file: expression/exprutils.asm

.1709					EvaluateTermAtX:
.1709	a9 1f		lda #$1f			lda 	#$1F 						; too high precedence so just term
.170b	20 3d 16	jsr $163d			jsr 	EvaluateExpressionAtXPrecA
.170e	60		rts				rts
.170f					DeReferenceBinary:
.170f	e8		inx				inx
.1710	20 14 17	jsr $1714			jsr 	DeReferenceUnary
.1713	ca		dex				dex
.1714					DeReferenceUnary:
.1714	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; the reference flag is in bit 0
.1717	6a		ror a				ror 	a 							; shift into carry.
.1718	90 33		bcc $174d			bcc 	_DRNotReference 			; if clear, it's already a reference.
.171a	0a		asl a				asl 	a 							; get back, but with bit 0 cleared
.171b	9d 00 06	sta $0600,x			sta 	xsStatus,x
.171e	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put the address to dereference into zTemp1
.1721	85 03		sta $03				sta 	zTemp1
.1723	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.1726	85 04		sta $04				sta 	zTemp1+1
.1728	5a		phy				phy 								; save position in code
.1729	b2 03		lda ($03)			lda 	(zTemp1) 					; dereference the first two bytes - this will be
.172b	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; for float, int and string, and will go in these
.172e	a0 01		ldy #$01			ldy 	#1 							; which are also the address, and mantissa3 & 2
.1730	b1 03		lda ($03),y			lda 	(zTemp1),y
.1732	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1735	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; check if it's a float (bit 7)
.1738	10 12		bpl $174c			bpl 	_DRNotFloat 				; if not, we are complete
.173a	c8		iny				iny 								; if float, copy all five bytes of the floating point
.173b	b1 03		lda ($03),y			lda 	(zTemp1),y 					; number into the stack.
.173d	9d 60 06	sta $0660,x			sta 	xsMantissa1,x
.1740	c8		iny				iny
.1741	b1 03		lda ($03),y			lda 	(zTemp1),y
.1743	9d 80 06	sta $0680,x			sta 	xsMantissa0,x
.1746	c8		iny				iny
.1747	b1 03		lda ($03),y			lda 	(zTemp1),y
.1749	9d a0 06	sta $06a0,x			sta 	xsExponent,x
.174c					_DRNotFloat:
.174c	7a		ply				ply 								; restore code position.
.174d					_DRNotReference:
.174d	60		rts				rts
.174e					UnaryNumberTypeCheck:
.174e	bd 00 06	lda $0600,x			lda 	xsStatus,x
.1751	80 06		bra $1759			bra 	BNTCMain
.1753					BinaryNumberTypeCheck:
.1753	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; bit 7 set if either float, bit 6 set if either string.
.1756	1d 01 06	ora $0601,x			ora 	xsStatus+1,x
.1759					BNTCMain:
.1759	0a		asl a				asl 	a 							; carry set if either float, bit 7 set if either string
.175a	30 01		bmi $175d			bmi 	_NTCError 					; so fail if string, we want int
.175c	60		rts				rts
.175d					_NTCError:
.175d	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>1760	4e 75 6d 62 65 72 20 65				.text 	"Number expected",0
>1768	78 70 65 63 74 65 64 00
.1770					BinaryStringTypeCheck:
.1770	3c 01 06	bit $0601,x			bit 	xsStatus+1,x
.1773	50 06		bvc $177b			bvc 	STCError
.1775					UnaryStringTypeCheck:
.1775	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; check if string
.1778	50 01		bvc $177b			bvc 	STCError
.177a	60		rts				rts
.177b					STCError:
.177b	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>177e	53 74 72 69 6e 67 20 65				.text 	"String expected",0
>1786	78 70 65 63 74 65 64 00

;******  Return to file: files.asm


;******  Processing file: expression/integer/arithmetic.asm

.178e					BinaryAdd:
.178e	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.1791	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.1794	50 06		bvc $179c			bvc 	_NumericType
.1796	20 70 17	jsr $1770			jsr 	BinaryStringTypeCheck 		; check both are strings
.1799	4c ae 12	jmp $12ae			jmp 	SyntaxError 							; and do the string handler
.179c					_NumericType:
.179c	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; see if they are compatible.
.179f	90 03		bcc $17a4			bcc 	_Integer
.17a1	4c 34 1b	jmp $1b34			jmp 	FPAdd
.17a4					_Integer:
.17a4	18		clc				clc
.17a5	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.17a8	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.17ab	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.17ae	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.17b1	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.17b4	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.17b7	60		rts				rts
.17b8					BinarySub:
.17b8	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.17bb	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.17be	90 03		bcc $17c3			bcc 	_Integer
.17c0	4c 34 1b	jmp $1b34			jmp 	FPSub
.17c3					_Integer:
.17c3	38		sec				sec
.17c4	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.17c7	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.17ca	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.17cd	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.17d0	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.17d3	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.17d6	60		rts				rts
.17d7					BinaryAnd:
.17d7	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.17da	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.17dd	90 03		bcc $17e2			bcc 	_Integer
.17df	20 34 1b	jsr $1b34			jsr 	FPFloatToInteger
.17e2					_Integer:
.17e2	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.17e5	3d 21 06	and $0621,x			and 	xsIntLow+1,x
.17e8	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.17eb	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.17ee	3d 41 06	and $0641,x			and 	xsIntHigh+1,x
.17f1	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.17f4	60		rts				rts
.17f5					BinaryOr:
.17f5	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.17f8	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.17fb	90 03		bcc $1800			bcc 	_Integer
.17fd	20 34 1b	jsr $1b34			jsr 	FPFloatToInteger
.1800					_Integer:
.1800	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1803	1d 21 06	ora $0621,x			ora 	xsIntLow+1,x
.1806	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1809	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.180c	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.180f	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1812	60		rts				rts
.1813					BinaryXor:
.1813	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.1816	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; check numeric. if float convert to integer
.1819	90 03		bcc $181e			bcc 	_Integer
.181b	20 34 1b	jsr $1b34			jsr 	FPFloatToInteger
.181e					_Integer:
.181e	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1821	5d 21 06	eor $0621,x			eor 	xsIntLow+1,x
.1824	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1827	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.182a	5d 41 06	eor $0641,x			eor 	xsIntHigh+1,x
.182d	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1830	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/multiply.asm

.1831					Multiply16x16:
.1831	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.1834	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.1837	90 03		bcc $183c			bcc 	_Integer
.1839	4c 34 1b	jmp $1b34			jmp 	FPMultiply
.183c					_Integer:
.183c	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; 1st value to zTemp1
.183f	85 05		sta $05				sta 	zTemp2
.1841	bd 40 06	lda $0640,x			lda		xsIntHigh,x
.1844	85 06		sta $06				sta 	zTemp2+1
.1846	9e 20 06	stz $0620,x			stz 	xsIntLow,x 					; zero 1st on stack
.1849	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.184c					_MultLoop:
.184c	46 06		lsr $06				lsr 	zTemp2+1 					; ror zTemp2 into C
.184e	66 05		ror $05				ror 	zTemp2
.1850	90 13		bcc $1865			bcc 	_MultNoAdd
.1852	18		clc				clc 								; add 2nd to 1st.
.1853	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1856	7d 21 06	adc $0621,x			adc 	xsIntLow+1,x
.1859	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.185c	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.185f	7d 41 06	adc $0641,x			adc 	xsIntHigh+1,x
.1862	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1865					_MultNoAdd:
.1865	1e 21 06	asl $0621,x			asl 	xsIntLow+1,x 				; shift 2nd left
.1868	3e 41 06	rol $0641,x			rol 	xsIntHigh+1,x
.186b	a5 05		lda $05				lda 	zTemp2	 					; until multiplier is zero
.186d	05 06		ora $06				ora 	zTemp2+1
.186f	d0 db		bne $184c			bne 	_MultLoop
.1871	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/divide.asm

.1872					Divide16x16:
.1872	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.1875	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.1878	90 03		bcc $187d			bcc 	_Integer
.187a	4c 34 1b	jmp $1b34			jmp 	FPDivide
.187d					_Integer:
.187d	20 9e 18	jsr $189e			jsr 	IntegerDivide
.1880	60		rts				rts
.1881					Modulus16x16:
.1881	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.1884	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; check numeric, returns CC if both integer.
.1887	90 03		bcc $188c			bcc 	_Integer
.1889	4c 34 1b	jmp $1b34			jmp 	FPModulus
.188c					_Integer:
.188c	20 9e 18	jsr $189e			jsr 	IntegerDivide
.188f	a5 03		lda $03				lda 	zTemp1
.1891	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1894	a5 04		lda $04				lda 	zTemp1+1
.1896	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1899	60		rts				rts
.189a					UnsignedIntegerDivide:
.189a	64 0b		stz $0b				stz 	SignCount 					; Count of signs.
.189c	80 1e		bra $18bc			bra 	DivideMain
.189e					IntegerDivide:
.189e	bd 21 06	lda $0621,x			lda 	xsIntLow+1,x 				; check for division by zero.
.18a1	1d 41 06	ora $0641,x			ora 	xsIntHigh+1,x
.18a4	d0 14		bne $18ba			bne 	_BFDOkay
.18a6	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>18a9	44 69 76 69 73 69 6f 6e				.text 	"Division by Zero",0
>18b1	20 62 79 20 5a 65 72 6f 00
.18ba					_BFDOkay:
.18ba	64 0b		stz $0b				stz 	SignCount 					; Count of signs.
.18bc					DivideMain:
.18bc	64 03		stz $03				stz 	zTemp1 						; Q/Dividend/Left in +0
.18be	64 04		stz $04				stz 	zTemp1+1 					; M/Divisor/Right in +1
.18c0	5a		phy				phy 								; Y is the counter, save position
.18c1	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.18c3					_BFDLoop:
.18c3	1e 20 06	asl $0620,x			asl 	xsIntLow,x 					; shift AQ left.
.18c6	3e 40 06	rol $0640,x			rol 	xsIntHigh,x
.18c9	26 03		rol $03				rol 	zTemp1
.18cb	26 04		rol $04				rol 	zTemp1+1
.18cd	38		sec				sec
.18ce	a5 03		lda $03				lda 	zTemp1+0 					; Calculate A-M on stack.
.18d0	fd 21 06	sbc $0621,x			sbc 	xsIntLow+1,x
.18d3	48		pha				pha
.18d4	a5 04		lda $04				lda 	zTemp1+1
.18d6	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.18d9	90 0f		bcc $18ea			bcc 	_BFDNoAdd
.18db	85 04		sta $04				sta 	zTemp1+1
.18dd	68		pla				pla
.18de	85 03		sta $03				sta 	zTemp1+0
.18e0	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; set Q bit 1.
.18e3	09 01		ora #$01			ora 	#1
.18e5	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.18e8	80 01		bra $18eb			bra 	_BFDNext
.18ea					_BFDNoAdd:
.18ea	68		pla				pla 								; Throw away the intermediate calculations
.18eb					_BFDNext:
.18eb	88		dey				dey
.18ec	d0 d5		bne $18c3			bne 	_BFDLoop
.18ee	7a		ply				ply 								; restore Y
.18ef	46 0b		lsr $0b				lsr 	SignCount 					; if sign count odd,
.18f1	90 03		bcc $18f6			bcc 	_BFDUnsigned 				; then the result is signed
.18f3	20 fd 18	jsr $18fd			jsr		IntegerNegate 				; negate the result
.18f6					_BFDUnsigned:
.18f6	60		rts				rts
.18f7					CheckIntegerNegate:
.18f7	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; is it -ve = MSB set ?
.18fa	30 01		bmi $18fd			bmi 	IntegerNegate 				; if so negate it
.18fc	60		rts				rts
.18fd					IntegerNegate:
.18fd	e6 0b		inc $0b				inc 	SignCount 					; bump the count of signs
.18ff	38		sec				sec 								; negate
.1900	a9 00		lda #$00			lda 	#0
.1902	fd 20 06	sbc $0620,x			sbc 	xsIntLow,x
.1905	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1908	a9 00		lda #$00			lda 	#0
.190a	fd 40 06	sbc $0640,x			sbc 	xsIntHigh,x
.190d	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1910	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/icompare.asm

.1911					Compare_Equals:
.1911	18		clc				clc
.1912	80 01		bra $1915			bra 	CEMain
.1914					Compare_NotEquals:
.1914	38		sec				sec
.1915					CEMain:
.1915	08		php				php 								; carry set flips the result
.1916	20 3f 19	jsr $193f			jsr 	EqualityComparison
.1919					CEWriteResult:
.1919	28		plp				plp  								; get the flip flag
.191a	90 02		bcc $191e			bcc 	_CENoFlip
.191c	49 ff		eor #$ff			eor 	#$FF 						; if so invert the result
.191e					_CENoFlip:
.191e	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; write it out
.1921	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1924	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; its an integer
.1927	60		rts				rts
.1928					Compare_GreaterEquals:
.1928	18		clc				clc
.1929	80 01		bra $192c			bra 	GEMain
.192b					Compare_Less:
.192b	38		sec				sec
.192c					GEMain:
.192c	08		php				php 								; carry set flips the result
.192d	20 6b 19	jsr $196b			jsr 	MagnitudeComparison
.1930	80 e7		bra $1919			bra 	CEWriteResult
.1932					Compare_LessEquals:
.1932	18		clc				clc
.1933	80 01		bra $1936			bra 	LEMain
.1935					Compare_Greater:
.1935	38		sec				sec
.1936					LEMain:
.1936	08		php				php 								; carry set flips the result
.1937	20 99 19	jsr $1999			jsr 	SwapStackTop 				; swap the top two over. Not that efficient, probably doesn't matter
.193a	20 6b 19	jsr $196b			jsr 	MagnitudeComparison 		; so the comparison is backwards.
.193d	80 da		bra $1919			bra 	CEWriteResult
.193f					EqualityComparison:
.193f	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.1942	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.1945	50 06		bvc $194d			bvc 	_NumericType
.1947	20 70 17	jsr $1770			jsr 	BinaryStringTypeCheck 		; check both are strings
.194a	4c ae 12	jmp $12ae			jmp 	SyntaxError 							; and do the string handler
.194d					_NumericType:
.194d	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; see if they are compatible.
.1950	90 03		bcc $1955			bcc 	_Integer
.1952	4c 34 1b	jmp $1b34			jmp 	FPEquality
.1955					_Integer:
.1955	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1958	dd 21 06	cmp $0621,x			cmp 	xsIntLow+1,x
.195b	d0 0b		bne $1968			bne 	_NECFail
.195d	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.1960	dd 41 06	cmp $0641,x			cmp 	xsIntHigh+1,x
.1963	d0 03		bne $1968			bne 	_NECFail
.1965	a9 ff		lda #$ff			lda 	#$FF
.1967	60		rts				rts
.1968					_NECFail:
.1968	a9 00		lda #$00			lda 	#$00
.196a	60		rts				rts
.196b					MagnitudeComparison:
.196b	20 0f 17	jsr $170f			jsr 	DeReferenceBinary 			; convert references to values
.196e	3c 00 06	bit $0600,x			bit 	xsStatus,x 					; is this a string ?
.1971	50 06		bvc $1979			bvc 	_NumericType
.1973	20 70 17	jsr $1770			jsr 	BinaryStringTypeCheck 		; check both are strings
.1976	4c ae 12	jmp $12ae			jmp 	SyntaxError 							; and do the string handler
.1979					_NumericType:
.1979	20 53 17	jsr $1753			jsr 	BinaryNumberTypeCheck 		; see if they are compatible.
.197c	90 03		bcc $1981			bcc 	_Integer
.197e	4c 34 1b	jmp $1b34			jmp 	FPMagnitude
.1981					_Integer:
.1981	bd 20 06	lda $0620,x			lda 	xsIntLow,x
.1984	dd 21 06	cmp $0621,x			cmp 	xsIntLow+1,x
.1987	bd 40 06	lda $0640,x			lda 	xsIntHigh,x
.198a	fd 41 06	sbc $0641,x			sbc 	xsIntHigh+1,x
.198d	50 02		bvc $1991			bvc 	_MCNoOverflow
.198f	49 80		eor #$80			eor 	#$80
.1991					_MCNoOverflow:
.1991	30 03		bmi $1996			bmi 	_NECFail
.1993	a9 ff		lda #$ff			lda 	#$FF
.1995	60		rts				rts
.1996					_NECFail:
.1996	a9 00		lda #$00			lda 	#$00
.1998	60		rts				rts
.1999					SwapStackTop:
.1999	da		phx				phx
.199a	5a		phy				phy
.199b	a0 06		ldy #$06			ldy 	#6 							; swap count
.199d					_SSTLoop:
.199d	bd 00 06	lda $0600,x			lda 	xsStatus,x 					; the first stack entry, flip it over.
.19a0	48		pha				pha
.19a1	bd 01 06	lda $0601,x			lda 	xsStatus+1,x
.19a4	9d 00 06	sta $0600,x			sta 	xsStatus,x
.19a7	68		pla				pla
.19a8	9d 01 06	sta $0601,x			sta 	xsStatus+1,x
.19ab	8a		txa				txa 								; go forward to the next stack chunk.
.19ac	18		clc				clc
.19ad	69 20		adc #$20			adc 	#stackSize
.19af	aa		tax				tax
.19b0	88		dey				dey 								; do it for the whole of this stack
.19b1	d0 ea		bne $199d			bne 	_SSTLoop
.19b3	7a		ply				ply
.19b4	fa		plx				plx
.19b5	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/random.asm

.19b6					RandomNumber:
.19b6	20 c9 19	jsr $19c9			jsr 	AdvanceRandomSeed 			; bytes seperately as zero problem.
.19b9	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.19bc	20 c9 19	jsr $19c9			jsr 	AdvanceRandomSeed
.19bf	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.19c2	9e 00 06	stz $0600,x			stz 	xsStatus,x
.19c5	20 8a 14	jsr $148a			jsr 	SyntaxCheckRightBracket 	; check followed by )
.19c8	60		rts				rts
.19c9					AdvanceRandomSeed:
.19c9	a5 0d		lda $0d				lda 	randomSeed
.19cb	05 0e		ora $0e				ora 	randomSeed+1
.19cd	d0 08		bne $19d7			bne 	_RH_NoInit
.19cf	a9 7c		lda #$7c			lda 	#$7C
.19d1	85 0d		sta $0d				sta 	randomSeed
.19d3	a9 a1		lda #$a1			lda 	#$A1
.19d5	85 0e		sta $0e				sta 	randomSeed+1
.19d7					_RH_NoInit:
.19d7	a5 0d		lda $0d				lda 	randomSeed
.19d9	4a		lsr a		        lsr		a
.19da	26 0e		rol $0e		        rol 	randomSeed+1
.19dc	90 02		bcc $19e0	        bcc 	_RH_NoEor
.19de	49 b4		eor #$b4	        eor 	#$B4
.19e0					_RH_NoEor:
.19e0	85 0d		sta $0d		        sta 	randomSeed
.19e2	45 0e		eor $0e		        eor 	randomSeed+1
.19e4	60		rts		        rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/tostring.asm

.19e5					PrintYA:
.19e5	a2 00		ldx #$00			ldx 	#0 							; put on stack.
.19e7	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.19ea	98		tya				tya
.19eb	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.19ee	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; tell system it is an integer.
.19f1	a9 0a		lda #$0a			lda 	#10 						; base
.19f3	20 fa 19	jsr $19fa			jsr 	ConvertIntegerUnsigned 		; unsigned integer conversion.
.19f6	20 04 14	jsr $1404			jsr 	EXPrintString 				; print the result
.19f9	60		rts				rts
.19fa					ConvertIntegerUnsigned:
.19fa	da		phx				phx
.19fb	48		pha				pha 								; save base on stack
.19fc	64 0c		stz $0c				stz 	convertPtr 					; reset conversion position
.19fe	80 11		bra $1a11			bra 	CIMain
.1a00					ConvertIntegerSigned:
.1a00	da		phx				phx
.1a01	48		pha				pha 								; save base on stack.
.1a02	64 0c		stz $0c				stz 	convertPtr 					; reset conversion position
.1a04	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; is it -ve ?
.1a07	10 08		bpl $1a11			bpl 	CIMain
.1a09	20 fd 18	jsr $18fd			jsr 	IntegerNegate 				; make it positive
.1a0c	a9 2d		lda #$2d			lda 	#"-" 						; write a - sign out.
.1a0e	20 4a 1a	jsr $1a4a			jsr 	CIWriteCharacter
.1a11					CIMain:
.1a11	7a		ply				ply									; get base back
.1a12	a9 ff		lda #$ff			lda 	#$FF 						; push marker on stack.
.1a14	48		pha				pha
.1a15	5a		phy				phy  								; push base back.
.1a16					_CILoop:
.1a16	68		pla				pla 								; get and save base.
.1a17	48		pha				pha
.1a18	9d 21 06	sta $0621,x			sta 	xsIntLow+1,x 				; put it in the next stack level and set type
.1a1b	9e 41 06	stz $0641,x			stz 	xsIntHigh+1,x
.1a1e	9e 00 06	stz $0600,x			stz 	xsStatus,x
.1a21	20 9a 18	jsr $189a			jsr 	UnsignedIntegerDivide 		; divide.
.1a24	7a		ply				ply 								; get base into Y
.1a25	a5 03		lda $03				lda 	zTemp1 						; push the remainder on the stack.
.1a27	48		pha				pha
.1a28	5a		phy				phy 								; push the base back.
.1a29	bd 20 06	lda $0620,x			lda 	xsIntLow,x 					; complete
.1a2c	1d 40 06	ora $0640,x			ora 	xsIntHigh,x
.1a2f	d0 e5		bne $1a16			bne 	_CILoop
.1a31	68		pla				pla 								; throw the base
.1a32					_CIUnpack:
.1a32	68		pla				pla 								; pull off stack so in the right order
.1a33	30 0f		bmi $1a44			bmi 	_CIExit
.1a35	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.1a37	90 03		bcc $1a3c			bcc 	_CINotAlpha
.1a39	18		clc				clc
.1a3a	69 07		adc #$07			adc 	#7
.1a3c					_CINotAlpha:
.1a3c	18		clc				clc
.1a3d	69 30		adc #$30			adc 	#48
.1a3f	20 4a 1a	jsr $1a4a			jsr 	CIWriteCharacter 			; keep going till reach the marker
.1a42	80 ee		bra $1a32			bra 	_CIUnpack
.1a44					_CIExit:
.1a44	fa		plx				plx
.1a45	a9 00		lda #$00			lda 	#textBuffer & $FF 			; return with pointer in YA
.1a47	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.1a49	60		rts				rts
.1a4a					CIWriteCharacter:
.1a4a	da		phx				phx
.1a4b	a6 0c		ldx $0c				ldx		convertPtr
.1a4d	9d 00 08	sta $0800,x			sta 	textBuffer,x
.1a50	9e 01 08	stz $0801,x			stz 	textBuffer+1,x
.1a53	fa		plx				plx
.1a54	e6 0c		inc $0c				inc 	convertPtr
.1a56	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: expression/integer/unary.asm

.1a57					Dummy_Binary:
.1a57					Dummy_Hex:
.1a57	20 09 17	jsr $1709			jsr 	EvaluateTermAtX
.1a5a	60		rts				rts
.1a5b					Parenthesis:
.1a5b	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; parenthesised expression
.1a5e	20 8a 14	jsr $148a			jsr 	SyntaxCheckRightBracket 	; check followed by )
.1a61	60		rts				rts
.1a62					AbsoluteValue:
.1a62	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1a65	20 14 17	jsr $1714			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1a68	20 4e 17	jsr $174e			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1a6b	90 03		bcc $1a70			bcc 	_Integer
.1a6d	4c 77 1a	jmp $1a77			jmp 	AVFloat
.1a70					_Integer:
.1a70	20 f7 18	jsr $18f7			jsr 	CheckIntegerNegate 			; use absolute value in divide
.1a73	20 8a 14	jsr $148a			jsr 	SyntaxCheckRightBracket
.1a76	60		rts				rts
.1a77					AVFloat:
.1a77	20 34 1b	jsr $1b34			jsr 	FPAbs
.1a7a	20 8a 14	jsr $148a			jsr 	SyntaxCheckRightBracket
.1a7d	60		rts				rts
.1a7e					SignValue:
.1a7e	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1a81	20 14 17	jsr $1714			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1a84	20 4e 17	jsr $174e			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1a87	90 03		bcc $1a8c			bcc 	_Integer
.1a89	4c ac 1a	jmp $1aac			jmp 	SVFloat
.1a8c					_Integer:
.1a8c	20 8a 14	jsr $148a			jsr 	SyntaxCheckRightBracket
.1a8f	bd 40 06	lda $0640,x			lda 	xsIntHigh,x 				; Check zero
.1a92	1d 20 06	ora $0620,x			ora 	xsIntLow,x
.1a95	f0 05		beq $1a9c			beq 	_SVSetLH
.1a97	0a		asl a				asl 	a 							; msb into carry
.1a98	90 09		bcc $1aa3			bcc 	_SVGreater0 				; if CC then it's positive and non zero
.1a9a	a9 ff		lda #$ff			lda 	#$FF 						; -ve so return -1
.1a9c					_SVSetLH:
.1a9c	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1a9f	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1aa2	60		rts				rts
.1aa3					_SVGreater0:
.1aa3	a9 01		lda #$01			lda 	#1
.1aa5	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1aa8	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.1aab	60		rts				rts
.1aac					SVFloat:
.1aac	20 34 1b	jsr $1b34			jsr 	FPSgn
.1aaf	20 8a 14	jsr $148a			jsr 	SyntaxCheckRightBracket
.1ab2	60		rts				rts
.1ab3					StringLength:
.1ab3	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1ab6	20 14 17	jsr $1714			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1ab9	20 75 17	jsr $1775			jsr 	UnaryStringTypeCheck 		; check string.
.1abc	20 8a 14	jsr $148a			jsr 	SyntaxCheckRightBracket
.1abf	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; put address of string into zTemp1
.1ac2	85 03		sta $03				sta 	zTemp1
.1ac4	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.1ac7	85 04		sta $04				sta 	zTemp1+1
.1ac9	b2 03		lda ($03)			lda 	(zTemp1)					; get the length (strings are len prefixed)
.1acb	9d 20 06	sta $0620,x			sta 	xsIntLow,x 					; and return it
.1ace	9e 40 06	stz $0640,x			stz 	xsIntHigh,x
.1ad1	9e 00 06	stz $0600,x			stz 	xsStatus,x
.1ad4	60		rts				rts
.1ad5					PeekMemory:
.1ad5	18		clc				clc
.1ad6	80 01		bra $1ad9			bra 	ReadMemoryMain
.1ad8					DeekMemory:
.1ad8	38		sec				sec
.1ad9					ReadMemoryMain:
.1ad9	08		php				php 								; CS read word CC read byte
.1ada	20 3b 16	jsr $163b			jsr 	EvaluateExpressionAtX 		; evaluate the term
.1add	20 14 17	jsr $1714			jsr 	DeReferenceUnary 			; convert term to value if reference.
.1ae0	20 4e 17	jsr $174e			jsr 	UnaryNumberTypeCheck 		; check numeric, returns CC if integer.
.1ae3	90 03		bcc $1ae8			bcc 	_Integer
.1ae5	4c cf 12	jmp $12cf			jmp 	ParameterError
.1ae8					_Integer:
.1ae8	20 8a 14	jsr $148a			jsr 	SyntaxCheckRightBracket
.1aeb	bd 20 06	lda $0620,x			lda 	xsAddrLow,x 				; transfer address
.1aee	85 03		sta $03				sta 	zTemp1
.1af0	bd 40 06	lda $0640,x			lda 	xsAddrHigh,x
.1af3	85 04		sta $04				sta 	zTemp1+1
.1af5	b2 03		lda ($03)			lda 	(zTemp1) 					; do the LSB
.1af7	9d 20 06	sta $0620,x			sta 	xsIntLow,x
.1afa	9e 40 06	stz $0640,x			stz 	xsIntHigh,x 				; zero MSB
.1afd	9e 00 06	stz $0600,x			stz 	xsStatus,x 					; set the type
.1b00	28		plp				plp
.1b01	90 09		bcc $1b0c			bcc 	_RMMPeek 					; read type
.1b03	5a		phy				phy
.1b04	a0 01		ldy #$01			ldy 	#1
.1b06	b1 03		lda ($03),y			lda 	(zTemp1),y
.1b08	9d 40 06	sta $0640,x			sta 	xsIntHigh,x
.1b0b	7a		ply				ply
.1b0c					_RMMPeek:
.1b0c	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: variables/variable.asm

.1b0d					VariableLookup:
.1b0d	c9 1a		cmp #$1a			cmp 	#26 						; multi character variables.
.1b0f	b0 13		bcs $1b24			bcs 	_VLError
.1b11	0a		asl a				asl 	a 							; multiply by 5, do not move for float
.1b12	0a		asl a				asl 	a
.1b13	71 00		adc ($00),y			adc 	(codePtr),y
.1b15	c8		iny				iny 								; skip over variable token
.1b16	9d 20 06	sta $0620,x			sta 	xsAddrLow,x
.1b19	a9 07		lda #$07			lda 	#variables >> 8
.1b1b	9d 40 06	sta $0640,x			sta 	xsAddrHigh,x
.1b1e	a9 01		lda #$01			lda 	#$01 						; integer reference.
.1b20	9d 00 06	sta $0600,x			sta 	xsStatus,x
.1b23	60		rts				rts
.1b24					_VLError:
.1b24	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>1b27	42 61 64 20 56 61 72 69				.text 	"Bad Variable",0
>1b2f	61 62 6c 65 00

;******  Return to file: files.asm


;******  Processing file: expression/float/floatdummy.asm

.1b34					FPAdd:
.1b34					FPSub:
.1b34					FPMultiply:
.1b34					FPDivide:
.1b34					FPModulus:
.1b34					FPAbs:
.1b34					FPSgn:
.1b34					FPFloatToInteger:
.1b34					FPIntegerToFloat:
.1b34					FPEquality:
.1b34					FPMagnitude:
.1b34	20 dc 12	jsr $12dc			jsr 	ErrorHandler
>1b37	46 6c 6f 61 74 20 4e 6f				.text 	"Float Not Implemented",0
>1b3f	74 20 49 6d 70 6c 65 6d 65 6e 74 65 64 00

;******  Return to file: files.asm


;******  Return to file: basic.asm

.1b4d					ColdStart:
.1b4d	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1b4f	9a		txs				txs
.1b50	20 11 13	jsr $1311			jsr 	ExternInitialise
.1b53	a9 60		lda #$60			lda 	#BootMessage & $FF
.1b55	a0 1b		ldy #$1b			ldy 	#BootMessage >> 8
.1b57	20 04 14	jsr $1404			jsr 	EXPrintString
.1b5a	4c ee 15	jmp $15ee			jmp 	Command_Run
.1b5d					WarmStart:
.1b5d	4c ff ff	jmp $ffff			jmp 	$FFFF
.1b60					BootMessage:
>1b60	2a 2a 2a 2a 20 43 6f 6d				.text 	"**** Commander X16 Basic ****",13,13
>1b68	6d 61 6e 64 65 72 20 58 31 36 20 42 61 73 69 63
>1b78	20 2a 2a 2a 2a 0d 0d
>1b7f	35 31 32 4b 20 48 69 67				.text 	"512K High RAM.",13,13
>1b87	68 20 52 41 4d 2e 0d 0d
>1b8f	50 72 65 2d 41 6c 70 68				.text 	"Pre-Alpha. "
>1b97	61 2e 20

;******  Processing file: generated/buildinfo.inc

>1b9a	42 75 69 6c 64 3a 31 37			.text	"Build:179 (08-Feb-20 19:20)"
>1ba2	39 20 28 30 38 2d 46 65 62 2d 32 30 20 31 39 3a
>1bb2	32 30 29

;******  Return to file: basic.asm

>1bb5	0d 0d 00					.byte 	13,13,0
.1bb8					BasicProgram:

;******  End of listing
